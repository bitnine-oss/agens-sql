<!-- doc/src/sgml/backup.sgml -->

<chapter id="backup">
 <title>백업과 복원</title>

 <indexterm zone="backup"><primary>백업</></>

 <para>
  모든 데이터베이스 시스템이 그렇듯이, 
  <productname>Agens SQL</> 데이터베이스 백업은 아주 중요한 사항이다.
  대부분의 서비스는 그 중요한 자료들은 대부분 데이터베이스에 보관하고 있기 때문이다.
  백업과 복원(restore) 과정은 비교적 간단한 작업이지만, 
  이 과정에 기술적인 부분과 개념적인 부분에 대해서 분명하게 숙지해 둘 필요가 
  있다.
 </para>

 <para>
  이 장에서는 <productname>Agens SQL</> 자료를 백업하는
  세 가지 서로 다른 방법을 소개하고 있다:
  <itemizedlist>
   <listitem><para><acronym>SQL</> 덤프</para></listitem>
   <listitem><para>파일 시스템 기반 백업</para></listitem>
   <listitem><para>아카이브 모드 백업</para></listitem>
  </itemizedlist>
  윗 방법들은 서로 장단점이 있다. 이것들에 대한 자세한 설명은 다음 각 절에서 설명하고 있다.
 </para>

 <sect1 id="backup-dump">
  <title><acronym>SQL</> 덤프</title>

  <para>
   이 방법은 백업 프로그램이 백업 대상에 대해서, 
   SQL 구문의 파일을 만들고, 
   복원을 할 때는 서버에 이 SQL 구문을 실행해서, 
   백업 할 때의 상태로 만드는 기법이다.
   이 방법을 구현한 <productname>Agens SQL</> 
   유틸리티 프로그램이 pg dump 이다.
   기본적인 사용법은 다음과 같다:
<synopsis>
pg_dump <replaceable class="parameter">데이터베이스이름</replaceable> &gt; <replaceable class="parameter">출력파일</replaceable>
</synopsis>
   위와 같이, <application>pg_dump</> 명령의 결과는 
   표준 출력(stdout)으로 출력된다.
   다음 글에서 이 프로그램이 얼마나 유용하게 쓰이는 지 알 수 있을 것이다.
   위 명령은 텍스트 파일을 만들지만, <application>pg_dump</> 명령에 
   부가 옵션들을 사용하면, 복원 작업 시 보다 섬세한 처리나 
   병렬 처리를 할 수 있도록 텍스트가 아닌 다른 양식으로도 만들 수 있다.
  </para>

  <para>
   <application>pg_dump</> 프로그램은 여느 <productname>Agens SQL</>
   클라이언트 응용 프로그램과 같다(특히 잘 만들어진).
   이 말은 원격 데이터베이스 서버에 대해서, 
   그 접속 권한이 있다면, 그 접속 가능한 다른 호스트에서 이 명령을 실행 할 수 있음을 
   의미한다. 단지, 덤프 작업을 하기 때문에, 
   필요에 따라서,
   스키마의 접근 권한이 있어야 하고, 테이블의 읽기 권한이 있어야 하는 등,
   그 적절한 접근 권한이 있어야한다. 
   대부분 실무에서는 이 작업은 데이터베이스 슈퍼유저로 실행된다. 
   (물론 해당 데이터베이스 전체를 백업할 수 없는 일반 유저 권한이라도,
   <option>-n <replaceable>schema</replaceable></option>
   또는 <option>-t <replaceable>table</replaceable></option> 옵션을 사용해서
   자신이 접근 할 수 있는 객체만 백업 할 수 있다.)
  </para>

  <para>
   <application>pg_dump</> 프로그램을 실행해서, 
   원격 데이터베이스 서버를 지정하기 위해서는
   <option>-h <replaceable>호스트이름</></>, <option>-p <replaceable>포트</></>
   옵션을 사용한다.
   <option>-h</> 옵션을 사용하지 않으면, 
   먼저 <envar>PGHOST</envar> 시스템 환경 변수에서 지정된 호스트로 접속을 
   시도하며, 이 값이 지정되어 있지 않으면, 로컬 호스트로 접속한다.
   <option>-p</> 옵션을 사용하지 않으며,
   먼저 <envar>PGPORT</envar> 시스템 환경 변수에서 지정된 포트로 접속을
   시도하며, 이 값이 지정되어 있지 않으면, 
   이 프로그램이 컴파일 될 때 지정한 포트로 접속한다.
  </para>

  <para>
   다른 <productname>Agens SQL</> 클라이언트 응용 프로그램과 
   마찬가지로, <application>pg_dump</> 프로그램도, 
   데이터베이스 사용자 계정을 특별히 지정하지 않으면, 
   현재의 운영체제 시스템 사용자 계정의 이름을 사용한다.
   데이터베이스 사용자 계정을 지정하려면, 
   <option>-U</option> 옵션을 사용하며, 
   <envar>PGUSER</envar> 시스템 환경 변수로도 이 데이터베이스 사용자 계정을
   지정할 수 있으며, 이 값의 사용 우선 순위도 위의 다른 
   시스템 환경 변수들과 같다.
   위에서 언급한 대로 <application>pg_dump</> 프로그램의 데이터베이스
   접속은 클라이언트 인증 메카니즘을 사용한다. 이에 대한
   보다 자세항 사항은 <xref
      linkend="client-authentication">에서 다룬다.
  </para>

  <para>
   <application>pg_dump</> 프로그램을 이용한 데이터베이스 백업방법은 
   파일 시스템 기반  백업과, 아카이브 모드 백업 방법에 비교해서,
   다음과 같은 잇점이 있다. 먼저 복원 서버의 버전이 백업 서버의 버전보다
   더 최신 것이도 복원이 가능하다.
   다음, 32-bit, 64-bit와 같은 머신 아키텍처가 서로 틀려도 가능하다.
  </para>

  <para>
   <application>pg_dump</> 프로그램이 실행되면, 그 실행되는 시점의
   스냅샷 상태로 작업을 진행한다.
   <application>pg_dump</> 프로그램이 실행되는 동안, 다른 세션에서
   <command>ALTER TABLE</command> 명령과 같이 exclusive lock이 발생하지 
   않는 상태라면, 대부분의 작업은 특별한 잠김 없이 작업을 진행한다.
  </para>

  <sect2 id="backup-dump-restore">
   <title>덤프 파일 복원하기</title>

   <para>
    <application>pg_dump</> 프로그램으로 만든 텍스트 덤프 파일은
        <application>psql</application> 프로그램에서 바로 사용할 수 있다. 
        일반적인 사용법은 다음과 같다:
<synopsis>
psql <replaceable class="parameter">데이터베이스이름</replaceable> &lt; <replaceable class="parameter">입력파일</replaceable>
</synopsis>
    <replaceable class="parameter">입력파일</replaceable> 자리에, 
        <application>pg_dump</> 명령으로 만든 덤프 파일을 지정한다.
        <replaceable class="parameter">dbname</replaceable> 자리에는
        <application>psql</> 클라이언트가 접속 해서, 
        덤프 파일의 명령을 실행할 데이터베이스 이름을 지정한다. 
        주의 할 점은 윗 명령으로 해당 데이터베이스가 만들어지지는 않는다. 
        <application>psql</> 명령을 실행하기 전에 먼저 
        <literal>createdb -T template0 <replaceable
            class="parameter">데이터베이스이름</></literal> 명령과 같이
    먼저 접속할 데이터베이스를 만들어 놓아야한다. 
    <application>psql</> 프로그램도 <application>pg_dump</> 프로그램과 
        마찬가지로 데이터베이스 접속과 관련된 접속 인증 방식으로 
        환경변수와, 명령행 옵션의 사용법이 같다.
    <application>psql</> 프로그램에 대한 자세한 설명은 psql
        설명서에서 다룬다.  일반 텍스트 덤프 파일이 아닌 백업 파일을 복원할 경우는
        pg restore 명령을 이용한다.
   </para>

   <para>
    SQL 덤프 파일 안에는 각 객체의 접근 권한을 지정하는 명령도 
        포함되어 있기 때문에, 그 덤프 파일 안에서 사용하는 모든 사용자들도 
        새 데이터베이스에 미리 만들어야한다.
        해당 사용자가 없다면, 이 접근 권한 설정하는 명령어들은 모두 
        실패할 것이다. (가끔 이것을 의도해서 이렇게 처리하기도 하지만, 
        일반적인 방법은 아니다.)
   </para>

   <para>
    기본적으로  <application>psql</> 스크립트는 해당 작업 도중
        오류가 발생하면, 멈추지 않고, 다음 작업을 진행한다.
        만일 이런 기능을 원치 않으며, <application>psql</application> 프로그램을
        실행 할 때, <literal>ON_ERROR_STOP</> 변수를 지정한다.
        이렇게 하면, 스크립트 실행 도중 오류가 발생하면, 
        바로 스크립트는 중지되고, <application>psql</application> 실행 
        리턴 코드 3으로 종료된다.
    다음은 그 사용 방법이다:
<programlisting>
psql --set ON_ERROR_STOP=on dbname &lt; infile
</programlisting>
    이 방법은 스크립트에서 정상적으로 실행된 작업들에 대해서는
        해당 데이터베이스에 반영되었다는 것을 의미한다. 
        이것도 원치 않고, 트랜잭션 처리 방식 처럼, 
        모든 스크립트가 정상 처리되어야만 전체가 반영되길 원한다면, 
        <option>-1</> 또는 <option>--single-transaction</> 옵션을 사용해서, 
        스크립트 전체를 하나의 트랜잭션으로 처리하도록 한다.
        단점은 많은 작업을 해야하는데, 작은 오류 하나로, 
        전체가 롤백 되면서 많은 시간을 소비할 수 있다는 점이다.
        대신에 오류가 발생되면 수동으로 일일히 복잡한 데이터베이스 정리
        작업을 하지 않아도 된다.
   </para>

   <para>
    <application>pg_dump</>, <application>psql</> 두 프로그램 모두
        표준 입출력을 사용할 수 있기 때문에, 
        파이프를 사용한다면, 덤프 하면서 바로 다른 데이터베이스 서버에 
        복원할 수도 있다. 사용법은 다음과 같다:
<programlisting>
pg_dump -h <replaceable>호스트1</> <replaceable>데이터베이스이름</> | psql -h <replaceable>호스트2</> <replaceable>데이터베이스이름</>
</programlisting>
   </para>

   <important>
    <para>
         <application>pg_dump</> 명령으로 만들어지는 결과물은
         <literal>template0</> 데이터베이스 기반으로 변경된 모든 
         작업이 포함된다. 그래서, 프로시져 언어, 확장 모듈과 관련된 
         함수들이 모두 포함되어있다. 
         만일 사용의 편의를 위해서, 이런 기반 작업들을 <literal>template1</>
         데이터베이스에 해 두었다면, 일반적인 방법으로 데이터베이스를 만들면, 
         이 <literal>template1</> 데이터베이스를 참조해서 만들기 때문에, 
         복원 작업에서 충돌이 발생할 수 있다. 이것을 방지하기 위해서는 
         위에서 언급한 대로 <literal>template0</> 데이터베이스를 참조해서, 
         새 데이터베이스를 만들어서 사용하는 것이 바람직하다.
    </para>
   </important>

   <para>
    백업 파일의 복원 작업이 끝난 뒤에는 
        쿼리 최적화기가 올바른 통계 정보를 사용할 수 있도록, 
        ANALYZE 명령을 실행 한다.
        <xref linkend="vacuum-for-statistics">과
        <xref linkend="autovacuum"> 참조.
        대용량 데이터베이스 작업에서 보다 낳은 성능을 고려한다면,
    <xref linkend="vacuum-for-statistics">을 참조해서, 
        덤프, 복원 작업을 하기 전에 먼저 서버 환경을 변경하고, 
        작업을 진행하는 것도 좋은 방법이다.
   </para>
  </sect2>

  <sect2 id="backup-dump-all">
   <title><application>pg_dumpall</> 명령어 이용하기</title>

   <para>
    <application>pg_dump</> 명령어는 지정한 하나의 데이터베이스만
        한 번에 백업한다. 또한 데이터베이스 객체에 속하지 않는 
        role(데이터베이스 사용자), 테이블스페이스 정보는 백업되지 않는다.
        데이터베이스 클러스터 기준 모든 정보를 백업받으려면, 
        pg dumpall 프로그램을 이용한다. 
        일반적인 사용법은 다음과 같다:
<synopsis>
pg_dumpall &gt; <replaceable>outfile</>
</synopsis>
    이 덤프 파일은 <application>psql</> 프로그램에서 다음과 같이 사용한다:
<synopsis>
psql -f <replaceable class="parameter">덤프파일</replaceable> postgres
</synopsis>
    (정확하게는, 데이터베이스 서버에 접속하기 위해서, <literal>postgres</>
        데이터베이스 이름을 지정한 것 뿐이지, 실재로는 접속이 끝나면, 
        바로 이 데이터베이스에서 작업하기 전에 먼저 데이터베이스 클러스터 전역
        정보부터 복원 작업을 시작한다.)
        <application>pg_dumpall</> 명령을 사용할 때는 접속할 해당 데이터베이스의
        슈퍼유저로 접속해야한다. 그래야, role, 테이블스페이스 정보들을 
        덤프할 수 있다. 또한 이 덤프된 자료를 복원 할 때도 마찬가지다.
        주의 할 점은 만일 기본 테이블스페이스 외에 다른 테이블스페이스를 사용한다면, 
        그 테이블스페이스의 실재 디렉토리도 덤프 하는 서버에서 사용하는 경로와
        똑같이 만들어 놓아야한다.
   </para>

   <para>
    <application>pg_dumpall</> 명령은 먼저, 데이터베이스 사용자를 위한
        role 정보, 다음 테이블스페이스 정보, 다음 기본 템플릿 데이터베이스에 대한 
        덤프 작업을 한 다음, 각 데이터베이스를 덤프하기 위해, <application>pg_dump</>
        프로그램을 호출 한다. 이 말은 각 데이터베이스가 각기 다른 시간에 
        백업 작업을 진행 하기 때문에 데이터베이스간 똑 같은 시간대의 스냅샷 형태의 
        자료 덤프는 불가능하다는 의미다.
   </para>

   <para>
    데이터베이스 클러스터의 서버 전역 객체들만 백업하려면, 
    <application>pg_dumpall</> <option>--globals-only</> 옵션을
    이용한다.  이 경우는 <application>pg_dump</> 명령을 이용해서
    각각의 데이터베이스를 따로 백업해서 복원하려고 할 때, 
    필요하다.
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
   <title>대용량 데이터베이스 다루기</title>

   <para>
    몇몇 운영체제는 만들 수 있는 최대 파일 크기가 제한 되어 있어, 
        <application>pg_dump</> 명령으로 만들어지는 파일이 이
        최대 파일 크기를 초과하는 경우 문제가 될 수 있다.
    다행이, <application>pg_dump</> 명령의 출력 내용을 표준 출력(stdout)으로 
        보낼 수 있기 때문에, 표준 유닉스 명령들을 이용한다면, 
        이런 잠재적인 문제를 피해갈 수 있다. 그 방법은 다음과 같이 여러가지다:
   </para>

   <formalpara>
    <title>덤프 내용을 압축하라.</title>
    <para>
     <application>gzip</application>과 같은 압축 프로그램을 사용하는 방법:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>

     복원 할 때는:

<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

     또는:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title><command>split</> 명령을 이용하라.</title>
    <para>
     <command>split</command> 명령은 표준 입력(stdin)으로 들어오는 내용을 
         지정한 크기로 나누워서 파일로 저장하는 기능을 제공한다.
     다음은 1MB 크기로 나눠서 덤프 파일을 생성하는 예제다:
     make chunks of 1 megabyte:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 1m - <replaceable class="parameter">filename</replaceable>
</programlisting>

     복원 할 때는:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
    <title><application>pg_dump</>의 사용자 정의 포멧 기능을 이용하라.</title>
    <para>
         만일 <productname>Agens SQL</productname> 배포판을 빌드 할 때, 
         <application>zlib</> 압축 라이브러를 사용할 수 있도록 했다면, 
         덤프 파일을 만들 때, 그 내용을 압축해서 만든다. 이 때 최종 덤프 파일은 
         <command>gzip</command> 프로그램으로 원본 덤프 파일을 압축 했을 때의
         크기만큼 줄일 수 있다. 또한 이 기능을 이용해서, 백업을 하면,
         테이블을 선택적으로 지정해서 그 테이블만 복원 할 수도 있다.
         다음은 사용자 정의 포멧을 지정해서 덤프 하는 예제다:

<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>

     이렇게 만들어진 덤프 파일은  <application>psql</>에서 사용할 수 있는 스크립트 파일이 아니다.
         그래서, 다음과 같이 <application>pg_restore</> 명령을 사용해서 복원 해야한다:

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>

     자세한 사용법은 pg dump, pg restore 사용설명서를 참조하라.
    </para>
   </formalpara>

   <para>
    엄청나게 큰 데이터베이스라면, <command>split</>  명령어와 함께 기타 다른 명령어들을 함께 
        연결해서 사용할 필요성도 있다.
   </para>

   <formalpara>
    <title><application>pg_dump</>의 병렬적 덤프 기능을 이용하라. </title>
    <para>
     대용량 데이터베이스의 덤프 속도를 높이기 위해서는 
     <application>pg_dump</application>의 병렬 모드를 사용하면 된다. 그러면 테이블들을 동시에 덤프한다. 병렬 처리 수준은 <command>-j</command> 매개변수로 조절할 수 있다.  병렬적 덤프는 “디렉토리” 아카이브 형식에만 지원된다.

<programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">out.dir</replaceable> <replaceable class="parameter">dbname</replaceable>
</programlisting>

     <command>pg_restore -j</command>를 이용해서 병렬적 덤프를 복구할 수 있다. 
     이 방식은 “사용자 정의” 혹은 “디렉터리” 아카이브 모드의 아카이브에서 가능하며 <command>pg_dump -j</command>로 만들어지지 않았어도 상관없다.
    </para>
   </formalpara>

  </sect2>
 </sect1>

 <sect1 id="backup-file">
  <title>파일 시스템 기반 백업</title>

  <para>
   백업 하는 다른 방법으로 <productname>Agens SQL</>에서 사용하는 
   데이터 저장 공간 전체를 직접 파일 복사하는 식으로 파일 시스템 차원에서
   처리하는 방식이 있다.
   해당 파일의 위치는 <xref linkend="creating-cluster">에서 자세히 
   설명하고 있다. 운영체제에서 파일 시스템 백업하는 것과 크게 틀리지 않다.
   예를 들면:

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>

  <para>
   위와 같은 명령으로 백업 할 수 있다. 하지만, 이 방식에는
   다음 두 가지 한계가 있어, 오히려, <application>pg_dump</> 명령을 사용하는 것보다
   실용적인 측면에서 별 도움이 안된다.

   <orderedlist>
    <listitem>
     <para>
          정상적인 백업 작업을 하려면, <emphasis>반드시</> 데이터베이스 서버를 
          중지해야한다. 모든 클라이언트의 접속을 막고 파일 시스템을 복사하는 방식도
          안전한 백업을 보장하지 않는다. 
          (<command>tar</command> 명령어나, 기타 이 비슷한 도구들 모두, 
          파일 시스템의 단위적(atomic) 스냅샷을 지원하지 않으며, 
          서버에서 사용하는 내부적인 버퍼링에 대한 정보를 정확하게 반영할 수 
          없기 때문이다.) 서버를 중지하는 방법은 <xref linkend="server-shutdown">에서
          다룬다. 또한 마찬가지로 복원 할 때는 반드시 서버는 중지된 상태여야한다.
     </para>
    </listitem>

    <listitem>
     <para>
          만일 데이터베이스에서 사용하는 각종 파일들의 위치와, 용도를 잘 알고 있어, 
          개별 데이터베이스나, 테이블에 해당하는 파일들만 복사해서 
          사용할 수 있을 것이다는 생각을 할 수도 있으나, 
          그렇게 한다고 해도, 커밋 로그 파일 없이는 정상으로 작동하지 않을 것이다.
          <filename>pg_clog/*</filename> 파일들이 모든 트랜잭션의 커밋 상태를 
          보관하고 있다. 이 로그 파일들은 테이블 단위가 아니라, 데이터베이스 크러스터
          단위로 처리되기 때문에, 개별 테이블의 물리적인 파일과, 로그 파일을 
          복사한다고 해도, 다른 테이블과 관계될 가능성이 있어, 
          부분 백업은 불가능하다.
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
   파일 시스템 기반 백업에서 또 하나 고려해야할 사항은 
   파일 시스템이 <quote>완전한 스냅샷(consistent snapshot)</> 기능을 제공한다면,
   (그리고, 이 기능이 신뢰성이 있다면)
   이 기능을 사용할 때 주의 해야한다는 점이다.
   이 파일 시스템 스냅샷 기능을 이용한 전형적인 백업 방법은
   먼저 <quote>현 시점 스냅샷 frozen snapshot</>을 만들고, 
   백업 장치로 모든 데이터 클러스터 모든 파일(위에서 언급했듯이, 부분 파일을 백업하는 것은 
   의미가 없다)을 복사하고, 잠긴 스냅샷을 푸는 방식으로 진행된다.
   파일 시스템이 이런 방식의 기능을 제공한다면, 
   데이터베이스 서버가 운영 중일 때도 백업이 가능하다.
   이 때, 운영 중 상태에서 백업을 받았기 때문에, 
   이 백업본으로 서버를 실행하려고 하며, 먼저 이전 실행 상태를 보관하고 있는 
   파일들을 정리해야하며, WAL 로그 정리 작업에 문제가 생길 수 있다.
   하지만, 백업 시작 전에, <command>CHECKPOINT</command> 명령을 실행했고, 
   백업 작업 중간에 생긴 WAL 로그들을 따로 보관하고 있다면, 
   별 문제 없이 실행할 수 있다. (물론 WAL 로그를 무시 할 수도 있다.)
  </para>

  <para>
   문제는 데이터베이스 서버가 여러 파일 시스템을 쓰는 경우다. 
   가령 예를 들어서 테이블스페이스를 만들고, 그 테이블스페이스가 
   다른 파티션을 사용한다면, 데이터베이스 서버가 사용하는 모든 
   파일 시스템에 대해서 동시에 <quote>현 시점 스냅샷 frozen snapshot</>을
   <emphasis>만들 수 있어야</>한다.
   이 방식으로 백업을 하려면, 먼저 파일 시스템 관련 문서를 세심하게 
   읽고, 타당성을 따져 본 후 작업하길 바란다.
  </para>

  <para>
   동시에 여러 파일 시스템 스냅샷을 만들 수 없다면,
   스냅샷을 만드는 동안 데이터베이스 서버를 중지해야한다.
   또 다른 방법으로 아카이브 모드 백업(<xref
   linkend="backup-base-backup">)과, 그 복구(<xref linkend="backup-pitr-recovery">)
   방식을 이용해야한다.
   자세한 이야기는 다음 절과, 앞 사용설명서를 참조하라.
  </para>

  <para>
   다른 한 방법은 <application>rsync</> 응용 프로그램을 이용하는 방법이다.
   작업은 두 단계로 진행 된다. 
   먼저 서버가 실행 중 일 때, 자료를 모두 동기화 하고, 
   다음 서버를 중지하고, 한 번 더 동기화를 한다.
   이렇게 하면, 서버 중지 되면서 변경 된 파일만 동기화를 하기 때문에, 
   서버 중지 시간을 최소화 할 수 있다.
  </para>

  <para>
   파일 시스템 백업은 SQL 덤프 보다 일반적으로 많은 백업 공간이 필요하다. 
   (<application>pg_dump</application> 명령으로 만들어진 
   덤프 파일에는 인덱스와 같이 물리적으로 없고, 인덱스를 만드는 명령어만
   들어있는 몇몇 명령어들이 있기 때문이다.)
   이 때문에, 복원 작업에 걸리는 시간은 파일 시스템 백업이 훨씬 빠르다.
  </para>
 </sect1>

 <sect1 id="continuous-archiving">
  <title>아카이브 모드 백업(Continuous Archiving)과, 특정시점 복구(Point-in-Time Recovery, PITR)</title>

  <indexterm zone="backup">
   <primary>아카이브 모드 백업</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>Continuous Archiving</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>특정시점 복구</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>Point-in-Time Recovery</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

  <para>
   <productname>Agens SQL</>에서는 미리 쓰기 기록
   (선행 기입 로그, <firstterm>write ahead log</>, WAL)을 
   데이터베이스 클러스터 디렉토리 안 <filename>pg_xlog/</>
   디렉토리에서 관리하고 있다.
   이 로그는 데이터베이스의 데이터 파일에 대한 모든 조작 기록을 
   보관하고 있다. 이 로그를 만드는 가장 첫번째 이유는
   서버가 갑자기 중지되었을 경우, 미처 데이터 파일에 
   적용하지 못한 작업(checkpoint 작업이 안된)을 이 로그에서 읽어서 
   그대로 <quote>다시 실행해서</>, 서버를 안전하게 복구하기 위해서다.
   이 기법을 그대로 응용하면, 이 로그를 준비된 다른 서버로 보내서, 
   이 로그의 내용을 그대로 재실행 하면, 원본 서버와 똑 같은 상태를 
   만들 수 있다. (물론 특정 시점까지만 실행하면, 데이터베이스를 
   특정시점으로 되돌릴 수도 있다.)
   여기서 소개하고 있는 백업과 복원 방법은 지금까지 이야기한 것보다 
   많이 복잡하다. 하지만, 다음과 같은 장점이 있다:

  <itemizedlist>
   <listitem>
    <para>
     파일 시스템을 백업 할 때, 파일 시스템 상태에 대해서 신경 쓸 필요가 없다.
     복원 할 때, WAL 파일의 내용을 재실행 하면서, 마치, 데이터베이스가 갑자기 중지되었을 때, 
     복구하는 기법과 같이 데이터베이스를 안전하게 복원 한다.
     즉, 파일 시스템의 스냅샷 기능을 고려할 필요 없이, <application>tar</>와 같은 간단한 
     프로그램으로 백업 작업을 할 수 있다.
    </para>
   </listitem>
   <listitem>
    <para>
     복원 작업에 필요한 WAL 파일의 수량에 제한이 없기 때문에, 
     백업을 시작하는 시점 뒤부터 생길 WAL 로그만 정확하게 보관하면, 
     백업 기간이 아무리 길어도 상관 없다.
     이 장점은 잦은 전체 백업을 할 수 없는 대용량 데이터베이스 백업에서 유용하다.
    </para>
   </listitem>
   <listitem>
    <para>
     복원을 할 때, WAL 파일의 내용을 끝까지 재실행 필요가 없다.
     이 말은 특정 시점에서 이 작업을 멈출 수 있다는 것이다.
     이렇게 되면, 특정 시점의 데이터베이스 상태로 복원이 가능하다.
     이것을 특정시점 복구 <firstterm>point-in-time recovery</> 기능이라고 한다.
    </para>
   </listitem>
   <listitem>
    <para>
     다른 호스트에 베이스 백업을 복원 해 놓고, 
     운영 서버에서 만들어지는 WAL 파일들을 주기적으로 그 준비해둔 서버로 
     반영 한다면, 운영 서버 장애가 발생했을 경우, 빠르게 대응할 수 있는 여건을 
     제공한다. 이렇게 운영하는 방법을 <firstterm>warm standby</> 시스템 구축 기법이라고 한다.
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <note>
   <para>
    <application>pg_dump</application> 명령과
    <application>pg_dumpall</application> 명령을 이용해서 만든 백업 파일은, 
    데이터베이스의 <emphasis>논리적</> 백업이기 때문에 실재 데이터베이스에서 
    일어난 모든 기록을 보관하고 있지 않다. 그래서,
    파일 시스템 기반 백업이나, 아카이브 모드 백업에서는 사용할 수 없다.
   </para>
  </note>

  <para>
   파일 시스템 기반 백업에서 이야기한 것과 같이, 이 백업/복원 작업도 
   데이터베이스의 특정 부분을 대상으로 할 수 없고, 데이터베이스 클러스터 전체를
   대상으로 한다.
   또한 아카이브 로그를 다루는 여유 공간이 상당히 필요하다:
   베이스 백업량도 많고, 업무량도 많아서 WAL 파일을 많이 만든다면, 
   베이스 백업과, WAL 파일을 처리하기 위한 비용도 상당히 많이 든다.
   하지만, 고가용성 데이터베이스 시스템으로 운영해야하는 환경에서는 
   여전히 이 방법이 제일 추천할 만한 방법이다.
  </para>

  <para>
   이 아카이브 모드 백업(다른 데이터베이스에서는 흔히 <quote>온라인 백업</>이라고 함)을 이용한
   복원 작업을 무사히 마치려면, 적어도 베이스 백업을 시작하기 직전의 WAL 파일부터, 베이스 백업이
   끝나는 시점까지 새로 생긴 WAL 파일들이 복원 작업을 할 때 필요하다.
   그래서, 이 백업 방식을 사용하려면, <emphasis>먼저</>, 아카이브 로그 백업에 대한 정책을 수립하고, 
   베이스 백업을 진행해야한다.
  </para>

  <sect2 id="backup-archiving-wal">
   <title>WAL의 아카이브 파일 만들기</title>

   <para>
    내부적으로 <productname>Agens SQL</> 시스템은 데이터베이스를 조작하는데, 
    끊임 없이 순차적으로 WAL 레코드를 만든다.
    이것을 물리적인 디스크 공간에 저장하기 위해서, WAL <firstterm>세그먼트 파일</>로 
    나눠서 저장한다. 이 하나의 WAL 파일은 기본적으로 16MB 크기의 파일이다
    (이 크기는 서버를 컴파일 할 때 결정된다).  이 파일의 이름은 WAL 순서에 따른 
    해당 번호를 사용한다.
    WAL 아카이브 파일을 만들지 않도록 설정하면, 이 파일은 몇 개만 만들어지며, 
    이것 가운데 더이상 사용하지 않는 로그 파일을 찾아서 <quote>재사용</>한다.
    내부적으로 WAL 레코드들의 상태 정보를 찾아서, 이미 체크포인트 작업이
    일어난 것에 대해서는 더 이상 사용하지 않는 상태로 바꾸고, 그 자리에 새로운 
    WAL 레코드를 기록하는 방식으로 재사용한다.
   </para>

   <para>
    WAL 아카이브 파일을 만든다면, 어떤 WAL 세그먼트 파일을 재사용하기 전에, 
    기존에 있던 WAL 레코드 정보를 다른 곳(같은 호스트 내 일 수도 있고, NFS
    마운트 위치일 수도 있고, 심지어 테이프 같은 곳일 수도 있다)에 따로 
    보관하는 작업을 한다. 이 보관하는 작업에 대한 방법은 관리자가 직접 지정한다.
    이미 똑 같은 이름의 파일이 있는 경우에 대해서도 관리자가 결정하도록 한다.
    단지 <productname>Agens SQL</> 서버에서는 WAL 세그먼트 파일을 재사용할 
    때, 그 전에 관리자가 설정한 <quote>따로 보관하는 방법</>에 따른 
    그 작업만 수행한다. 이 아카이브 보관 방법으로 단순하게, <literal>cp</> 명령이 
    이용할 수도 있고, 이보다 훨씬 복잡한 사용자 정의 쉘 스크립트일 수도 있고, 
    또한 백업 솔루션의 명령이 될 수도 있다. 이 부분에 대해서는 전적으로
    관리자 몫이다.
   </para>

   <para>
    WAL 아카이브 파일을 만드려면, 
    wal level 환경설정 매개변수의 값으로
    <literal>archive</> (또는 <literal>hot_standby</>)로 지정한다,
    다음, archive mode 환경설정 매개변수 값은 <literal>on</>,
    archive command 환경설정 매개변수 값에는 
    적당한 시스템 명령어를 지정한다. 이 설정은 모두 <filename>postgresql.conf</filename>
    파일 안에서 설정한다.
    <varname>archive_command</> 값으로 지정할 쉘 명령어에는
    <literal>%p</> (WAL 로그파일 절대경로), <literal>%f</> (보관할 로그 파일 이름) 예약 인자를 
    사용할 수 있다.
    <literal>%</> 글자 그대로 써야할 경우면, <literal>%%</>로 입력한다.
    일반적으로 이 설정 값은 다음과 같은 형태로 사용된다:
<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
</programlisting>
    윗 설정은 단순하게, WAL 세그먼트 파일을 <filename>/mnt/server/archivedir</> 디렉토리로 이름을 똑같게 해서
    복사하는 설정이다.
    윗 예제는 Unix와, Windows 운영체제에 대한 한 예제일 뿐이다. 실제 설정은 해당하는 운영체제에 맞게
    변경 되어야한다.
    <literal>%p</> <literal>%f</> 예약 인자들은 다음과 같이 변경되어 실재로 명령이 실행된다:
<programlisting>
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
</programlisting>
    이렇게 실행 된다면, WAL 로그파일을 항상 특정 위치에 새롭게 만드는 작업을 하게될 것이다.

   </para>

   <para>
    이 아카이브 명령의 실행은 <productname>Agens SQL</> 서버들 실행했던 
    시스템 사용자 권한으로 실행된다. 그래서, WAL 세그먼트 파일을 처리하는 
    것과 같이 이 파일의 아카이브 파일의 처리에 있어서도 운영체제 차원은
    보안 정책을 고려해야한다. 누구나 읽고 덮어쓰고, 지울 수 있다면, 
    치명적인 보안 사고가 발생할 수 있음을 주의해야 한다.
   </para>

   <para>
    또 하나 주의할 사항은 아카이브 명령의 쉘 실행 리턴값은 그 명령이 성공 했을 경우 0(zero), 아니면, 
    그 밖에 값이 되도록 해야한다. <productname>Agens SQL</> 서버는 이 리턴값으로
    로그 파일을 잘 보관했는지, 실패했는지를 판단하고, 성공했다면, 
    원본 로그 파일을 지우거나 재사용하고, 실패하면, 성공할 때까지 재시도한다.
   </para>

   <para>
    이 아카이브 명령은 이미 있는 파일을 덮어쓰지 않도록 해야한다.
    덮어 쓰는 경우가 생기면, 관리 입장에서 복원 작업 시 의도되지 않는 오류가 발생 할 수 있다.
    (해당 파일이 이미 다른 데이터베이스에서 생성했거나, 그것을 사용할 수도 있기 때문이다.)
    그 로그 파일이 이미 있다면, 끊임 없이 오류를 발생하며, 이 문제는 관리자가 
    파악해서, 수동으로 처리하는 것이 가장 안전하기 때문이다.
   </para>

   <para>
    로그 파일을 보관 하는 작업을 하기 전에 먼저 그 파일이 그곳에 있는지
    부터 확인하고, 그 경우는 해당 명령어가 0 아닌 값을 리턴할 수 있도록 
    설정하기를 권한다. Unix에서는 이런 작업을 위해, <command>test</> 명령을
    제공하고 있다. 몇 Unix 플랫폼에서는 이미 있는 파일을 덮어쓰지 않기 위해
    <command>cp</> 명령에서 <option>-i</> 옵션을 제공하는데, 
    이 명령을 사용할 때는 반드시 리턴값을 확인 해 볼 필요가 있다. (GNU <command>cp</>
    명령은 이 경우, 0 값을 리턴한다. 이는 원하는 결과가 아니다.)
   </para>

   <para>
    WAL 파일을 따로 저장하는 작업을 할 때, 운영상 해당 작업을 수동으로 
        중시 했을 경우나, 저장 공간이 부족하여, 이 저장 작업이 실패해서, 
        계속 반복 될 경우, 어떤 일이 생길지에 대해서도 고려해야한다.
        한 예로, WAL 세그먼트 파일을 테이프 저장장치로 보관하려고 하는데, 
        해당 장치가 자동으로 테이프 교환을 하지 않고, 테이프의 여유 공간이 없다면, 
        사용자가 테이프를 바꾸기 전까지 계속해서 파일 기록 작업을 실행했다가, 
        오류를 내고, 다시 실행할 것이다.
        이렇게 되면, <filename>pg_xlog/</> 디렉토리에서는 테이프 저장장치로
        자료가 안전하게 복사되지 않았기 때문에, 해당 WAL 세그먼트 파일을 삭제하거나
        재사용하지 않을 것이며, 그 이후 만들어지는 새로운 WAL 세그먼트 파일들이 
        계속 해서 쌓일 것이고, 결국 <filename>pg_xlog/</> 디렉토리의 여유 공간이 
        없어 서버는 PANIC 오류를 내면서 중지하게된다. 
   </para>

   <para>
    또한 WAL 파일을 따로 저장할 때의 그 저장 장치의 자료 기록 속도도 함께 
        고민해야한다. 정상적으로 작업이 진행된다 하더라도, WAL 파일을 만들어내는 
        속도가, 그 파일을 따로 보관하는 속도보다 빠르다면, 똑같은 문제가 발생할 
        수 있다.  물론 따로 보관하는 속도가 다소 늦더라도, 정상적으로 이루워지고, 
        <filename>pg_xlog/</> 디렉토리의 여유공간이 충분히 있다면 별문제 되지는 않지만, 
        그렇지 않다면, 위에서 언급한 문제가 발생할 여지가 있다.
        이 기능을 사용하기 전에 충분히 이 부분에 대한 문제를 고민해 
        보아야하며, 관리자는 이 기능이 의도된 대로 잘 작동하는지 
        감시해야한다.
   </para>

   <para>
    저장 파일의 경로는 최대 64 개의 ASCII 글자면 되고, 파일이름은 <literal>%f</>
        예약어를 사용해야하며, (즉 디렉토리까지만 바꿀 수 있다) 
        원본 WAL 세그먼트 파일은 <literal>%p</> 예약어를 사용해야한다.
   </para>

   <para>
    WAL 파일에는 트랜잭션 작업 정보만 담겨있기 때문에, 
        <filename>postgresql.conf</>, <filename>pg_hba.conf</>, <filename>pg_ident.conf</>
        파일의 변경 사항은 복원 되는 데이터베이스에 이 백업 방법으로는 
        반영되지 않는 점을 주의해야한다.
        이 환경설정 파일의 백업은 시스템의 일반 파일 백업 정책에 따라 백업하길 바란다.
    이 환경설정 파일 백업을 위해서, 해당 파일의 위치를 바꾸려면, 
        <xref linkend="runtime-config-file-locations"> 항목을 참조하라.
   </para>

   <para>
    아카이브 명령은 WAL 파일 가운데, 서버에 모두 반영된,(rollback되거나
        commit 되어 checkpoint 작업이 끝난) 파일에 대해서 실행된다.
        즉, 작업량이 아주 적은 데이터베이스일 경우라면, 아카이브 명령이 실행될 
        간격이 아주 길어진다. 이 사이 데이터베이스 장애가 생긴다면, 
        자료 손실이 그 긴 기간 만큼 생기게 됨으로 WAL 세그먼트 파일의 모든 
        내용이 처리되기 전에 강제로 특정 시간이 지나면 아카이브 명령을 사용해서 
        이 세그먼트 파일을 따로 저장하려면, <varname>archive_timeout</> 환경설정 값을 
        짧게 조정하면 된다. 이 설정값을 너무 짧게 잡으며, 디스크 공간을 낭비하는 
        단점이 생긴다. 일반적으로 이 설정값은 분 딘위가 적당하다.
   </para>

   <para>
    또한 사용자가 강제로 세그먼트 파일을 <function>pg_switch_xlog</> 
    함수를 이용해서 바꿀 수 있다. 일반적으로 대량 자료 입력, 변경, 삭제 
        작업이 일어나고, 이것에 대한 즉시 백업이 필요한 경우에 
        이 함수를 사용한다. 
   </para>

   <para>
    <varname>wal_level</> 환경설정값을 <literal>minimal</>로
    설정하게 되면 이 WAL 로그를 따로 보관해서 그것을 기반으로 복원 하는 
        기능을 사용할 수 없다. 이 설정을 사용하면, WAL 파일에 복원 관련 
        정보를 보관하지 않기 때문이다. 
        이렇기 때문에, <varname>wal_level</> 설정값을 변경하면, 
        서버를 재실행해야한다. 하지만, <varname>archive_command</> 설정값은 
        환경설정파일 다시 로드하는 것으로도 충분하다.
        필요에 따라서 운영 중에 이 작업이 중지되어야할 필요도 있기 때문이다.
        이렇게 하려면, <varname>archive_command</> 설정값으로 빈문자열(<literal>''</>)로
        지정하면 된다.  이러면 <varname>archive_command</>  설정값이 다시 WAL 파일을 
        복사하는 작업을 하기 전까지 <filename>pg_xlog/</> 디렉토리에 계속 남아있게 된다.
   </para>
  </sect2>

  <sect2 id="backup-base-backup">
   <title>베이스 백업 만들기</title>

   <para>
   베이스 백업을 만드는 가장 손쉬운 방법은 pg basebackup 툴을 사용하는 것이다.
   이 툴을 이용하면 일반적인 파일이나, tar 묶음 파일로 베이스 백업 파일을 만들 수 있다. 
   pg basebackup 툴을 이용하는 방법보다 
   보다 유연하게 백업을 하고 싶다면, 저수준 API를 이용해서 사용자 정의 백업 방식을 구현할 수 있다.
   (24.3.3절 참조)
   </para>

   <para>
   베이스 백업을 만드는데 걸리는 시간에 대해서는 우려할 필요가 없다. 하지만, 
   운영 서버가 <varname>full_page_writes</> 비활성화 상태로 운영 되고 있다면, 
   베이스 백업을 하는 동안 자동으로 <varname>full_page_writes</> 설정이 활성화 되어
   서버의 성능이 약간 떨어질 것이다.
   </para>

   <para>
   이 베이스 백업을 이용해서 복구작업을 한다면, 베이스 백업 작업에서 파일 시스템 복사를 
   시작하는 시점부터 복사가 끝나는 시점까지 만든 모든 WAL 파일을 따로 보관하고 있어야한다.
   어떤 파일부터 따로 보관해야하는지는 베이스 백업을 시작하는 시점부터 백업이 끝나는 시점까지
   생성된 WAL 파일을 <firstterm>백업 내역 파일</>에 기록해 둔다. 이 파일의 이름은 
   복구에 필요한 WAL 파일의 첫번째 파일 이름을 사용한다. 예를 들어서, 
   필요한 파일이 <literal>0000000100001234000055CD</> 이라면, 백업 내역 파일은 
   <literal>0000000100001234000055CD.007C9330.backup</> 파일이다. 이 파일 또한 pg_xlog 디렉토리
   안에 있으면, 베이스 백업이 끝나 이 파일이 만들어지면, 아카이빙 작업에 의해 WAL 세그먼트 파일과 
   함께 따로 보관하는 장소에 복사된다. (WAL 세그먼트 파일 이름 뒤에 있는 또 하나의 정보는 
   그 파일의 정확한 시작 위치인데 이 부분은 무시해도 좋다.) 베이스 백업이 끝나면, 
   백업 내역 파일의 이름을 보고 그 이름보다 알파벳 순으로 이전 것들은 복구를 하는데 사용되지 않는다. 
   그러므로 다중 백업 환경이 아니라면, 오래된 WAL 세그먼트 파일들은 파일 시스템에서 삭제 되어도 
   무방하다. 다중 백업 환경이라면 그 각각의 백업 복구를 위해서 필요한 모든 WAL 세그먼트 파일들을 
   잘 정리해 두어야한다.
   </para>

   <para>
    백업 내역 파일은 크기가 작은 단순 텍스트 파일이다. 이 파일에는 
        pg basebackup 툴에서 자동으로 지정한 백업 라벨과, 
        백업 복구에 필요한 WAL 세그먼트 파일 이름 정보와 백업 시간이 기록되어있다.
        백업본의 구분하려고 라벨을 사용한다면, 이 백업 내역 파일을 이용하면 충분하다.
   </para>

   <para>
    베이스 백업 주기는 전체 백업량과, 그 간격 사이 만들어지는 WAL 세그먼트 파일의 양과, 백업 파일을 보관하는 속도, 
        여유 공간, 그리고 복구할 때 소요되는 시간까지 여러 부분들을 모두 고려해야한다. 
        &mdash; WAL 세그먼트 파일이 많다면, 베이스 백업을 준비 해 놓고도 그 파일을 모두 반영하는데 걸리는 시간도 
        필요하기 때문이다. 
   </para>

  </sect2>
  <sect2 id="backup-lowlevel-base-backup">
  <title>저수준 API를 이용한 베이스 백업 만들기</title>
   <para>
    저수준 API를 이용해서 베이스 백업을 만드는 방법은, pg basebackup 
        툴을 사용할 때보다 몇 단계 작업이 추가 되기는 하지만, 상대적으로 간단하다.
        이렇게 작업할 때 가장 주의해야 할 점은 다음 설명하고 있는 각 단계가 반드시 정상적으로 
        수행 된 경우에만 다음 단계 작업을 해야한다는 점이다.
  <orderedlist>
   <listitem>
    <para>
         서버가 아카이브 모드로 설정 되어있고 정상적으로 WAL 세그먼트 파일들이 따로 보관하는 작업이 실행되는 상태여야한다.
    </para>
   </listitem>
   <listitem>
    <para>
         해당 데이터베이스에 슈퍼유저로 접속해서, 다음 명령을 실행한다:
<programlisting>
SELECT pg_start_backup('라벨');
</programlisting>
     <literal>라벨</> 자리에는 어떤 문자열이 와도 상관 없다. 
         관리자가 해당 백업 작업에 대한 식별자로 사용되는 문자열이면 된다.
         (백업본을 저장하려고 하는 디렉토리의 전체 경로를 이 이름으로 정하는 것도
         좋은 방법이다.)
         <function>pg_start_backup</> 함수는 먼저 데이터 클러스터 디렉토리에, 
         <filename>backup_label</> 이라는 파일을 만들고, 그 안에, 지정한 라벨 문자열과, 
         백업을 시작하는 시간을 기록한다.  이 파일은 복구를 할 때 꼭 필요한 파일이기 때문에, 
         백업 결과물에 이 파일이 없다거나 손상되었다면, 백업 작업을 처음부터 다시 해야한다.
    </para>

    <para>
         백업 대상이 되는 접속한 데이터베이스의 클러스터 디렉토리가 어디인지는 
         몰라도 된다. 또한 이 함수의 결행결과가 오류가 발생한다면,
         그에 적합한 조치를 취해야겠지만,  오류를 내지 않는다면, 
         이 작업의 내부 작업에 대해서는 신경쓰지 않아도 된다.
    </para>

    <para>
         기본적으로, <function>pg_start_backup</> 함수를 마치는데, 
         꽤 긴 시간이 소요되기도 한다. 
         백업 시작 전에 이 함수에 의해서 체크포인트 작업을 하는데, 
         이 작업을 준비하기 위한 내부적인 작업들과,
         또,  체크포인트 작업은 데이터베이스 성능에 최대한 영향을 끼치지
         않기 위해,  데이터베이스 서버가 다른 작업으로 바쁘며, 
         checkpoint completion target 설정값에서
         지정한 시간만큼 일단 기다리는 이 대기 시간까지 합쳐, 
         실재로 이 함수의 총 실행 시간이 길어지기도 한다.
         만일 이렇게 긴 기다림의 시간 없이 바로 백업 준비를 위한 작업을 
         곧바로 하려면 다음과 같은 명령을 사용한다:
<programlisting>
SELECT pg_start_backup('label', true);
</programlisting>
     위 명령은 최대한 빨리 체크포인트 작업을 진행한다.
    </para>
   </listitem>
   <listitem>
    <para>
         데이터 클러스터 디렉토리를 시스템 차원에서 백업한다. 
         이 때의 백업 방법은 파일 시스템 백업하는 그 어떠한 방법으로도 가능하다.
         예를 들면,  <application>tar</> ,  <application>cpio</>  같은 
         명령어를 사용하는 것을 말한다 (<application>pg_dump</application>, 
         <application>pg_dumpall</application> 명령어를 사용하는 것이 아니라).
         이때 주의할 사항은 이 백업 작업을 하는 동안, 
         데이터베이스를 중지할 필요도 없으며, 중지 해서도 안된다는 점이다.
         (*테스트 필요*)
    </para>
   </listitem>
   <listitem>
    <para>
         파일 시스템 차원의 데이터베이스 클러스터 디렉토리에 대한 백업이 
         끝나면, 다시 해당 데이터베이스에 슈퍼유저로 접속해서 다음 명령을 실행한다:
<programlisting>
SELECT pg_stop_backup();
</programlisting>
     이 작업은 데이터베이스 서버 쪽에, 이제 백업이 끝났으니,
         지금까지 사용했던 WAL 세그먼트 파일들은 아카이브 보관 작업 처리하는 
         쪽으로 넘기고, 새 WAL 세그먼트 파일로 바꾸어서 다시 서버를 일상적인 상태로 실행한다.
    </para>
   </listitem>
   <listitem>
    <para>
         다음 이 마지막 로그 파일을 보관 하는 작업이 완료되면, 베이스 백업은 끝난다.
         <function>pg_stop_backup</> 명령이 끝나는 시점은 마지막 사용했던 WAL 파일이 
         <varname>archive_command</> 설정값으로 지정된 명령에 의해서, 
         무사히 처리되었을 때다. <function>pg_stop_backup</> 명령은 
         <varname>archive_mode</> 설정값이 on 상태일 때만 실행되며, 
         이 명령이 실행되기 직전까지 사용하고 있던 WAL 파일은 반드시, 
         정상적으로 보관처리가 되어야 끝난다. 일반적인 환경에서는 
         이 명령은 짧은 시간 안에 끝나지만, 예상했던 것보다 이 명령 시간이 
         오래 걸린다면, <varname>archive_command</> 설정값으로 지정된 작업에
         문제가 있는지 살펴보고, 그 원인을 해결해야한다. 또한 <varname>archive_command</>
         설정값이 비어 있어도 이 명령은 끝나지 않는다.
         <varname>archive_command</> 설정값으로 지정된 작업은 성공 할 때까지 
         반복 한다는 점도 주의 해야한다.  필요하다면, <varname>statement_timeout</varname>
         설정값을 지정해서, <function>pg_stop_backup</> 작업이 무한 대기 상태로 
         빠지는 것을 막을 수도 있다.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
    베이스 백업을 할 때, 위와 같은 순서로 직접 하나 하나 작업을 진행할 수도 
        있지만, pg basebackup 응용 프로그램을 이용할 수도 있다.
        이 프로그램은 윗 작업을 <productname>Agens SQL</productname> 서버로 연결해서, 
        해당 쿼리를 실행하고, 리플리케이션 프로토콜을 이용해서, 데이터 파일들을 복사하고, 
        뒷 마무리까지 (필요하다면, 백업 중간에 변경 된 xlog 파일의 적용까지) 
        한 번에 할 수 있다. 또한 이 프로그램은 <function>pg_start_backup()</>/<function>pg_stop_backup()</>
        함수를 이용하는 파일 시스템 기반 베이스 백업을 하고 있는 중에도 
        사용할 수 있다.
   </para>

   <para>
    몇몇 파일 시스템 백업 툴들은 파일 복사 도중에, 
        그 파일이 변경되면, 경고나, 오류를 내는 경우도 있다.
        운영 중인 데이터베이스를 대상으로 베이스 백업을 만들고 
        있는 상황에서는 이 경고나 오류가 정상적인 것이다.
        하지만, 이 베이스 백업 작업 자체의 오류와, 윗 파일이 변경 되어서
        발생하는 오류를 구분할 필요가 있다. 예를 들어서, 
        <application>rsync</> 프로그램의 어떤 버전은 
        <quote>사라져 버린 원본 파일</>에 대한 처리를 할 때, 
        실행 결과 리턴값을 다르게 처리한다. 이것을 이용하며, 
        리턴값을 조사해서, 정상적인 처리와, 오류 처리를 구분하는 
        백업 스크립트를 작성할 수도 있을 것이다.
        또한, 어떤 <application>tar</> 버전에서는 위와 같은 경우와, 
        물리적인 묶는 작업 실패에 대한 구분을 하지 않고, 같은 리턴 값으로
        작업이 종료되기도 한다.  다행히, GNU <application>tar</> 1.16 이후
        버전부터는 백업 도중 원본 파일이 변경된 경우는 1, 그 외 오류인 경우는
        2를 리턴하면서 종료한다.
   </para>

   <para>
    <function>pg_start_backup</> 명령이 실행되고, 
        <function>pg_stop_backup</> 명령을 실행하기 전까지, 파일 시스템을 
        복사하는 작업 시간에 대해서는 신경 쓰지 않아도 된다. 
        데이터 클러스터 전체를 시스템 차원의 백업 시간과 같이, (또는 이 보다 더 늦게)
        처리 되어도 괜찮다. 단, 서버 환경 설정이 <varname>full_page_writes</> off 
        상태로 운영되고 있던 서버라면, <function>pg_start_backup</> 명령이 실행되면, 
        이 값이 on 되기 때문에, <function>pg_stop_backup</> 명령이 
        실행되기 전까지 그 만큼의 성능 저하가 발생 할 것이다.
        이 작업에서 신경 써야 할 부분은 베이스 백업 작업이 길어지고 있고, 
        그 중에 또 새로운 백업을 시도할 경우, 그 명령은 무시 되고, 그 백업 스크립트 
        오류로 <function>pg_stop_backup</> 명령이 의도되지 않게 실행되어 
        기존 베이스 백업 작업을 망치는 경우다. 이 베이스 백업을 할 때는 
        반드시 위에서 언급한 절차가 모두 순차적으로 끝나야 한다. 중간 작업이 실패한다면, 
        그 백업본은 사용할 수 없다.
   </para>

   <para>
    백업본을 만들 때는 반드시 데이터 클러스터 디렉토리
        (대게, 이 디렉토리의 이름은 <filename>/usr/local/pgsql/data</> 이다.)
        안에 있는 
        모든 파일을 보관해야한다.  또한, 기본 테이블스페이스 외에 다른 사용자 정의
        테이블스페이스를 사용한다면, 그 파일들로 모두 보관해야한다. 
        그렇지 않으면, 복원 작업이 정상적으로 이루워지지 않는다.
   </para>

   <para>
    한편, 데이터 클러스터 디렉토리에 대한 백업본을 만들 때, 
        <filename>pg_xlog/</> 디렉토리를 빼야한다.
        이렇게 하려면, 클러스터 디렉토리 안에 <filename>pg_xlog/</>
        디렉토리를 두지 않고, 그냥 심볼릭 링크로 만들어 사용하면, 
        손쉽게 처리할 수 있다. 또한 복원 작업을 손쉽게 하기 위해서, 
        데이터베이스 서버가 실행 중일 때만 생기는 <filename>postmaster.pid</>,
        <filename>postmaster.opts</> 파일들을 백업본을 만들 때, 
        제외해두면 좋다.  이 파일들이 있으면, <application>pg_ctl</> 명령으로
        서버를 실행하려고 할 때, 문제를 일으킨다.  그래서 수동으로 정리작업을 
        해 주어야한다.
   </para>

   <para>
    디렉터리 안에 덤프파일을 만들어서, 리플리케이션 슬롯 대신 백업 일부로 사용할 수 있다. 그렇게 하지 않으면 대기 서버를 만들 때마다 마스터 서버에 연결된 리플리케이션 사용자가 계속 마스터 서버의 슬롯을 업데이트하고, hot standby feedback이 활성화된 상태에선 마스터가 폭발할 지도 모른다. 백업이 새 마스터를 만들 때만 사용된다 하더라도, 리플리케이션 슬롯을 복사하는 것은 좋지 않다. 슬롯의 컨텐츠도 새 마스터가 연결된 때에는 이미 오래된 정보일 가능성이 높기 때문이다.
   </para>

   <para>
    이 백업본을 정상적으로 사용하려면, 파일 시스템 백업을 시작 한 뒤부터
        생긴 WAL 세그먼트 파일들을 모두 보관하고 있어야한다.
        이 작업을 쉽게 할 수 있도록, <function>pg_stop_backup</>함수가
        실행되면, <firstterm>백업 내역 파일</>을 만들어 WAL 아카이브 영역 쪽으로 
        즉시 보관한다.  이 파일의 이름은 백업을 시작하면서 첫 체크포인트 작업을 한 
        다음 세그먼트 번호로 결정된다.
    예를 들어, WAL 세그먼트 파일의 백업이 필요한 파일 이름이 
    <literal>0000000100001234000055CD</> 라면, 백업 내역 파일의 이름은 
        <literal>0000000100001234000055CD.007C9330.backup</>으로 된다. 
        (이 이름의 두번째 부분은 해당 세그먼트 내의 정확한 위치를 나타내는데, 
        크게 신경쓰지 않아도 된다.)
        이렇게 해서, 이 파일 이름의 세그먼트 파일과, 파일 시스템 백업 과정에 생긴 
        WAL 세그먼트 파일들만 보관하면, 정상적인 복구가 가능하다. 즉, 이 백업 시작 전 
        세그먼트 파일들은 더 이상 필요가 없다. (일반적으로 쓸모 없는 파일들은 
        16진수로 백업 내역 파일의 이름보다 작다.) 하지만, 
        만일을 대비해서, 현재 베이스 백업으로 복원이 불가능한 경우를 대비해서, 
        이전 WAL 세그먼트 파일들도 따로 보관해 둘 필요도 있다.
   </para>

   <para>
    백업 내역 파일은 작은 텍스트 파일이다. 이 파일 안에는 
        <function>pg_start_backup</> 함수를 실행할 때 지정한 
        라벨 문자열이 있고, 파일 시스템 백업 시작, 종료 시간과 
        각 WAL 세그먼트 파일 이름이 기록되어 있다.
        파일 시스템 백업과 관계 된 라벨을 잘 이용하면, 
        여러개의 베이스 백업본을 독립적으로 보관할 수있으며, 
        필요에 따라 그 라벨을 보고, 선택적으로 복원 작업을 할 수 있다.
   </para>

   <para>
    정상적인 복원 작업이 이루워지려면, 이처럼 마지막 베이스 백업 작업을 
        끝낸 뒤부터, 다음 베이스 백업 작업을 할 때까지의 간격에 대해서 
        고민할 필요가 있다. 간격이 길다면, 그 만큼 복원 작업에서 사용될 
        WAL 세그먼트 파일이 많아지기 때문이다.  또한 백업 저장 장치의 
        공간도 고려되어야한다. 백업 저장 장치의 입출력 속도와, 
        여유 공간과, 데이터베이스 서버에서 만들어내는 WAL 세그먼트 파일들의 량과
        베이스 백업을 하는 동안 데이터베이스 서버의 서비스 영향도를
        모두 고려해서, 가장 적당한 백업 주기를 선택하는 것이 좋다.
   </para>

   <para>
    또한, 데이터베이스 클러스터 디렉토리 안에 있는 <filename>backup_label</> 파일도
        신경써야한다. 이 파일은 <function>pg_start_backup</> 함수가 실행될 때 만들어지며, 
        <function>pg_stop_backup</> 함수가 실행될 때, 해당 디렉토리에서는 삭제 되고, 
        WAL 세그먼트 파일 백업 처리와 같은 방식으로 보관된다.  즉, 베이스 백업본에는 
        반드시 이 <filename>backup_label</> 파일이 있게 된다.  실행 되는 서버 쪽에서는 
        베이스 백업이 완료되면 없어야하고, 백업본에는 이 파일이 있는 것이 정상이다.
        만일 그렇지 않다면, 해당 베이스 백업은 비정상적으로 처리된 경우다.
        이렇기 때문에, 백업 도중 데이터베이스 서버가 중지 되어 버린 경우, 이 점을 감안해서, 
        베이스 백업본을 사용할 수 있는지를 판단해야한다.
     또한, 이 <filename>backup_label</> 파일은 복구 작업에 반드시 필요한 정보들을 
     포함 하고 있기 때문에, 이 파일은 임의로 삭제 해서는 안된다.

   </para>

   <para>
    서버가 중지된 상태라면, 간단하게 데이터베이스 클러스터 디렉토리 전체를 
        백업하는 것으로도 충분하다.  이 때는 당연히 <function>pg_start_backup</>,
        <function>pg_stop_backup</> 함수를 사용하지 않는다. 그러므로, 
        서버가 정상적으로 중지된 것이 아니라면, 이 WAL 파일을 서버가 복원될 때, 
        사용할 수 있도록 수동으로 따로 보관해야할 필요가 있다.
   </para>
  </sect2>

  <sect2 id="backup-pitr-recovery">
   <title>아카이브 모드 백업을 이용한 복구</title>

   <para>
    이제, 최악의 사고가 일어났을 때, 아카이브 모드 백업 방식으로 보관해둔 백업을 가지고, 
        데이터베이스 서버를 복구하는 방법에 대해서 설명한다.
    작업 순서는 다음과 같다:
  <orderedlist>
   <listitem>
    <para>
     서버가 실행 중이라면, 먼저 서버를 중지한다.
    </para>
   </listitem>
   <listitem>
    <para>
         만일 시스템의 디스크 공간이 넉넉하다면, 
         데이터베이스 클러스터 디렉토리 전체와, 
         관계된 사용자 정의 테이블스페이스의 파일들과
         필요한 WAL 세그먼트 파일 모두다. 이 작업을 기존 운영 중이던 시스템에서
         하려면, 적어도 두 배 이상의 디스크 공간이 필요하게 된다. 이런 여유 공간이 없다면, 
         적어도 기존 데이터베이스 서버의 클러스터 디렉토리 안에 있는 
         <filename>pg_xlog</> 파일들과, 서버 환경 설정 파일들 만이라도 복사한다.
     백업한 WAL 세그먼트 파일들과 미처 백업 되지 못한 WAL 세그먼트 파일들을 모두 구할 수 있다면, 
         서버가 중지되기 직전의 상태로 복구 될 수 있다.
    </para>
   </listitem>
   <listitem>
    <para>
         기존 서버용 데이터 클러스터 디렉토리와, 기존 테이블스페이스용 디렉토리를 모두 
         지운다. 
    </para>
   </listitem>
   <listitem>
    <para>
         백업 파일을 원래의 위치에 그대로 복사한다. 이 때 작업자는 데이터베이스 서버를 
         실행하는 시스템 사용자여야한다. (<literal>root</>로 작업하면, 반드시, 
         해당 소유주로 변경해야한다!) 그래서, 파일 접근 권한과, 소유주를 원래의 그것과 
         같게 맞추어야한다. 다음 사용자 정의 테이블스페이스를 사용한다면, 
         <filename>pg_tblspc/</> 디렉토리 내에 심볼릭 링크로 되어 있는 원본 디렉토리와, 
         그 안에 있는 모든 파일을 복사해 둔다.
    </para>
   </listitem>
   <listitem>
    <para>
         <filename>pg_xlog/</> 디렉토리는 비워둔다; 만일 이 디렉토리 안에 파일이 있다면, 
         지워야한다. 복구 작업에서 이 디렉토리 안에 필요한 파일들은 자동으로 만들어진다. 
         만일 <filename>pg_xlog/</> 디렉토리를 백업 대상에서 제외했다면, 
         디렉토리를 만들거나, 심볼릭 링크를 만들어 데이터베이스 서버가 해당 디렉토리를 
         사용할 수 있도록 한다. 이 때도, 이 디렉토리의 접근권한과 소유주가 데이터베이스
         서버를 실행하는 시스템 사용자만 사용할 수 있는지 확인해야한다.
         만일 심볼릭 링크라면, 혹 옛 데이터베이스에서 사용하는 원본 경로와 같아서
         옛 자료들을 덮어쓸 수 있는지 꼭 확인해야한다.
    </para>
   </listitem>
   <listitem>
    <para>
         만일 WAL 세그먼트 파일에 대한 백업본이 없다면, 
         2단계에서 복사해둔 <filename>pg_xlog/</> 내의 파일들을 복구하려는 
         곳으로 복사한다. (옮기지 말고 복사하길 권한다. 아직 완벽한 복구가 
         이루워지지 않았기 때문에, 복사가 안전하다.)
    </para>
   </listitem>
   <listitem>
    <para>
         데이터베이스 클러스터 디렉토리 안에, <filename>recovery.conf</> 파일을
         만든다. (이 파일의 내용에 대한 자세한 설명은 <xref linkend="recovery-config"> 참조)
         또한 복구 과정 중에 외부에서 접근 할 수 없도록 
         임시로 <filename>pg_hba.conf</> 파일을 수정하는 것도 좋은 방법이다.
    </para>
   </listitem>
   <listitem>
    <para>
         서버를 실행한다. 서버는 복구 모드로 가동되면서, 
         필요한 WAL 파일들을 찾아서 반영되지 않았는 트랜잭션들을 
         일괄 처리하기 시작한다. 복구 작업 도중 외부 영향으로 서버가 
         중지 된다면, 단순히 서버를 재실행하면, 이어서 복구 작업을 계속 
         진행한다. 복구 작업이 끝나면, 서버는 복구 모드로 재실행 되는 것을 막기 위해, 
         <filename>recovery.conf</> 파일을 <filename>recovery.done</> 이름으로 바꾸고,
         정상 실행 상태로 클라이언트의 접속을 기다린다. 
    </para>
   </listitem>
   <listitem>
    <para>
         이제 데이터베이스로 접속해서, 자료가 정상인지 살펴보고, 
         만일 원하는 대로 복구 되지 않았다면, 서버 로그를 살펴보면서, 
         1단계부터 다시 진행한다.  자료가 모두 정상이고, 
         데이터베이스 상태도 정상이라면, <filename>pg_hba.conf</> 파일의 내용을
         원래대로 수정해서, 외부 접속도 허용한다.
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
    이 복구 방법의 핵심은 어떻게 백업 WAL 세그먼트 파일을 데이터베이스에 
        적용시키냐는 것과, 그 복구를 어느 시점까지 할 것이냐이다.
        이것을 <filename>recovery.conf</> 파일에서 지정한다.
        이 파일을 만드는 간단한 방법은 먼저 데이터베이스 배포판의
        <filename>share/</> 디렉토리 안에 <filename>recovery.conf.sample</> 파일을
        복사해서, 필요한 부분만 수정해서 사용하는 것이다.
        <filename>recovery.conf</> 파일에서 꼭 필요한 부분은
        <varname>restore_command</> 부분이다.
    이 설정은 <productname>Agens SQL</>에서 백업본 WAL 세그먼트 파일을 
        어떻게 적용시킬 것인가에 대한 정의다.
        간단하게 설명하면, 서버 환경 설정 가운데, <varname>archive_command</>
        설정과 반대되는 명령을 지정하면 된다. 여기서 사용되는 예약어는 
        <varname>archive_command</> 설정값을 지정할 때와 같다. 
        <literal>%f</> 값은 백업 아카이브 디렉토리 안에 있는 파일이름이 되고, 
        <literal>%p</> 값은 트랜잭션 로그 파일로 대체된다. (상대 경로를 사용하면, 
        서버를 실행하는 현재 디렉토리를 기준으로 처리된다.) <literal>%%</> 예약어는
        <literal>%</> 문자로 처리된다. 다음은 일반적인 이 설정값이다:
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
    윗 설정은 <filename>/mnt/server/archivedir</> 디렉토리 안에 있는 
        미리 백업 해둔 WAL 세그먼트 파일들을 복구 작업을 진행할 때 
        사용하겠다는 예제다. 물론 이 명령은 사용하는 백업 장치에 따라서
        훨씬 복잡할 수도 있으며, 테이프 백업 장치처럼, 
        해당 테이프를 마운트하고, 원하는 위치로 이동하는 등, 몇몇 
        명령들이 포함된, 직접 만든 쉘 스크립트를 이용할 수도 있다.
   </para>

   <para>
    여기서 중요한 점은 여기서 지정한 작업이 실패 했을 경우,
    그 작업의 리턴값이 0이 아닌(nonzero) 것이여야 한다는 점이다.
    이 작업에서는 아카이브 백업 디렉토리 안에 없는 파일도 요청할 것이다.
    이 때 이 작업의 결과는 반드시 0이 아닌 리턴값을 리턴해야한다.
    이 상황은 오류 상황이 아니다.  이 작업의 오류 상황으로는 
    해당 스크립트에서 명령어가 없다거나, 서버가 정상 종료되면서, 
    복구작업을 하는 프로세스로 <systemitem>SIGTERM</systemitem>
    시그널을 보내는 경우를 제외한 기타 다른 시그널로 그 작업이 
    중지 되는 경우가 있다. 이런 상황에서는 복구 작업이 중지 되고, 
    서버는 정상 작동을 하지 않고 멈춘다.
   </para>
    
   <para>
        서버는 <literal>.backup</> 또는 <literal>.history</> 이름으로 끝나는 
        파일을 찾을 수도 있는데, 이 때, 그 파일이 없으면, 그 파일이 없다고, (0 아닌 값을 리턴함으로)
        서버 쪽에 알려주어야한다. 
        또한, <literal>%f</> 파일 이름과, 서버 쪽으로 복사되는 <literal>%p</> 파일 이름이 
        항상 같지는 않다. 그렇기 때문에, 쉘 스크립트를 직접 만들어 사용한다면, 
        이 부분에 대한 처리에 실수가 없도록 주의해야한다.
   </para>

   <para>
    아카이브 백업 디렉토리에서 WAL 세그먼트 파일을 못 찾으면, 
        데이터 클러스터 안에 있는 <filename>pg_xlog/</> 디렉토리 안에서 찾는다.
        혹시 처리해야할 WAL 세그먼트 파일이 더 있는데, 
        미처 백업 되지 않은 것이 있으면, 그것까지도 처리하기 위한 방법이다. 
        하지만, 똑 같은 파일이름으로 아카이브 백업 디렉토리 안에 이미 
        그 파일이 있다면, 그 파일이 적용되고, <filename>pg_xlog/</> 안에 있던 
        파일은 무시하고, 새로운 WAL 세그먼트 이름으로 그 로그를 반영한다. 이렇기 때문에, 
        복구 작업 전에 반드시 WAL 세그먼트 파일들을 잘 정리해야한다.
   </para>

   <para>
    일반적으로 복구 작업은 아카이브 백업 디렉토리 안에 가장 마지막 로그 파일을 반영하고, 
        그 다음 파일을 찾아서 없을 때까지 진행되기 때문에, 
        복구 로그의 마지막은 어떤 파일을 찾을 수 없다는 <quote>file not found</> 메시지가 출력된다.
        또한 복구 작업을 시작하면서, <filename>00000001.history</> 형태의 파일을
        찾기도한다. 이 모든 경우는 정상적인 복구 과정 속에서 생기는 로그들이다. 
        자세한 이야기는 <xref linkend="backup-timelines">에서 설명하고 있다.
   </para>

   <para>
    복구 작업은 <filename>recovery.conf</> 파일에서 
        복구 <link linkend="recovery-target-settings">중지 지점</link>을 
        지정해서 원하는 지점에서 복구 작업을 중지할 수도 있다. 
        이 지점을 <quote>recovery target</>이라고 한다.
        이 기능은 미숙한 데이터베이스 관리자가 실수로 중요 테이블을 삭제하는 것 같은 
        운영성 실수에 대한 복구를 지원하는데 유용하다.
        <quote>recovery target</>은 특정 시각으로 지정할 수도 있고, 
        관리자가 미리 지정한 어떤 문자열일 수도 있고, 
        특정 트랜잭션 ID로 지정할 수도 있다.
        사고가 어느 트랜잭션 ID에서 발생했는지 알 수 있는 툴을 사용할 수 없다면, 
        단순한 특정 시각, 또는 관리자가 미리 지정한 어떤 문자열을 지정하는 것이 
        복구 작업을 하는데 손쉽다.
   </para>

   <note>
     <para>
          복구 작업을 멈출 시점은 베이스 백업 시간 이후여야한다.  <function>pg_stop_backup</>
          명령이 실행된 시간보다 늦은 시점으로 지정해야한다.
          베이스 백업 - 데이터 클러스터 파일들을 파일 시스템 차원으로 백업하고 있었던 
          그 시간 대로 복구 할 수는 없다. 이 작업이 필요하다면, 
          이전 베이스 백업 자료와, 해당 WAL 백업 파일들이 필요하다.
     </para>
   </note>

   <para>
    만일 WAL 파일 자체에 문제가 있다면, 
        정상적으로 처리한 트랜잭션까지만 적용되고, 복구 작업은 멈추고, 
        서버도 중지된다. 이런 경우라면, 문제가 발생한 시점을 파악해서,
        처음부터 다시 그 시점 전까지만 <quote>recovery target</> 으로 지정해서 
        복구한다.
    반면, 복구 작업 도중 외부적인 영향으로 작업이 중지 되었다면, (시스템 리부팅, 
        disk full, .... 이런 이유들) 문제의 원인을 해결하고, 
        단순히 서버 재실행을 하면, 복구 작업을 이어서 계속 진행한다.
        복구 작업은 일반 실행환경에서의 체크 포인트 작업과 같이 재실행된다.
        내부적으로 <filename>pg_control</> 파일을 주기적으로 갱신해서, 
        이미 반영된 로그들에 대해서는 더이상 재작업을 하지 않도록 하기 때문에, 
        중복처리에 대한 염려는 안해도 된다.
   </para>

  </sect2>

  <sect2 id="backup-timelines">
   <title>타임라인</title>

  <indexterm zone="backup">
   <primary>타임라인</primary>
  </indexterm>

   <para>
    어떤 데이터베이스를 특정 시점으로 복원하는 것은 마치 
        공상과학 소설에서 나오는 시간여행이나, 다원우주론 같이 
        복잡한 여러 문제점을 만든다.
        예를 들어서, 그 데이터베이스의 최초의 변화 내역에서, 
        화요일 오후 5시 15분에 중요한 테이블을 지웠고, 
        그것을 수요일 아침까지 몰랐다고 치자. 이 때, 관리자는 
        침착하게, 백업 자료를 가지고, 화요일 오후 5시 14분까지 
        복구를 하고, 서버를 운영했다. 이렇게 해서 두 번째 변화 내역이 
        진행되었고, <emphasis>이</> 데이터베이스 변화 내역에서는 
        그 테이블이 삭제 되지 않고 계속 운영 되었다. 하지만, 
        좀 있다가 판단해 보니, 이 판단이 바람직한 것이 아닌 것 같아, 
        다시 최초의 변화 내역 기준으로 수요일 아침으로 데이터베이스를 상태로
        (그 중요 테이블이 지원진 채로 운영된 상태) 다시 되돌아야가야할 
        필요가 생긴다. 단순하게 생각하면, 이미 한 번 과거로 되돌아 갔고, 
        거기서 이미 WAL 파일을 덮어써 버렸기 때문에, 이 작업이 불가능할 것 같다.
        이 문제를 해결하기 위해서, 백업 WAL 세그먼트 파일을 이용한 데이터베이스
        복구 작업을 할 때는 서버가 각각의 복구 작업에 필요한 WAL 세그먼트 파일의
        이름을 다르게 해서 사용한다.
   </para>

   <para>
    이것을 <productname>Agens SQL</>에서는 <firstterm>타임라인</>이라는
        개념으로 설명하고 있다.
        복구 작업이 끝나고, 데이터베이스가 새롭게 실행되면, 
        새로운 타임라인 ID로 WAL 레코드를 만든다.
        이 타임라인 ID는 WAL 세그먼트 파일 이름의 한 부분으로 사용되어
        같은 트랜잭션 번호에 대해서도 다른 WAL 파일을 만들 수 있도록 해서, 
        예전 데이터베이스 변경 내역 정보를 덮어쓰지 않도록 한다.
        이런 방식이면, 얼마든지 다양한 타임라인이 존재할 수 있다.
        필요 없는 기능 같아 보이기는 하지만, 이 기능이 가끔 구원자 역할을 톡톡히 한다.
        복구시점을 정확히 모르고, 그 시점을 정확하게 찾을 때까지 계속 복구 작업을 
        계속 해야하는 상황에 아주 유용하게 사용된다.
        타임라인 정보가 없다면, 이런 작업은 거의 관리가 안될 정도로 복잡해저버린다.
        타이라인을 사용하면, 이미 분기 되어 더이상 사용하지 않는 <emphasis>어떠한</>
        이전 데이터베이스 상태로도 되돌아 갈 수 있다.
   </para>

   <para>
    새로운 타임라인으로 운영될 때마다 <productname>Agens SQL</>에서는
        <quote>타임라인 내역</> 파일을 만든다. 이 파일에는 언제, 어디서 분기되었는지 대한
        정보를 담고 있다.
        이 내역 파일은 다중 타임라임이 있을 경우, 사용자가 지정한 특정 타임라인을 
        사용할 때, 어느 WAL 파일을 사용해야하는지에 대한 정보를 담고 있어, 복원 작업에 
        사용된다. 즉, 이 파일 또한 새롭게 생성 되면, WAL 세그먼트 파일과 마찬가지로, 
        바로 WAL 세그먼트 파일 백업 처리할 때와 마찬가지로 archive_command 설정값에서 지정한 
        작업을 진행해서, 따로 보관 된다. 이 내역 파일은 (큰 크기의 WAL 세그먼트 파일과 달리)
        단순한 텍스트 파일이다. 그래서 충분히 많은 파일들을 보관 할 수 있다.
        또한 해당 내역 파일을 문서편집기로 열어서, 그 복구 내역에 대한 구체적인 
        내용을 기록해 두면, 나중에 여러모로 쓸모가 있을 것이다.
   </para>

   <para>
    복구 작업에서 기준이 되는 타임라인은 특별히 다른 타임라인을 지정하지 않으며, 
        베이스 백업 당시 사용되었던 타임라인을 사용한다. 
        만일 다른 타임라인을 사용하려면, <filename>recovery.conf</> 파일에
        원하는 타임라인 ID를 지정해주면 된다. 물론 이 타임라인은 반드시 베이스 백업 뒤에
        사용한 하위 타임라인 가운데 하나여야 한다.
   </para>
  </sect2>

  <sect2 id="backup-tips">
   <title>팁과 예제</title>

   <para>
    아카이브 모드를 사용하는 환경설정에 관계된 몇가지 팁과 예제를 여기서 소개한다.
   </para>

    <sect3 id="backup-standalone">
     <title>독립된 핫백업</title>

     <para>
          <productname>Agens SQL</> 백업 방식으로 독립된 핫백업을 구현할 수 있다.
          이 방식으로 구현하면, 특정시점 복구는 불가능해지지만, 
          장애복구시, <application>pg_dump</> 프로그램을 이용해서, 만든 덤프 파일을 
          사용하는 복구보다 훨씬 빠른 시간안에 복구 할 수 있다.
          (물론 <application>pg_dump</>의 덤프 파일 크기가 데이터 클러스터 디렉토리
          사이즈에 비해 아주 적은 경우라면, 오히려 더 늦을 수도 있을 것이다.)
          베이스 백업에서 언급했던 것처럼 독립된 핫백업 서버를 구축하는 
          가장 손쉬운 방법은 pg basebackup 툴을 이용해서 
          베이스 백업을 받는 것이다. pg basebackup을 호출할 때 <literal>-X</> 매개변수를 쓰면 사용되는 트랜잭션 로그 전체가 백업에 자동으로 쓰이고, 그 이상의 작업은 필요 없다. 

     </para>

     <para>
          백업 파일을 복사하는데 보다 유연한 방법이 필요한 경우라면, 
          보다 저수준의 작업으로 독립된 핫백업을 구현할 수 있다.
          독립된 핫백업을 구축하려면, <varname>wal_level</> 값은 
      <literal>archive</> 또는 그보다 자세히, <varname>archive_mode</> 값은
      <literal>on</>, <varname>archive_command</> 값으로 
          <emphasis>스위치 파일</>이 있는 경우에 한해서 그 파일을 다른 곳에도 보관할 수 있도록
          설정하면 된다. 다음은 이 설정의 예제다:
<programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'
</programlisting>
      윗 설정은 <filename>/var/lib/pgsql/backup_in_progress</> 파일이 없으면,
          그냥 건너뛰고, 이 파일이 있으면 복사하려는 WAL 세그먼트 파일이 없는 경우만 
          다른 곳에 복사하는 작업을 한다. (이렇게 해서, 
          <productname>Agens SQL</> 서버가 더이상 쓸모가 없는 WAL 파일을 다시 
          사용할 수 있도록 한다.)
     </para>

     <para>
      WAL 세그먼트 파일들의 백업 설정을 위가 같이 해 두고, 아래와 같이 베이스 백업 스크립트를 만든다:
<programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
</programlisting>
      <filename>/var/lib/pgsql/backup_in_progress</> 이름으로 
          스위치 파일을 먼저 만들어, 베이스 백업을 준비하는 동안만
          WAL 파일을 다른 장소에 따로 보관하고,
          베이스 백업을 tar 파일로 만들고,
          백업 작업이 끝났다고 서버쪽에 알리고, 스위치 파일을 지우고,
          tar 작업을 하는 동안 생긴 생긴 WAL 파일들을 
          같은 tar 파일에 추가하고 작업을 끝낸다.
      이 때 이 스크립트의 오류를 확인해 예외처리를 해야할 필요도 있다.
     </para>

     <para>
          저장 공간이 넉넉치 않다면, <application>pg_compresslog</>,
      <ulink url="http://pglesslog.projects.postgresql.org"></ulink>, 프로그램을
          이용해서, 필요없는 full page writes 정보와, 
          실재 작업할 내용이 없는 WAL 파일의 영역을 정리해서 보관할 수도 있다.
      거기다 <application>pg_compresslog</> 프로그램으로 정리된 내용을 
          <application>gzip</application> 프로그램을 이용해서 더 압축할 수도 있다:
<programlisting>
archive_command = 'pg_compresslog %p - | gzip &gt; /var/lib/pgsql/archive/%f'
</programlisting>
      복구 할 때는 <application>gunzip</> 프로그램과,
      <application>pg_decompresslog</> 프로그램을 다음과 같이 사용한다:
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f | pg_decompresslog - %p'
</programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
     <title><varname>archive_command</varname> 스크립트</title>

     <para>
          많은 사람들이 <varname>archive_command</varname> 설정값으로
          <filename>postgresql.conf</> 파일에 아래와 같이 스크립트를 
          사용해서, 그 값을 단순화 한다:
<programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
</programlisting>
      아카이빙 작업을 단순한 시스템 명령들의 조합으로 설정하기 보다, 
          하나의 스크립트로 지정해 놓으면, 백업 관련 작업과, 데이터베이스 관리 작업을
          분리할 수 있어, 얻는 이득이 많다. 필요하다면, 그 스크립트만
          수정하면 백업 정책을 언제든지 바꿀 수 있기 때문이다.
          이렇게 하면, 많이 쓰는 <application>bash</> 또는
          <application>perl</> 스크립트로 작성할 수 있으며, 보다 안전하고, 
          꼼꼼한 작업을 할 수 있다.
          <tip>
          <para>
            <varname>archive_command</varname> 에서 지정한 스크립트의 로그를 
                서버 로그로 저장하고 싶다면, logging collector 
                환경 설정값을 on으로 켜두면 된다.
                이렇게 하면, 스크립트에서 <systemitem>stderr</> 쪽으로 출력하는 모든 
                내용은 서버 로그로 저장된다. 이렇게 해서, 보다 손 쉽게 오류를 검사 할 수 있다.
          </para>
          </tip>
          스크립트를 실행하면서 생기는 모든 <literal>stderr</> 출력은
          데이터베이스 서버 로그로 기록된다.  이렇게 해서, 
          백업 스크립트 오류를 쉽게 진단할 수 있다.
     </para>

     <para>
      이 스크립트를 만들 때는 다음 항목들에 대한 고려도 함께 하면 좋다:
      <itemizedlist>
       <listitem>
        <para>
         파일이 복사 되면서 발생하는 파일 누출 문제 - 보안 문제
        </para>
       </listitem>
       <listitem>
        <para>
                 WAL 파일 복사(전송, 다른 곳에 따로 보관하는 것)의 가장 안전하고, 확실한 방법
                 - 실패 했을 경우 재시도에 대한 정책, 복구를 빠르게 하기 위한 이중 백업 등
        </para>
       </listitem>
       <listitem>
        <para>
                 다른 백업, 복구 소프트웨어를 사용할 때의 인터페이스 문제
         Interfacing with other backup and recovery software
        </para>
       </listitem>
       <listitem>
        <para>
         오류 모니터링 소프트웨어와의 인터페이스 문제
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
   <title>위험부담</title>

   <para>
    여기서는 아카이브 모드 백업 기술의 여러가지 한계점을 소개하고 있다.
    이 한계들은 미래의 배포판에서 수정될 예정이다:

  <itemizedlist>
   <listitem>
    <para>
     해시 인덱스 작업에 대한 기록은 WAL 로그에 포함되지 않는다.
     그래서, 이런 인덱스들에 대해서는 대기(standby) 서버(복원 서버)에서
     삽입, 갱신 작업을 하지 않는다. 다시 말하면, 이렇게 제대로 반영되지 않은
     인덱스 때문에, 원한는 결과가 출력되지 않을 수 있다.
     만일 해시 인덱스를 사용하고 있다면, 복원 작업이 끝난 뒤에 수동으로 
     REINDEX 작업을 해야한다.
    </para>
   </listitem>

   <listitem>
    <para>
     베이스 백업이 시작 된 다음 CREATE DATABASE 명령으로
     새 데이터베이스가 만들어지고, 그 데이터베이스를 만들 때, 원본이 되었던 
     템플릿 데이터베이스가 베이스 백업이 끝나기 전에 변경 되었다면, 
     복원 작업을 할 때, 원본이 되었던 모습과 같은 새 데이터베이스가 
     만들어지지 않을 가능성이 있다. 이 문제를 피하려면, 베이스 백업 중에는 
     템플릿 데이터베이스를 변경 하지 않는 것이 가장 좋은 방법이다.
    </para>
   </listitem>

   <listitem>
    <para>
     CREATE TABLESPACE 명령은 거기서 사용하는 실재 경로가
     그대로 반영 된다. 이 말은 복원 하는 시점에 미리 그 실재 경로의 
     디렉토리가 있어야함을 의미한다(물론 처음 테이블스페이스를 만들 때 처럼
     그 디렉토리는 비어있고, 소유주와 접근권한이 데이터베이스가 사용할 수 있는 
     상태여야한다).
     이점은 복원 작업에서 상당한 주의가 필요하다. 
     만일 같은 호스트에서 복원을 하는데, 임시 복원 작업을 진행하면서, 
     그 테이블스페이스에 있던 원본 파일을 손상 할 수도 있으며, 
     다른 호스트에서 테이블스페이스의 실재 디렉토리가 없어서, 
     원본 자료를 손실 할 수도 있다.
     이 문제를 피해갈 수 있는 가장 좋은 방법은, 
     일단 테이블스페이스를 만들거나, 삭제할 경우에는 반드시 그 다음에, 
     베이스 백업본을 만들어 두는 것이다.
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <para>
    또 다른 단점은 기본 <acronym>WAL</acronym> 포멧은 많은 디스크 
    페이지 스냅샷을 포함하고 있어, 그 크기가 상당히 크다는 점이다.
    이 페이지 스냅샷 기법은 서버가 갑자기 중지 될 경우, 해당 디스크 페이지가
    부분적으로 기록되었을 경우, 그 페이지를 안전하게 복구 하기 위해서 도입되었다. 
    물론 사용하고 있는 하드웨어와 소프트웨어에 따라, 
    이런 부분적인 디스크 페이지 기록으로 인한 오류가 미비하거나, 무시할 정도일 
    경우도 있다. 이럴 경우, full page writes 환경변수 값을
    off로 설정하면, 이 로그 전체 크기를 많이 줄일 수 있다.
    (하지만, 먼저 29장을 꼼꼼히 살펴 보고, 결정하라.)
    이 환경변수값을 off로 설정해도 PITR 기능을 사용할 수 있다.
    또한 <varname>full_page_writes</> 값이 on 이더라도, 
    아카이브 로그를 만들 때, 필요없는 페이지 복사본들은 버리고, 
    복원에 필요한 것만 담아서 만드는 방식도 도입되어야할 것이다.
    (미래의 개발자들에게 이 일은 넘긴다.)
    운영 입장에서, 관리자는 체크 포인트 간격을 늘려서 이 WAL 로그를 
    적게 만드는 방법도 한 방법이다.
   </para>
  </sect2>
 </sect1>

</chapter>

