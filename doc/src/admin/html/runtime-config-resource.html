<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>리소스 소비</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="서버 환경 설정"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="연결 및 인증"
HREF="runtime-config-connection.html"><LINK
REL="NEXT"
TITLE="Write Ahead 로그"
HREF="runtime-config-wal.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-30T08:52:27"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="연결 및 인증"
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 2. 서버 환경 설정</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Write Ahead 로그"
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-RESOURCE"
>2.4. 리소스 소비</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-MEMORY"
>2.4.1. Memory</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SHARED-BUFFERS"
></A
><TT
CLASS="VARNAME"
>shared_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>데이터베이스 서버가 공유 메모리 버퍼용으로 사용하는 메모리 양을 설정한다. 
기본값은 일반적으로 128메가바이트(<TT
CLASS="LITERAL"
>128MB</TT
>)이지만 커널 설정에서 지원하지 않는 경우 
여기에 미치지 못할 수 있다(<SPAN
CLASS="APPLICATION"
>initdb</SPAN
> 중에 결정됨). 
이 설정은 최소 128킬로바이트여야 한다. (기본값이 아닌 <TT
CLASS="SYMBOL"
>BLCKSZ</TT
> 값은 최소값을 변경한다.) 
단, 최소값보다 훨씬 큰 설정은 일반적으로 우수한 성능이 필요할 때 사용된다. 
 </P
><P
>RAM이 1GB 이상인 전용 데이터베이스 서버를 사용하는 경우 <TT
CLASS="VARNAME"
>shared_buffers</TT
>의 적절한 시작 값은 시스템 메모리의 25%이다. 
작업 부하는 <TT
CLASS="VARNAME"
>shared_buffers</TT
>에 대한 설정이 클수록 효과적이지만, 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 역시 운영 체제 캐시에 의존적이므로 시스템 효율을 위해 
40% 이상의 RAM을 <TT
CLASS="VARNAME"
>shared_buffers</TT
>에 할당하는 것은 좋지 않다.
장시간에 걸쳐 대량의 새 데이터 또는 변경된 데이터 쓰기 프로세스를 실행하기 위해 
<TT
CLASS="VARNAME"
>shared_buffers</TT
>를 더 크게 설정하면 <TT
CLASS="VARNAME"
>checkpoint_segments</TT
>에서도 그에 맞게 설정을 증가시켜야 한다.
 </P
><P
>시스템 RAM이 1GB 미만인 경우에는 운영 체제를 위한 적정 공간이 필요하므로 RAM 비율을 더 작게 하는 것이 맞다. 
또한 Windows에서 <TT
CLASS="VARNAME"
>shared_buffers</TT
> 값을 크게 하는 것은 효과적이지 않다. 
설정을 작게 하고, 운영 체제는 캐시는 상대적으로 크게 함으로써 더 나은 결과가 나올 수도 있다. 
Windows 시스템의 <TT
CLASS="VARNAME"
>shared_buffers</TT
>에 대한 유용한 범위는 64MB ~ 512MB이다.
 </P
></DD
><DT
><A
NAME="GUC-HUGE-PAGES"
></A
><TT
CLASS="VARNAME"
>huge_pages</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>거대(huge) 메모리 페이지를 활성/비활성으로 설정한다. 
유효 값은 <TT
CLASS="LITERAL"
>try</TT
>(기본값) 및 <TT
CLASS="LITERAL"
>on</TT
>, <TT
CLASS="LITERAL"
>off</TT
>이다.
 </P
><P
>현재 이 기능은 Linux에서만 지원된다. <TT
CLASS="LITERAL"
>try</TT
>로 설정되면 다른 시스템에서는 무시된다.
 </P
><P
>huge pages 페이지를 사용하면 결과적으로 메모리 관리에 더 작은 페이지 테이블과 더 짧은 CPU 시간을 사용하여 성능이 높아진다.
자세한 내용은 <A
HREF="kernel-resources.html#LINUX-HUGE-PAGES"
>1.4.4절</A
>을 참조 바란다.
 </P
><P
><TT
CLASS="VARNAME"
>huge_pages</TT
>를 <TT
CLASS="LITERAL"
>try</TT
>로 설정하면 서버가 huge pages의 사용하지만, 
실패 시 일반적인 할당을 사용하는 쪽으로 폴백한다. 
<TT
CLASS="LITERAL"
>on</TT
>의 경우 huge pages 사용에 실패하면 서버가 시작되지 않는다. 
<TT
CLASS="LITERAL"
>off</TT
>의 경우 huge pages를 사용하지 않는다.
 </P
></DD
><DT
><A
NAME="GUC-TEMP-BUFFERS"
></A
><TT
CLASS="VARNAME"
>temp_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>각 데이터베이스 세션이 사용하는 임시 버퍼의 최대 수를 설정한다. 
임시 테이블에 액세스하는 용도로만 사용되는 세션-로컬 버퍼가 있다. 
기본값은 8메가바이트(<TT
CLASS="LITERAL"
>8MB</TT
>)이다. 
설정은 개별 세션 내에서 변경할 수 있지만, 세션 내 임시 테이블을 처음 사용하기 전에만 가능하다. 
이후에 값을 변경하면 해당 세션에서 효과가 없다.
 </P
><P
>세션은 <TT
CLASS="VARNAME"
>temp_buffers</TT
>에 설정된 한계까지 필요한 임시 버퍼를 할당한다. 
실제로는 임시 버퍼가 많이 필요 없는 세션에서 큰 값을 설정하는 데 드는 비용은 
<TT
CLASS="VARNAME"
>temp_buffers</TT
> 증가분당, 버퍼 디스크립터 혹은 약 64바이트에 불과하다. 
그러나 버퍼가 실제로 사용되는 경우에는 8192바이트가 추가적으로 필요하다(또는 일반적으로 <TT
CLASS="SYMBOL"
>BLCKSZ</TT
> 바이트).
 </P
></DD
><DT
><A
NAME="GUC-MAX-PREPARED-TRANSACTIONS"
></A
><TT
CLASS="VARNAME"
>max_prepared_transactions</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>동시에 <SPAN
CLASS="QUOTE"
>"준비된"</SPAN
> 상태일 수 있는 트랜잭션의 최대 수.
 </P
><P
>준비된 트랜잭션을 사용할 계획이 없으면 이 매개변수는 0으로 설정하여 준비된 트랜잭션을 생성하는 실수를 방지해야 한다. 
준비된 트랜잭션을 사용하는 경우 <TT
CLASS="VARNAME"
>max_prepared_transactions</TT
>가 최소한 
<A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
> 이상이 되도록 설정하면 세션이 준비된 트랜잭션을 보류시킬 수 있다.
 </P
><P
>대기 서버 실행 시 마스터 서버 값보다 크거나 같게 설정해야 한다. 그렇게 하지 않으면 대기 서버가 쿼리를 허용하지 않는다.
 </P
></DD
><DT
><A
NAME="GUC-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>임시 디스크 파일을 쓰기 전에 내부 정렬 명령 및 해시 테이블에서 사용되는 메모리 양을 지정한다. 
기본값은 4메가바이트이다(<TT
CLASS="LITERAL"
>4MB</TT
>). 복잡한 쿼리의 경우 몇 가지 정렬 또는 해시 명령이 병렬로 실행될 수 있다. 
각 명령은 데이터를 임시 파일에 쓰기 전에 이 값에 지정된 크기만큼 메모리를 사용할 수 있다. 
실행 중인 세션들은 해당 명령을 동시에 실행할 수도 있다. 사용된 총 메모리는 <TT
CLASS="VARNAME"
>work_mem</TT
>의 배수가 된다.
정렬 명령은 <TT
CLASS="LITERAL"
>ORDER BY</TT
> 및 <TT
CLASS="LITERAL"
>DISTINCT</TT
>, 머지 조인에 사용된다. 
해시 테이블은 해시 조인, 해시 기반 집계(aggregation), <TT
CLASS="LITERAL"
>IN</TT
> 서브쿼리의 해시 기반 처리에 사용된다.
 </P
></DD
><DT
><A
NAME="GUC-MAINTENANCE-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>maintenance_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="COMMAND"
>VACUUM</TT
>, <TT
CLASS="COMMAND"
>CREATE
INDEX</TT
> 및 <TT
CLASS="COMMAND"
>ALTER TABLE ADD FOREIGN KEY</TT
> 같은 유지보수 명령에서 사용되는 최대 메모리 양을 지정한다. 
기본값은 64메가바이트이다(<TT
CLASS="LITERAL"
>64MB</TT
>). 
이 명령은 데이터베이스 세션에서 한 번에 하나만 실행할 수 있으며, 정상 설치에는 동시 실행되는 명령이 여러 개 있을 수 없다. 
이 값은 <TT
CLASS="VARNAME"
>work_mem</TT
>보다 훨씬 큰 값으로 설정하는 것이 안전하다. 
설정값이 큰 경우에는 vacuuming 및 데이터베이스 덤프 복구 성능이 개선될 수 있다.
 </P
><P
>autovacuum 실행 시 이 메모리에서 <A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
>의 배수로 할당할 수 있으므로 
기본값을 너무 높게 설정하지 않도록 해야 한다. 
<A
HREF="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM"
>autovacuum_work_mem</A
>을 별도로 설정하여 이것을 관리하는 것이 유용할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-AUTOVACUUM-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>autovacuum_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>각 autovacuum worker 프로세스에서 사용되는 최대 메모리 양을 지정한다. 
기본값은 <A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
> 값을 대신 사용해야 함을 나타내는 -1이다. 
다른 컨텍스트에서 실행하는 경우 이 설정은 <TT
CLASS="COMMAND"
>VACUUM</TT
>에 영향을 끼치지 않는다.
 </P
></DD
><DT
><A
NAME="GUC-MAX-STACK-DEPTH"
></A
><TT
CLASS="VARNAME"
>max_stack_depth</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>서버 실행 스택의 최대 안전 깊이를 지정한다. 
이상적인 설정은 커널이 강제로 지정한 안전 마진(safety margin)에서 약간 부족하게 설정하는 것이다.
(<TT
CLASS="LITERAL"
>ulimit -s</TT
>에 의해 설정된 대로 하거나 로컬과 동등하게). 
표현식 평가(expression evaluation) 같이 서버의 모든 루틴이 아니라 
잠재적 재귀 루틴 중 중요한 것만 스택 깊이가 검사되기 때문에, 안전 마진(safety margin)이 필요하다. 
기본 설정은 기본적으로 작고, 충돌 가능성이 낮은 2메가바이트이다(<TT
CLASS="LITERAL"
>2MB</TT
>). 
그러나, 설정값이 너무 작으면 복합 함수의 실행이 어려울 수 있다. 슈퍼유저만 이 설정을 변경할 수 있다.
 </P
><P
>실제 커널 제한보다 <TT
CLASS="VARNAME"
>max_stack_depth</TT
>를 큰 값으로 설정하면 런어웨이 재귀 함수가 백엔드 프로세스와 충돌할 수 있다. 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 커널 제한을 결정할 수 있는 플랫폼에서 서버는 이 변수가 불안정한 값으로 설정되는 것을 허용하지 않는다. 
그러나 모든 플랫폼이 정보를 제공하지는 않으므로 값 선택 시 신중을 기해야 한다.
 </P
></DD
><DT
><A
NAME="GUC-DYNAMIC-SHARED-MEMORY-TYPE"
></A
><TT
CLASS="VARNAME"
>dynamic_shared_memory_type</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>서버가 사용해야 하는 동적 공유 메모리 구현을 지정한다. 
가능한 값은 <TT
CLASS="LITERAL"
>posix</TT
>(<TT
CLASS="LITERAL"
>shm_open</TT
>을 사용하여 할당된 POSIX 공유 메모리의 경우) 및
<TT
CLASS="LITERAL"
>sysv</TT
>(<TT
CLASS="LITERAL"
>shmget</TT
>을 통해 할당된 System V 공유 메모리의 경우), 
<TT
CLASS="LITERAL"
>windows</TT
>(Windows 공유 메모리의 경우), 
<TT
CLASS="LITERAL"
>mmap</TT
>(데이터 디렉토리에 저장된 메모리 맵 파일을 사용하는 공유 메모리 시뮬레이션). 
<TT
CLASS="LITERAL"
>none</TT
>(이 기능 비활성)이다. 
일부 플랫폼에서는 몇 개가 지원되지 않는다. 
첫 번째 지원 옵션은 해당 플랫폼의 기본값이다. 
플랫폼에서 기본값이 아닌 <TT
CLASS="LITERAL"
>mmap</TT
> 옵션의 사용은 일반적으로 권장하지 않는다. 
이유는 운영 체제가 수정된 페이지를 디스크에 반복해서 다시 쓰면서 시스템 I/O 로드가 늘어나기 때문이다. 
그러나, <TT
CLASS="LITERAL"
>pg_dynshmem</TT
> 디렉토리를 RAM 디스크에 저장하거나 다른 공유 메모리 기능을 사용할 수 없는 경우에는 디버깅용으로 유용하다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-DISK"
>2.4.2. 디스크</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-TEMP-FILE-LIMIT"
></A
><TT
CLASS="VARNAME"
>temp_file_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>정렬 및 해시 임시 파일 같은 임시 파일 또는 보류된 커서용 저장소 파일에 세션이 사용할 수 있는 디스크 공간의 최대 크기를 지정한다. 
이 제한을 초과하는 트랜잭션은 취소된다. 값은 킬로바이트 단위로 지정되며 <TT
CLASS="LITERAL"
>-1</TT
>(기본값)은 무제한을 의미한다. 
슈퍼유저만 이 설정을 변경할 수 있다.
 </P
><P
>이 설정은 주어진 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>세션이 동시에 사용하는 모든 임시 파일의 총 공간을 제한한다. 
쿼리 실행 시 조용히 사용되는 임시 파일과 달리, 
명시적 임시 테이블용으로 사용되는 디스크 공간은 이 제한에 합산되지 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>않는다</I
></SPAN
>는 점에 유의해야 한다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-KERNEL"
>2.4.3. 커널 리소스 사용량</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-FILES-PER-PROCESS"
></A
><TT
CLASS="VARNAME"
>max_files_per_process</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>서버 하위 프로세스별로 허용된 동시 오픈 파일의 최대 수를 설정한다. 기본값은 1000이다. 
커널이 프로세스별 안전 한계를 강제하는 경우 이 설정은 신경 쓸 필요가 없다. 
그러나 일부 플랫폼(특히, 대부분의 BSD 시스템)에서는 여러 개의 프로세스가 모두 여러 파일을 열려고 할 때
커널은 시스템이 실제로 지원하는 파일 수보다 많아도 여는 것을 시도한다.
<SPAN
CLASS="QUOTE"
>"Too many open files"</SPAN
> 실패가 나타난 경우 이 설정을 줄여야 한다. 
이 매개변수는 서버 시작 시 설정된다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-VACUUM-COST"
>2.4.4. 비용기반 Vacuum 지연</A
></H2
><P
>VACUUM 및 ANAYLYZE 명령 실행 시 다양한 I/O 명령을 수행하는 데 드는 예상 비용을 추적하는 내부 카운터가 시스템에 있다.
누적 비용이 제한값(<TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
>으로 지정)에 도달하면 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>에서 지정된 값만큼 
명령을 수행하는 프로세스가 잠시 슬립 상태가 된다. 
그런 다음, 카운터가 리셋되고 실행이 계속된다.
 </P
><P
>이 기능으로 관리자는 데이터베이스 동시 작업 시 이러한 명령들이 I/O에 주는 부담을 완화시킬 수 있다. 
<TT
CLASS="COMMAND"
>VACUUM</TT
> 및 <TT
CLASS="COMMAND"
>ANALYZE</TT
> 같은 유지 보수 명령이 빨리 마무리되는 것이 중요하지 않을 때도 있다.
그러나, 일반적으로는 이 명령 때문에 다른 데이터베이스 명령을 수행 중인 시스템 능력이 저해되지 않게 하는 것이 중요하다.
비용 기반 vacuum 지연은 관리자가 이것을 수행하는 방법을 제공한다.
 </P
><P
><TT
CLASS="COMMAND"
>VACUUM</TT
> 명령을 직접 실행하면 기본적으로 실행되지 않는다.
사용하는 것으로 설정하려면 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> 변수를 0 이외의 값으로 설정해야 한다.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-VACUUM-COST-DELAY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 비용 제한을 초과한 경우 프로세스가 슬립하는 초 단위의 시간 길이. 기본값은, 비용 기반 vacuum 지연 기능을 사용하지 않는 0이다. 
 양의 값은 비용 기반 vacuuming을 사용하는 것으로 설정된다. 다수의 시스템에서 슬립 지연의 효율적인 설정은 10밀리초이다. 
 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>를 10의 배수가 아닌 다른 값으로 설정하면 10의 배수로 값을 올림하여 설정한 것과 결과가 동일하다.</P
><P
> 비용 기반 vacuuming을 사용하는 경우 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>는 일반적으로 매우 작으며, 보통 10 ~ 20밀리초이다. 
 vacuum의 자원 소비를 조절하려면 다른 vacuum 비용 매개변수를 변경하는 것이 가장 좋다.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-HIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_hit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 공유 버퍼 캐시에 있는 버퍼 vacuuming의 예상 비용. 
 이것은 버퍼 풀을 잠그고, 공유 해시 테이블을 조회하고 페이지 내용을 스캔 하는 비용을 나타낸다. 기본값은 1이다.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-MISS"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_miss</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 디스크에서 읽어온 버퍼를 vacuuming하는 데 드는 예상 비용. 
 이것은 버퍼 풀을 잠그고, 공유 해시 테이블을 조회하고, 디스크에어 원하는 블록을 읽고, 내용을 스캔하는 비용을 나타낸다. 기본값은 10이다.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-DIRTY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_dirty</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 이전에 클린한 블록을 vacuum이 수정하는 경우 예상 비용. 이것은 dirty 블록을 디스크에 다시 쓰는 데 필요한 추가 I/O를 나타낸다. 기본값은 20이다.</P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-LIMIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> vacuuming 프로세스를 슬립 시키는 누적 비용. 기본값은 200이다.</P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 일부 명령은 critical locks을 갖고 있으며 따라서, 이러한 명령은 가능한 한 신속하게 완료해야 한다. 
 해당 명령이 수행되는 중에는 비용 기반 vacuum 지연이 발생하지 않는다. 
 따라서, 지정된 제한보다 비용이 훨씬 더 많아져 누적될 수도 있다. 
 이런 경우 쓸데없이 긴 지연을 방지하기 위해 실제 지연은 최대값이 
 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * 4인 
 <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * <TT
CLASS="VARNAME"
>accumulated_balance</TT
> / <TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
>으로 계산된다. </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER"
>2.4.5. 백그라운드 Writer</A
></H2
><P
><I
CLASS="FIRSTTERM"
>백그라운드 writer</I
>라는 별도의 서버 프로세스가 있는데, 
이 기능은 <SPAN
CLASS="QUOTE"
>"더티(dirty)"</SPAN
>(신규 또는 수정) 공유 버퍼에 쓰기 작업을 실행하는 것이다. 
이것은 공유 버퍼에 쓰는 것이므로, 서버는 사용자 쿼리를 거의 처리하지 않거나 쓰기가 시작될 때까지 기다릴 필요도 없다. 
그러나, 반복적으로 더티 페이지가 체크포인트 간격당 한 번만 기록될 수 있는 반면, 
동일한 간격으로 더티 페이지에 백그라운드 writer가 여러 번 쓸 수 있으므로 백그라운드 writer는 최종적으로 I/O 로드의 전반적인 증가를 초래한다. 
이 절에서 논의된 매개변수는 로컬로 필요한 동작을 조절하는 데 이용할 수 있다.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-BGWRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>bgwriter_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 백그라운드 writer의 작업 라운드 사이의 지연을 지정한다. 
 각 라운드에서 writer는 몇 개의 dirty 버퍼(다음 매개변수로 조절 가능)에 대해 쓰기를 실행한다. 
 그리고 <TT
CLASS="VARNAME"
>bgwriter_delay</TT
> 밀리초 동안 슬립한 다음, 반복한다. 
 버퍼 풀에 더티 버퍼가 없으면, <TT
CLASS="VARNAME"
>bgwriter_delay</TT
>와 무관하게 장기 슬립으로 들어간다. 
 기본값은 200밀리초이다(<TT
CLASS="LITERAL"
>200ms</TT
>). 다수의 시스템에서 효율적인 슬립 지연 설정은 10밀리초이다. 
 <TT
CLASS="VARNAME"
>bgwriter_delay</TT
>를 10의 배수가 아닌 다른 값으로 설정하면 10의 배수로 값을 올림하여 설정한 것과 결과가 동일하다. 
 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.</P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MAXPAGES"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 각 라운드에서 이것보다 큰 버퍼 수는 백그라운드 writer가 쓰지 않는다.
 이것을 0으로 설정하면 백그라운드 쓰기가 사용되지 않는다. 
 (별도의 전용 보조 프로세스에 의해 관리되는 해당 체크포인트들은 영향을 받지 않는다.)
 기본값은 100개 버퍼이다. 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.</P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MULTIPLIER"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>)
 </DT
><DD
><P
> 각 작업에 쓰기 된 더티 버퍼의 개수는 최근 작업들 수행 중에 서버 프로세스가 필요 했던 새 버퍼의 개수이다.
 최근 평균 요구량에 <TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
>를 곱하면 다음 작업에서 필요한 버퍼 추정치에 가깝다.
 깨끗하고 재사용 가능한 버퍼 수가 충분히 남아 있을 때까지 더티 버퍼는 쓰여진다. 
 (그렇더라도 작업당 <TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> 이상의 버퍼는 쓰여지지 않는다.) 
 따라서, 1.0을 설정하면 정확히 필요한 버퍼 수를 기록하는 <SPAN
CLASS="QUOTE"
>"just in time"</SPAN
> 정책을 나타낸다. 
 더 큰 값을 설정하면 수요 급증에 대비할 수 있는 반면, 
 더 작은 값은 쓰기를 서버 프로세스가 처리하도록 일부러 미처리 상태로 방치한다. 기본값은 2.0이다. 
 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.</P
></DD
></DL
></DIV
><P
><TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> 및 <TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> 값을 더 작게 설정하면 
백그라운드 writer로 인한 I/O 로드는 줄어들지만, 서버 프로세스가 자체적으로 쓰기를 실행해야 하므로 쿼리 수행 지연될 가능성이 높다.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR"
>2.4.6. 비동기 동작</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-EFFECTIVE-IO-CONCURRENCY"
></A
><TT
CLASS="VARNAME"
>effective_io_concurrency</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 동시에 실행 가능할 것으로 예상하는 동시 디스크 I/O 실행 수를 설정한다. 
 이 값을 올리면 각 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 세션이 병렬 초기화를 시도하는 I/O 실행 수가 늘어난다. 
 허용 범위는 1 ~ 1000, 또는 비동기 I/O 요청의 실행을 비활성화하는 0이다. 
 현재, 이 설정은 비트맵 힙 스캔에만 영향을 미친다.</P
><P
> 이 설정을 위한 권장 시작점은 데이터베이스에서 사용되는 RAID 0 스트라이프 또는 RAID 1 미러를 환경 설정하는 개별 드라이브 수이다. 
 (RAID 5의 경우 패리티 드라이브 수는 계산하지 않는다. ) 
 그러나 동시 세션에서 여러 개의 쿼리가 실행된 상태에서 데이터베이스가 매우 바쁠 경우, 
 디스크 배열을 바쁜 상태로 유지하기 위해서는 적은 값도 충분하다. 
 디스크를 바쁜 상태로 만들기 위해 필요 이상으로 큰 값을 설정하면 CPU 오버헤드만 가중된다.</P
><P
> 버스 대역폭에 의해 제한되는 메모리 기반 저장소 또는 RAID 배열 같은 외부 시스템의 경우, 가용한 I/O 경로 수를 설정해야 한다. 
 최상의 값을 찾아내려면 몇 가지 시험이 필요할 수도 있다.</P
><P
> 비동기 I/O는 효과적인 <CODE
CLASS="FUNCTION"
>posix_fadvise</CODE
> 함수에 따라 달라지며, 이것이 운영 체제에 없을 수도 있다. 
 이 함수가 없을 경우 이 매개변수를 0 이외의 다른 것으로 설정하면 에러가 발생한다. 
 일부 운영 체제(예: Solaris)에는 함수가 존재하지만 실제로는 아무것도 하지 않는다.</P
></DD
><DT
><A
NAME="GUC-MAX-WORKER-PROCESSES"
></A
><TT
CLASS="VARNAME"
>max_worker_processes</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 시스템이 지원할 수 있는 백그라운드 프로세스의 최대 수를 설정한다. 이 매개변수는 서버 시작 시 설정된다.</P
><P
> 대기 서버 실행 중에는 이 매개변수를 마스터 서버 값보다 크거나 같게 설정해야 한다. 그렇게 하지 않으면 대기 서버가 쿼리를 허용하지 않는다.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>연결 및 인증</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Write Ahead 로그</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>