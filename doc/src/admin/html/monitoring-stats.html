<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>통계 수집기</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="데이터베이스 성능 모니터링"
HREF="monitoring.html"><LINK
REL="PREVIOUS"
TITLE="표준 유닉스 도구들"
HREF="monitoring-ps.html"><LINK
REL="NEXT"
TITLE="잠금 보기"
HREF="monitoring-locks.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-30T08:52:27"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="표준 유닉스 도구들"
HREF="monitoring-ps.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 11. 데이터베이스 성능 모니터링</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="잠금 보기"
HREF="monitoring-locks.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="MONITORING-STATS"
>11.2. 통계 수집기</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> <I
CLASS="FIRSTTERM"
>통계 수집기</I
>는 
   서버 운영 상태에 대한 정보를 수집하거나 보고하기 위한 작업을 하는 백그라운드 시스템이다.  
   현재 이 수집기는 테이블이나 인덱스의 디스크 블록 단위 또는 개별 로우 단위의 접근
   횟수를 수집할 수 있다.  
   또한 각 테이블에 저장 되어있는 총 로우 수를 수집하며, 각 테이블에 대한 vacuum 작업과 analyze 작업에 관한 정보들도
   수집한다. 또한 사용자 정의 함수들의 호출 횟수와 그것들의 각 총 수행 시간들도 수집한다.
  </P
><P
>   또한 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는 각기 다른 서버 프로세스들이 자기가 무슨 작업을 하고 있는지에 대한 현재 상태를 살펴볼 수 있다. 
   이 기능은 수집기 프로세스와 별개로 제공하고 있는 기능이다.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-SETUP"
>11.2.1. 통계 수집기 환경설정</A
></H2
><P
>   통계 자료를 수집한다는 것은 궁극적으로는 그 만큼의 추가 비용을 서버가
   사용한다는 것을 의미한다. 그래서 그 추가 비용을 얼마만큼 쓸 것인지에
   대한 결정을 서버 환경변수로 제어할 수 있다. 다음은 
   <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 환경설정 파일에서 사용할 수 있는
   환경변수들이다. (이들에 대한 보다 자세한 부분은
   <A
HREF="runtime-config.html"
>2장</A
>을 참고하라.)
  </P
><P
>   track-activities 설정값을 활성화하면 각각의
   서버 프로세스들은 현재 자신이 하고 있는 작업을 프로세스 이름으로 보여준다.
  </P
><P
>   track-counts 설정값을 활성화하면 테이블과 인덱스의
   사용빈도를 통계 수집기가 수집한다.
  </P
><P
>   track-functions 설정값을 활성화하면 사용자 정의
   함수들의 사용빈도를 통계 수집기가 수집한다.
  </P
><P
>   track-io-timing 설정값을 활성화면 블록 읽기
   쓰기 회수를 통계 수집기가 수집한다.
  </P
><P
>   일반적으로 이 환경설정 변수들은 <TT
CLASS="FILENAME"
>postgresql.conf</TT
>에서
   그 값을 지정하면 이것은 모든 서버의 프로세스들을 대상으로 작동하게 된다.
   하지만 SET 명령을 이용해서 개별 세션 단위로 이 설정값을 변경할 수도 있다. 
   (이 작업은 일반 사용자가 악의적으로 사용될 가능성이 있기 때문에 슈퍼유저만 사용할 수 있다.)
  </P
><P
>   통계 수집기가 만든 정보는 stats-temp-directory 설정값으로
   지정한 디렉토리 (초기값은 <TT
CLASS="FILENAME"
>pg_stat_tmp</TT
>) 안에 있는
   임시 파일로 저장되고, 그것을 여러 다른 Agens SQL 프로세스들이 이용한다.
   보다 나은 성능을 위해서는 이 파일의 I/O 성능을 높이기 위해 이 디렉토리를
   메모리 기반 파일시스템에 두는 것도 좋은 방법이다. 이 통계 정보는 서버가
   중지 될 때 <TT
CLASS="FILENAME"
>pg_stat</TT
> 디렉토리 쪽으로 복사하는
   작업을 하기 때문에 서버 중지, 재시작에도 자료를 그대로 유지할 수 있다.
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-VIEWS"
>11.2.2. 수집된 통계 정보 보기</A
></H2
><P
>   수집된 통계 정보는 아래 <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
>표 11-1</A
>에서 나열한 여러 뷰를
   통해서 살펴 볼 수 있다. 다른 방법으로는 <A
HREF="monitoring-stats.html#MONITORING-STATS-FUNCTIONS"
>11.2.3절</A
>에서 제공하는
   여러 통계 정보 보기 함수들을 이용해서 필요한 뷰를 직접 만들어서
   살펴 볼 수도 있을 것이다.
  </P
><P
>   여기서 중요한 점은 살펴 보고 있는 통계 정보가 현재 데이터베이스의
   정확한 현재 상태가 아니라는 점이다. 각 개별 프로세스들이 수집한 통계
   정보는 그 프로세스가 아무런 작업을 하고 있지 않을 때 수집기에게 전달한다.
   즉 한 쿼리가 실행 되고 있다거나 트랜잭션 내에 있으면 그 과정에
   생긴 통계 정보들은 반영되지 않고 있다는 것이다. 또한 통계 수집기의
   작업은 <TT
CLASS="VARNAME"
>PGSTAT_STAT_INTERVAL</TT
> (기본값은 500ms 이다)
   시간 간격으로 진행된다. 즉 이 만큼의 통계 정보 오차가 발생한다.
   하지만 <TT
CLASS="VARNAME"
>track_activities</TT
> 관련 정보는 항상 즉시 반영 된다.
  </P
><P
>   또 다른 중요한 점은 한 통계 정보는 해당 뷰나 함수로 출력할 때,
   한 트랜잭션 내에서는 항상 같은 값을 출력한다. 즉, 트랜젹션이 끝날 때까지
   그 값을 유지한다. 이와 비슷하게 모든 세션들의 현재 쿼리에 대한 정보도
   하나의 트랜잭션 내에서는 같은 정보를 출력한다. 이것은 버그가 아니라
   특성이다. 이것은 한 트랜잭션 내에서 그 통계 정보가 일정하게 유지
   되도록해서 여러 다른 쿼리들에서 그 값을 일관성 있게 한다.  하지만 이것을
   원치 않는다면 각 쿼리들을 트랜잭션 단위로 분리해서 작업하면 된다.  다른
   방법으로 <CODE
CLASS="FUNCTION"
>pg_stat_clear_snapshot</CODE
>() 함수를 사용해서 
   현재 스냅샷으로 지정된 통계 정보를 버리고 새 통계 정보를 사용할 수도 있다.
  </P
><P
>   하나의 트랜잭션 내에서 그 자신의 통계 정보 (아직까지 수집기 쪽으로 보내지
   않은 현재 작업 내역에 대한 정보)들은 다음과 같은 뷰에서 제공한다:
   <TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
>,
   <TT
CLASS="STRUCTNAME"
>pg_stat_xact_sys_tables</TT
>,
   <TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_tables</TT
>, 
   <TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_functions</TT
>.
   이들의 통계 정보는 현재 트랜잭션 내에서도 자신의 세션 작업에 대한 통계치를
   반영 해서 다른 세션에서 수집된 정보와 자신의 세션에서 수집된 정보와 차이가 생길 수도 있다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-VIEWS-TABLE"
></A
><P
><B
>표 11-1. 표준 통계 정보 뷰</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>뷰 이름</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
>       <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>
       
      </TD
><TD
>       세션 프로세스들의 정보를 각각 하나의 로우로 보여준다.
       이 프로세스들은 현재 서버를 사용하고는 있고, 클라이언트가
       서버로 접속 해서 만들어진 하위 서버 프로세스들이다. 이들의
       현재 상태 및 실행 중인 쿼리들을 살펴 볼 수 있다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
></TD
><TD
>WAL 아카이버 프로세스 작동에 대한 
       통계 정보를 하나의 로우로 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
></TD
><TD
>       백그라운드 라이터 프로세스의 작업 통계 정보.
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
></TD
><TD
>한 로우에 하나씩 각 데이터베이스 전역 통계 정보를 보여 준다. 
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
></TD
><TD
>       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블 사용에 대한 통계 정보를 보여 준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_sys_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> 내용과 같은데, 시스템 테이블에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> 내용과 같은데, 시스템 테이블을 제외한
      현재 사용자 접근 할 수 있는 테이블에 대한 정보만 보여준다.</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다.
      (즉 <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> 쪽으로 반영 되지
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>않은</I
></SPAN
> 트랜잭션 내의 정보다).
      이 뷰에는 사용하는 실 로우 수, 사용하지 않는 로우(dead row) 수,
      vacuum과 analyze 작업에 관계된 정보는 제공하지 않는다.</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_sys_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는 테이블에 대해서만 보여준다.</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
></TD
><TD
>       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스 사용에 대한 통계 정보를 보여 준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_sys_indexes</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
> 내용과 같은데, 시스템 인덱스에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_indexes</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는 인덱스에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
></TD
><TD
>       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블에 대한 I/O 통계 정보를 보여 준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
> 내용과 같은데, 시스템 테이블에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_tables</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
> 내용과 같은데, 시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는 테이블에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
></TD
><TD
>       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스에 대한 I/O 통계 정보를 보여 준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_indexes</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_indexes</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
></TD
><TD
>       현재 접속한 데이터베이스에 속한 모든 시퀀스에 대해서
       한 로우씩 그 시퀀스에 대한 I/O 통계 정보를 보여 준다.
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_sequences</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
> 내용과 같은데,
      시스템 시퀀스에 대해서만 보여준다.
      (현재 사용하고 있는 시스템 시퀀스가 없음으로 이 뷰는
      항상 그 내용이 비어있을 것이다.)
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_sequences</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
> 내용과 같은데,
      시스템 시퀀스를 제외한 현재 사용자가 접근 할 수 있는
      시퀀스에 대해서만 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
></TD
><TD
>       현재 데이터베이스에 만들어진 사용자 정의 함수들의
       실행에 대한 통계 정보를 보여준다.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_functions</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다,
      (즉 <TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
> 쪽으로 반영 되지
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>않은</I
></SPAN
> 트랜잭션 내의 정보다).
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
></TD
><TD
>       하나의 WAL 송신 프로세스에 대해서 하나의 로우로,
       대기 서버 쪽으로 보내는 리플리케이션 작업에 대한 통계 정보를
       보여준다. 
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
></TD
><TD
>       하나의 데이터베이스에서 그 전역에 걸쳐 발생한 대기 서버
       복제 작업 충돌에 의한 쿼리 실행 실패 통계 정보를 각각 하나의
       로우로 보여준다. 
      </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   인덱스 별 통계 정보는 어느 인덱스가 많이 사용되며,
   어떻게 영향을 미치는 지를 조사하는데 특히 유용하게 쓰인다.
  </P
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_</TT
> 뷰들은 공유 버퍼의
   사용 빈도를 파악하는데 가장 기본이 되는 것들이다.
   이상적인 서버 운영 모습은 
   디스크 읽기 빈도 보다 공유 버퍼를 사용하는(buffer hit)
   빈도가 훨씬 높아서, 
   대부분의 작업이 커널 호출 작업 없이 이루어지도록 
   하는 것이다.  한편, <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>
   에서는 단지 이 서버 기준으로 디스크를 읽은 것과
   서버의 공유 버퍼를 사용한 것에 대한 정보만 제공할 뿐이다.  
   즉, 커널의 I/O 캐시 사용 빈도에 대해서는 
   제공하지 않는다.  다시 말하면, 
   정말 디스크를 읽은 것인지, OS의 I/O 캐시를 사용한 
   것인지는 이 뷰를 통해서는 알 수 없다.
   이런 세세한 부분까지 살펴 보려면 
   OS 관련 도구들을 이용해야 할 것이다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ACTIVITY-VIEW"
></A
><P
><B
>표 11-2. <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>이 백엔드가 연결된 데이터베이스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 백엔드가 연결된 데이터베이스의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>이 백엔드의 프로세스 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usesysid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>이 백엔드에 로그인 한 사용자의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usename</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 백엔드에 로그인 한 사용자의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>application_name</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>이 백엔드에 연결된 애플리케이션의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>이 백엔드에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 서버 머신의 UNIX 소켓으로 연결이 되어 있다는 뜻이거나 autovacuum같은 내부 프로세스라는 뜻임
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_hostname</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 이 필드는 IP 연결했을 때와 log-hostname이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_port</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>이 백엔드와 교류하는 데 클라이언트가 쓰는 TCP 포트 넘버. <TT
CLASS="LITERAL"
>-1</TT
>은 UNIX 소켓이 사용됐을 때
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>이 프로세스가 시작된 시간. 예를 들어 클라이언트가 서버에 연결되었을 때
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>이 프로세스의 현재 트랜잭션이 시작된 시간이거나 어떤 트랜잭션도 수행되고 있지 않을 때 null로 표시함 
      현재 쿼리가 트랜잭션의 첫 번째 쿼리이면 이 칼럼은 <TT
CLASS="STRUCTFIELD"
>query_start</TT
> 칼럼과 같다.
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>query_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>현재 수행 중인 쿼리가 시작된 시간이거나 
      <TT
CLASS="STRUCTFIELD"
>state</TT
>가 <TT
CLASS="LITERAL"
>active</TT
>가 아닐 때에는 마지막 쿼리가 시작된 시간을 뜻함
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state_change</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
>가 마지막으로 변경된 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>waiting</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>이 백엔드가 잠금을 기다리고 있으면 true</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>현재 이 백엔드의 전체 상태. 가능한 값들은 아래와 같다.
       <P
></P
><UL
><LI
><P
>           <TT
CLASS="LITERAL"
>active</TT
>: 백엔드가 쿼리를 수행하고 있다는 뜻
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle</TT
>: 백엔드가 새로운 클라이언트 명령어를 기다리고 있음을 나타냄
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle in transaction</TT
>: 백엔드가 트랜잭션을 수행하고 있지만 쿼리를 수행하고 있지는 않은 상태
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle in transaction (aborted)</TT
>: <TT
CLASS="LITERAL"
>idle in transaction</TT
>과 비슷하지만 트랜잭션의 구문들 중 하나가 에러를 발생시켰을 때
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>fastpath function call</TT
>: 백엔드가 fast-path함수를 수행할 때
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>disabled</TT
>: track-activities가 이 백엔드에서 비활성화됐을 때 
          </P
></LI
></UL
>
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>query</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>이 백엔드의 가장 최근 쿼리 내 텍스트. <TT
CLASS="STRUCTFIELD"
>state</TT
>가 <TT
CLASS="LITERAL"
>active</TT
>이면 이 필드는 현재 수행 중인 쿼리를 보여 줌. 다른 state들에서는 마지막으로 수행된 쿼리를 보여 줌
     </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> 뷰는 서버 프로세스당 한 개의 로우를 가지며 이는 해당 프로세스의 현재 활동 관련 정보를 보여준다.
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>    <TT
CLASS="STRUCTFIELD"
>waiting</TT
>과 <TT
CLASS="STRUCTFIELD"
>state</TT
>칼럼은 독립적이다. 
    백엔드가 <TT
CLASS="LITERAL"
>active</TT
> 상태이면,
    <TT
CLASS="LITERAL"
>waiting</TT
>일 수도 있고 아닐 수도 있다. 상태가
    <TT
CLASS="LITERAL"
>active</TT
>이고 <TT
CLASS="STRUCTFIELD"
>waiting</TT
>이 true면, 쿼리가 수행 중임을 뜻하지만 시스템 어딘가에서 잠금으로 블록 됐음을 뜻한다.
   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ARCHIVER-VIEW"
></A
><P
><B
>표 11-3. <TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>archived_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>성공적으로 아카이브 된 WAL 파일의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_archived_wal</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>최근 성공적으로 아카이브 된 WAL 파일의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_archived_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>최근 성공적으로 아카이브 작업을 한 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>failed_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>WAL 파일 아카이빙 시도에 실패한 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_failed_wal</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>마지막으로 아카이빙 작업에 실패한 WAL 파일의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_failed_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>마지막으로 아카이빙 작업에 실패한 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>이 통계치가 마지막으로 리셋된 시간</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
> 뷰는 클러스터의 아카이버 프로세스에 관한 데이터가 있는 하나의 로우만 갖고 있다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-BGWRITER-VIEW"
></A
><P
><B
>표 11-4. <TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
> 뷰</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoints_timed</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>checkpoint_timeout 환경 설정값에 따른 체크 포인트 작업 회수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoints_req</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>체크포인트 명령이 수행되어 진행한 작업 회수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoint_write_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>        체크포인트 작업으로 발생한 디스크 쓰기 작업의 밀리세컨드 총 시간. 
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoint_sync_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>        체크포인트 작업으로 발생할 디스크 쓰기에
        대한 디스크 동기화 작업(fsync)에 소요된 밀리세컨드 총 시간. 
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_checkpoint</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>checkpointer 프로세스가 기록한 총 버퍼 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_clean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>writer 프로세스가 기록한 총 버퍼 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>maxwritten_clean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>writer 프로세스가 기록해야 할 버퍼수가
       bgwriter_lru_maxpages 환경 설정값보다 많아서 작업이 중지된 회수
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_backend</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>백엔드(세션) 프로세스가 직접 기록한 총 버퍼 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_backend_fsync</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>백엔드(세션) 프로세스가 직접 <CODE
CLASS="FUNCTION"
>fsync</CODE
> 작업을
       한 회수 (일반적으로 백엔드(세션) 프로세스가 공유 버퍼를 디스크로
       내려 쓰더라도, 이 동기화 작업은 writer 프로세스가 담당한다.
       즉 writer 프로세스의 fsync 작업 부하량을 파악하는데 도움이 됨)
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_alloc</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>Number of buffers allocated</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>이 통계값들이 초기화 된 시각</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
> 뷰는 항상 한 개의 로우만
   보여준다. 이 자료는 데이터클러스터 전역 정보다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-DATABASE-VIEW"
></A
><P
><B
>표 11-5. <TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>데이터베이스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>해당 데이터베이스의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>numbackends</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>현재 연결된 백엔드의 수.
현재 상태를 가리키는 값을 리턴 하는 유일한 칼럼. 다른 칼럼들은 마지막 리셋 시점 이후로 축적된 값들을 리턴함.</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_commit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>커밋된 트랜잭션의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_rollback</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>롤백한 트랜잭션의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>읽힌 디스크 블록의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>버퍼 캐쉬에 이미 존재하는 디스크 블록을 감지하여 읽기가 불필요함을 알려줌. (Agens SQL 버퍼 캐쉬 내 히트 수만 계산하고, 운영체제 파일 시스템 캐쉬는 확인하지 않음)
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_returned</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리가 리턴한 로우의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_fetched</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리가 fetch한 로우의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_inserted</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리로 삽입된 로우의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_updated</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리로 업데이트된 로우의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_deleted</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리로 삭제된 로우의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>conflicts</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>복구 충돌로 인해 취소된 쿼리의 개수 (대기 서버에서만 발생하는 충돌을 말함. 
      pg-stat-database-conflicts-view 참조)
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>temp_files</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리로 생성된 임시 파일의 개수. 모든 임시 파일은 임시 파일이 생성된 이유와 
      log-temp-files 설정을 불문하고 카운트 됨
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>temp_bytes</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>쿼리로 임시 파일에 쓰여진 데이터의 총합. 모든 임시 파일은 임시 파일이 생성된 이유와 log-temp-files 설정을 불문하고 카운트 됨
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>deadlocks</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>감지된 교착상태의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blk_read_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>백엔드가 데이터 파일 블록을 읽는 데 소요된 시간으로 밀리세컨드 단위를 사용</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blk_write_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>백엔드가 데이터 파일 블록을 쓰는데 소요된 시간으로 밀리세컨드 단위를 사용</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>통계치가 마지막으로 리셋된 시간</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
> 뷰는 클러스터 내 데이터베이스 당 한 개의 로우를 가지며 전체 데이터베이스 통계치를 보여준다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ALL-TABLES-VIEW"
></A
><P
><B
>표 11-6. <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>테이블의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>테이블을 포함하는 스키마 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>테이블명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>seq_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>풀스캔을 시도한 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>seq_tup_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>풀스캔으로 가져온 live row 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>인덱스 스캔을 시도한 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>인덱스 스캔으로 가져온 live row 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_ins</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>삽입된 로우 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_upd</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>업데이트된 로우 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_del</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>삭제된 로우 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_hot_upd</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>HOT 업데이트 된 로우 개수 (예를 들어 따로 인덱스 업데이트 필요가 없는)</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_live_tup</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>추정되는 live row 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_dead_tup</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>추정되는 dead row 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_vacuum</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>테이블이 수동적으로 vacuum된 마지막 시간 
      (<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>은 해당되지 않음)</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_autovacuum</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>autovacuum 데몬으로 테이블이 vacuum된 마지막 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_analyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>테이블이 수동적으로 분석된 마지막 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_autoanalyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>autovacuum 데몬으로 테이블이 분석된 마지막 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>vacuum_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>수동적으로 vacuum된 횟수 
      (<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>은 제외)</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>autovacuum_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>autovacuum 데몬으로 vacuum된 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>analyze_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>수동적으로 분석된 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>autoanalyze_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>autovacuum 데몬으로 분석된 횟수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
> 뷰는 현재 데이터베이스의 테이블(TOAST 테이블 포함)당 한 개의 로우를 가지며, 이는 해당 테이블 접근에 대한 통계치를 보여준다. <TT
CLASS="STRUCTNAME"
>pg_stat_user_tables</TT
>와
   <TT
CLASS="STRUCTNAME"
>pg_stat_sys_tables</TT
>뷰는 같은 정보를 가지나 사용자와 시스템 테이블 각각을 보여주는 데만 쓰인다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ALL-INDEXES-VIEW"
></A
><P
><B
>표 11-7. <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>이 인덱스를 갖는 테이블의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>이 인덱스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 인덱스가 있는 스키마의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 인덱스를 갖는 테이블명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>인덱스명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이 인덱스로 스캔한 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이 인덱스로 스캔해서 리턴된 인덱스 엔트리의 개수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이 인덱스로 인덱스 스캔해서 가져온 live 테이블 로우의 개수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
> 뷰는 현재 데이터베이스에서 인덱스 당 한 개의 로우를 가지며 해당 인덱스 접근에 대한 통계치를 보여준다. 
   <TT
CLASS="STRUCTNAME"
>pg_stat_user_indexes</TT
>와 
   <TT
CLASS="STRUCTNAME"
>pg_stat_sys_indexes</TT
> 뷰는 같은 정보를 갖지만 각각 사용자와 시스템 인덱스만 보여준다. 
  </P
><P
>   인덱스는 일반 인덱스 스캔 혹은 <SPAN
CLASS="QUOTE"
>"bitmap"</SPAN
>
   인덱스 스캔을 사용할 수 있다. 비트맵 스캔에서 일부 인덱스 결과는 AND나 OR 규칙으로 통합될 수 있어서, 비트맵 스캔이 사용되면 각각의 heap 로우들을 특정 인덱스에 매칭하기 어렵다. 
   비트맵 스캔은 사용된 인덱스의 
   <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>
  를 증가시키고, 테이블의 
   <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>
   를 증가시키지만 
   <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>에는 영향을 미치지 않는다.
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>    <TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>와 <TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>의 값은 비트맵 스캔을 하지 않아도 다를 수 있다. 
    <TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>는 인덱스에서 회수된 인덱스 엔트리 개수를 세지만, <TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>
    는 테이블에서 가져온 live row를 세기 때문이다. 후자는 죽었거나 아직 커밋되지 않은 로우가 fetch되어 인덱스를 사용할 경우나 index-only 스캔으로 heap fetch들을 감지하지 못한 경우 감소한다.
   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-TABLES-VIEW"
></A
><P
><B
>표 11-8. <TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>테이블의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 테이블이 속한 스키마 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>이 테이블의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>heap_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이 테이블에서 읽힌 디스크 블록의 수 </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>heap_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이 테이블 내 버퍼 히트 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>테이블의 전체 인덱스에서 읽힌 디스크 블록의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>테이블 내 모든 인덱스에 대한 버퍼 히트의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>toast_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>TOAST 테이블(있으면)에서 읽힌 디스크 블록의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>toast_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>TOAST 테이블(있으면) 내 버퍼 히트 수 </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tidx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>TOAST 테이블 인덱스(있으면)에서 읽힌 디스크 블록 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tidx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>TOAST 테이블 인덱스(있으면) 내 버퍼 히트 수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
> 뷰는 현재 데이터베이스에서 각 테이블당(TOAST 테이블을 포함해서) 한 개의 로우를 갖는데, 해당 테이블의 I/O에 대한 통계치를 보여준다. 
   <TT
CLASS="STRUCTNAME"
>pg_statio_user_tables</TT
>와 
   <TT
CLASS="STRUCTNAME"
>pg_statio_sys_tables</TT
> 뷰도 같은 정보를 갖지만 각기 사용자와 시스템 테이블만 보여준다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-INDEXES-VIEW"
></A
><P
><B
>표 11-9. <TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>인덱스가 포함된 테이블의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>인덱스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>인덱스가 포함된 스키마의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>인덱스가 포함된 테이블의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>인덱스명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>인덱스로 읽힌 디스크 블록의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>인덱스 내 버퍼 히트 수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
>뷰는 현재 데이터베이스의 각 인덱스당 하나의 로우를 갖는데, 해당 인덱스의 I/O에 대한 통계치를 보여준다. 
   <TT
CLASS="STRUCTNAME"
>pg_statio_user_indexes</TT
>와 
   <TT
CLASS="STRUCTNAME"
>pg_statio_sys_indexes</TT
> 뷰도 같은 정보를 갖지만 사용자와 시스템 인덱스만 각각 보여준다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-SEQUENCES-VIEW"
></A
><P
><B
>표 11-10. <TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>시퀀스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>시퀀스가 포함된 스키마명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>시퀀스명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>시퀀스에서 읽힌 디스크 블록의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>시퀀스 내 버퍼 히트 수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
> 뷰는 현재 데이터베이스의 각 시퀀스당 한 개의 로우를 갖고, 해당 시퀀스의 I/O에 대한 통계치를 보여준다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-USER-FUNCTIONS-VIEW"
></A
><P
><B
>표 11-11. <TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>funcid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>함수의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>함수가 포함된 스키마명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>funcname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>함수명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>calls</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>함수가 호출된 횟수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>total_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>함수와 호출된 함수들에 소요된 밀리세컨드 총 시간</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>self_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>호출된 함수들을 제외하고 이 함수에 소요된 밀리세컨드 총 시간</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
> 뷰는 추적된 각 함수당 한 개의 로우를 가지며, 함수 수행에 대한 통계치를 보여 준다. 
   track-functions는 정확히 어떤 함수가 추적되어야 하는지 정한다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-REPLICATION-VIEW"
></A
><P
><B
>표 11-12. <TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>WAL 송신 프로세스의 프로세스 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usesysid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>WAL 송신 프로세스에 로그인 된 사용자의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usename</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>WAL 송신 프로세스에 로그인 된 사용자의 이름</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>application_name</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>WAL 송신 프로세스에 연결된 애플리케이션명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>WAL 송신자에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 서버 머신의 UNIX 소켓으로 연결되었음을 의미함
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_hostname</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 
     이 필드는 IP로 연결했을 때와 log-hostname이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_port</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>클라이언트가 WAL 송신자와 커뮤니케이션 하기 위해 쓰는 TCP 포트 넘버. <TT
CLASS="LITERAL"
>-1</TT
> 이면 유닉스 소켓이 사용됐을 때
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>이 프로세스가 시작된 시간. 예를 들어 WAL 송신자와 클라이언트가 연결된 시간
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>현재 WAL 송신자 상태</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sent_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>이 연결에 전송된 마지막 트랜잭션 로그 위치</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>write_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>대기 서버가 디스크에 쓴 마지막 트랜잭션 로그 위치</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>flush_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>대기 서버가 디스크로 내린 마지막 트랜잭션 로그 위치</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>replay_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>대기 서버에 있는 데이터베이스로 리플레이 된 마지막 트랜잭션 로그 위치</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sync_priority</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>동기적인 대기 서버로 선택된 대기 서버의 우선순위</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sync_state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>대기 서버의 동기적 상태</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
>뷰는 WAL 송신자 프로세스당 하나의 로우를 가지며, 송신자가 연결된 대기 서버의 리플리케이션에 관한 통계치를 보여준다. 
   직접 연결된 대기 서버만 보여진다. 다운스트림 대기 서버에 관한 정보는 없다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-DATABASE-CONFLICTS-VIEW"
></A
><P
><B
>표 11-13. <TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
> View</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>칼럼</TH
><TH
>자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>데이터베이스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>데이터베이스명</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_tablespace</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>드롭된 테이블스페이스로 인해 취소된 쿼리의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_lock</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>잠금 시간초과로 취소된 쿼리의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_snapshot</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>이전 스냅샷으로 취소된 쿼리의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_bufferpin</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>고정된 버퍼로 취소된 쿼리의 수</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_deadlock</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>교착상태로 취소된 쿼리의 수</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
> 뷰는 데이터베이스당 하나의 로우를 가지며, 대기 서버의 복구 충돌로 인해 발생한 쿼리 취소에 대해 전체 데이터베이스 통계치를 보여준다. 
   마스터 서버에서 충돌이 발생하지 않으므로 이 뷰는 대기 서버의 정보만 갖고 있다. 
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-FUNCTIONS"
>11.2.3. 통계 함수들</A
></H2
><P
>   위에서 소개한 뷰를 통해서 서버 통계 정보를 살펴보는 방법과
   함께 또 다른 한 방법은 각각의 정보를 제공하는 
   함수를 사용하는 방법이다.  위에서 
   소개한 뷰들의 뷰 정의를 살펴보면, 
   각각의 뷰가 어떤 함수들을 사용하는지 알 수 있다.
   (예를 들면, <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 에서
    <TT
CLASS="LITERAL"
>\d+ pg_stat_activity</TT
> 명령을 사용하면 된다.)
   데이터베이스 단위로 통계 정보를 보여주는 
   함수들에 대해서는 함수의 입력 인자로 데이터베이스 OID를 
   입력해야 한다.  
   이처럼 테이블별, 인덱스별,
   함수별 통계 정보를 살펴보려면
   각 객체의 OID를 입력 인자로 사용하면 된다.
   기억해야 할 점은 테이블, 인덱스, 함수 같은 각 데이터베이스
   소속 객체들을 입력 인자로 쓰는 함수면 
   그 데이터베이스는 현재 접속한 데이터베이스가 된다.
  </P
><P
>   부가적으로 제공하는 통계 관련 함수들은 <A
HREF="monitoring-stats.html#MONITORING-STATS-FUNCS-TABLE"
>표 11-14</A
>에서 소개한다.
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-FUNCS-TABLE"
></A
><P
><B
>표 11-14. 부가 통계 함수들</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>함수이름</TH
><TH
>리턴 자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_backend_pid()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>       현재 세션을 처리하는 서버 프로세스의 프로세스 ID
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_activity</CODE
>(<TT
CLASS="TYPE"
>integer</TT
>)</TT
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>       특정 PID를 갖는 백엔드 정보를 담은 레코드를 리턴하거나 인자가 <TT
CLASS="SYMBOL"
>NULL</TT
>일 경우에는 시스템에서 활성화된 각 백엔드의 레코드를 리턴함. 리턴된 필드는 
       <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> 뷰의 부분집합
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_clear_snapshot()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       현재 통계치 스냅샷을 버림
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       현재 데이터베이스의 통계치 카운터 전체를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_shared</CODE
>(text)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       인자에 따라서 전체 클러스터 통계치 카운터를 0으로 만듦(슈퍼 유저 권한이 필요함) 
       <TT
CLASS="LITERAL"
>pg_stat_reset_shared('bgwriter')</TT
>를 호출하면 
       <TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
>뷰에 보여진 전체 카운터들을 0으로 만듦
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_single_table_counters</CODE
>(oid)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       현재 데이터베이스의 한 테이블 혹은 인덱스에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_single_function_counters</CODE
>(oid)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       현재 데이터베이스의 한 함수에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> 뷰에서 사용되는
   <CODE
CLASS="FUNCTION"
>pg_stat_get_activity</CODE
> 함수는
   지정한 한 세션의 현재 상태에 대한 모든 정보를 
   레코드 자료형으로 리턴한다. 
   이렇게 가끔은 뷰보다 함수를 직접 사용하는 것이 
   보다 유용할 때가 있다.  위에서 소개한 뷰들(<A
HREF="monitoring-stats.html#MONITORING-STATS-BACKEND-FUNCS-TABLE"
>표 11-15</A
>)은 
   함수를 호출하고 그것을 뷰로 보여주기 때문에 
   뷰를 내용으로 출력 되는 결과는 이미 지난 자료 집합이다
   보다 정확한 현재 상태를 파악 하고자 할 때 
   이런 함수를 직접 사용하는 방법이 좋다. 
   한 예제를 소개하면,
   다음은, 현재 접속해 있는 세션들의 <ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>와
   현재 실행 중인 쿼리 내용을 보는 쿼리다:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</PRE
><P>
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-BACKEND-FUNCS-TABLE"
></A
><P
><B
>표 11-15. 백엔드 단위 통계 함수들</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>함수이름</TH
><TH
>리턴 자료형</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_idset()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof integer</TT
></TD
><TD
>현재 활성화된 백엔드 ID 넘버 집합(1부터 활성화된 백엔드 개수까지)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_activity(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>백엔드의 최근 쿼리의 텍스트</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_activity_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>최근 쿼리가 시작된 시간</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_client_addr(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>백엔드에 연결된 클라이언트의 IP 주소</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_client_port(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>클라이언트가 커뮤니케이션에 쓰고 있는 TCP 포트 넘버</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_dbid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>백엔드가 연결된 데이터베이스의 OID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_pid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>백엔드의 프로세스 ID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>프로세스가 시작된 시간</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_userid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>백엔드에 로그인한 사용자의 OID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_waiting(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>백엔드가 현재 잠금을 기다리고 있는 경우엔 true</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_xact_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>현재 트랜잭션이 시작된 시간</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring-ps.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="monitoring-locks.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>표준 유닉스 도구들</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>잠금 보기</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>