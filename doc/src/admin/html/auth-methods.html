<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>인증 방법</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="클라이언트 인증"
HREF="client-authentication.html"><LINK
REL="PREVIOUS"
TITLE="사용자 이름 맵"
HREF="auth-username-maps.html"><LINK
REL="NEXT"
TITLE="인증 문제"
HREF="client-authentication-problems.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T09:12:38"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="사용자 이름 맵"
HREF="auth-username-maps.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 3. 클라이언트 인증</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="인증 문제"
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AUTH-METHODS"
>3.3. 인증 방법</A
></H1
><P
> 아래 절에서는 인증 방법을 자세하게 다룬다.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-TRUST"
>3.3.1. 트러스트 인증</A
></H2
><P
><TT
CLASS="LITERAL"
>trust</TT
> 인증이 지정된 경우 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>는 지정한 데이터베이스 사용자 이름을 사용하여 
서버에 연결 가능한 모든 이가 데이터베이스 액세스에 대한 인증을 받는 것으로 간주한다(수퍼유저 이름 포함). 
물론, <TT
CLASS="LITERAL"
>database</TT
> 및 <TT
CLASS="LITERAL"
>user</TT
> 칼럼의 제한도 계속 적용된다. 
이 방법은 서버 연결에 대한 적절한 운영 체제 수준의 보호가 제공되는 경우에만 사용되어야 한다.
 </P
><P
><TT
CLASS="LITERAL"
>trust</TT
> 인증은 단일 사용자 워크스테이션에 대한 로컬 연결 시 적절하며, 매우 편리하다. 다중 사용자 머신에서는 일반적으로 적절하지 
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>않다</I
></SPAN
>. 
그러나, 파일 시스템 권한을 사용하여 서버의 Unix 도메인 소켓 파일에 대한 액세스를 제한하는 경우 다중 사용자 머신에서도 
<TT
CLASS="LITERAL"
>trust</TT
>를 사용 가능할 수 있다. 
이렇게 하려면 <TT
CLASS="VARNAME"
>unix_socket_permissions</TT
>(및 가능하면 <TT
CLASS="VARNAME"
>unix_socket_group</TT
>) 환경 설정 매개 변수를 
<A
HREF="runtime-config-connection.html"
>2.3절</A
>에서 설명한 대로 설정해야 한다. 
또는 <TT
CLASS="VARNAME"
>unix_socket_directories</TT
> 환경 설정 매개 변수를 설정하여 소켓 파일을 적절히 제한된 디렉토리에 배치할 수 있다.
 </P
><P
>파일 시스템 권한 설정은 Unix 소켓 연결 시에만 유용하다. 로컬 TCP/IP 연결은 파일 시스템 권한에 의해 제한되지 않는다. 
따라서 로컬 보안을 위해 파일 시스템 권한을 사용하려면 <TT
CLASS="LITERAL"
>host ... 127.0.0.1 ...</TT
> 줄을 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>에서 삭제하거나, 
비 <TT
CLASS="LITERAL"
>trust</TT
> 방법으로 변경해야 한다.
 </P
><P
><TT
CLASS="LITERAL"
>trust</TT
> 인증은 <TT
CLASS="LITERAL"
>trust</TT
>를 지정하는 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>에서 서버와 연결이 허용된 모든 머신의 모든 사용자를 
신뢰하는 경우에만 TCP/IP 연결에 적합하다.
<SPAN
CLASS="SYSTEMITEM"
>localhost</SPAN
>(127.0.0.1) 외에 TCP/IP 연결 시 <TT
CLASS="LITERAL"
>trust</TT
>를 사용하는 것은 별로 합당하지 않다.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PASSWORD"
>3.3.2. 패스워드 인증</A
></H2
><P
>패스워드 기반 인증 방법은 <TT
CLASS="LITERAL"
>md5</TT
> 및 <TT
CLASS="LITERAL"
>password</TT
>이다. 패스워드가 전송될 때 각각 MD5 해시 및 일반 텍스트로 전송되는 점을 
제외하고 두 방법은 유사하게 작동된다.
 </P
><P
>패스워드 <SPAN
CLASS="QUOTE"
>"스니핑"</SPAN
> 공격을 주의하는 경우 <TT
CLASS="LITERAL"
>md5</TT
>가 바람직하다. 일반 <TT
CLASS="LITERAL"
>password</TT
>는 가능하면 피해야 한다. 
대신, <TT
CLASS="LITERAL"
>md5</TT
>는 db_user_namespace<A
HREF="runtime-config-connection.html#GUC-DB-USER-NAMESPACE"
>db_user_namespace</A
> 기능과 함께 사용할 수 없다. 
연결이 SSL 암호화로 보호되는 경우 <TT
CLASS="LITERAL"
>password</TT
>를 안전하게 사용할 수 있다(SSL을 사용하는 경우 SSL 인증서 인증이 더 나을 수 있지만).
 </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 데이터베이스 패스워드는 운영 체제 사용자 패스워드와 구분된다. 
각 데이터베이스 사용자에 대한 패스워드는 <TT
CLASS="LITERAL"
>pg_authid</TT
> 시스템 카탈로그에 저장된다. 
패스워드는 SQL 명령 CREATE USER 및 ALTER ROLE으로 관리할 수 있으며, 
예를 들면 <KBD
CLASS="USERINPUT"
>CREATE USER foo WITH PASSWORD 'secret'</KBD
>와 같다. 
패스워드가 사용자에 대해 설정되지 않은 경우 저장된 패스워드는 null이고 패스워드 인증은 해당 사용자에 대해 항상 실패한다.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GSSAPI-AUTH"
>3.3.3. GSSAPI 인증</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>는 RFC 2743에 정의된 보안 인증을 위한 산업 표준 프로토콜이다. 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 RFC 1964에 따라 <SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>를 사용한 <SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>를 지원한다. 
<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>은 이것을 지원하는 시스템에 대해 자동 인증(single sign-on)을 제공한다. 
인증 자체는 안전하지만, <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>을 사용하지 않을 경우 데이터베이스 연결을 통해 전송된 데이터는 암호화되지 않은 상태로 전송된다.
 </P
><P
>GSSAPI는 Agens SQL이 빌드된 경우 활성화되어야 한다. 
 </P
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>가 <SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>를 사용하는 경우 
<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>servicename</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>@<TT
CLASS="REPLACEABLE"
><I
>realm</I
></TT
></TT
> 형식으로 표준 규칙이 사용된다. 
Agens SQL 서버가 서버에서 사용되는 키탭에 포함된 보안 규칙을 수용하지만, <TT
CLASS="LITERAL"
>krbsrvname</TT
> 연결 매개 변수를 사용하여 
클라이언트에서 연결을 할 때 올바른 보안 규칙 상세 정보를 지정할 때 특별히 주의해야 한다. 
설치 기본값은 빌드 시에 <TT
CLASS="LITERAL"
>./configure --with-krb-srvnam=</TT
><TT
CLASS="REPLACEABLE"
><I
>whatever</I
></TT
>를 사용하여 기본값 
<TT
CLASS="LITERAL"
>postgres</TT
>에서 변경 가능하다. 
대부분의 환경에서 이 매개 변수는 절대 변경할 필요가 없다. 일부 Kerberos 구현은 서비스 이름이 대문자여야 하는 
Microsoft Active Directory처럼 서로 다른 서비스 이름을 요구할 수도 있다(<TT
CLASS="LITERAL"
>POSTGRES</TT
>).
 </P
><P
><TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>은 서버 머신의 정규화된 호스트 이름이다. 
서비스 보안 규칙의 영역은 서버 머신의 기본 설정된 영역이다.
 </P
><P
>클라이언트 보안 규칙은 첫 번째 구성요소로 자체 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 데이터베이스 사용자 이름을 갖는다(예:<TT
CLASS="LITERAL"
>pgusername@realm</TT
>). 
또는, 보안 규칙 이름의 첫 번째 구성요소부터 데이터베이스 사용자 이름까지 맵핑을 위해 사용자 이름 맵핑을 사용할 수도 있다. 
기본적으로 클라이언트의 영역(realm)은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 검사되지 않는다. 
영역 간 인증(cross-realm authentication)을 활성화하고 영역(realm)을 검증해야 하는 경우 <TT
CLASS="LITERAL"
>krb_realm</TT
> 매개 변수를 사용하거나 
<TT
CLASS="LITERAL"
>include_realm</TT
>을 활성화하고 사용자 이름 맵핑을 사용하여 영역(realm)을 검사해야 한다.
 </P
><P
>사용자는 서버 키탭 파일을 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버 계정으로 판독 가능한지(기본적으로 판독만 가능한지) 확인해야 한다. 
S키 파일의 위치는 krb_server_keyfile 환경 설정 매개 변수에 의해 지정된다. 
기본값은 <TT
CLASS="FILENAME"
>/usr/local/pgsql/etc/krb5.keytab</TT
>(또는 빌드 시 <TT
CLASS="VARNAME"
>sysconfdir</TT
>로 지정된 아무 디렉토리). 
보안상의 이유로, 시스템 키탭 파일에 대한 권한을 여는 것보다는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버에 대해 별개의 키탭을 사용하는 것이 바람직하다.
 </P
><P
>키탭 파일은 Kerberos 소프트웨어에 의해 생성된다. 자세한 내용은 Kerberos 문서를 참조 바란다. 다음 예시는 MIT 호환 Kerberos 5 구현에 대한 것이다.
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ank -randkey postgres/server.my.domain.org</KBD
>
<SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ktadd -k krb5.keytab postgres/server.my.domain.org</KBD
></PRE
><P>
 </P
><P
>데이터베이스에 연결할 때 요청된 데이터베이스 사용자 이름과 일치하는 보안 규칙에 대한 티켓이 있는지 확인해야 한다. 
예를 들면, 데이터베이스 이름 <TT
CLASS="LITERAL"
>fred</TT
>의 경우 보안 규칙 <TT
CLASS="LITERAL"
>fred@EXAMPLE.COM</TT
>은 연결이 가능하다. 
보안 규칙 <TT
CLASS="LITERAL"
>fred/users.example.com@EXAMPLE.COM</TT
>의 연결도 허용하려면 <A
HREF="auth-username-maps.html"
>3.2절</A
>에 설명된 대로 사용자 이름 맵을 사용해야 한다.
 </P
><P
>다음 환경 설정 옵션이 <SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
>1로 설정되면 인증된 사용자 보안 규칙의 영역 이름이 사용자 이름 맵핑을 통해 전달되는 시스템 사용자 이름에 포함된다(<A
HREF="auth-username-maps.html"
>3.2절</A
>). 이것은 복수의 영역(realm)에서 사용자를 처리할 때 유용하다. 
기본값은 0이지만(시스템 사용자 이름의 영역에 포함되지 않음을 뜻함), 향후 Agens SQL 버전에서는 1로 바뀔 수도 있다. 사용자는 업그레이드할 때 이슈를 피하기 위해 0을 명시적으로 설정할 수 있다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>시스템과 데이터베이스 사용자 이름 사이의 맵핑을 허용한다. 자세한 내용은 <A
HREF="auth-username-maps.html"
>3.2절</A
>을 참조 바란다. 
Kerberos 보안 규칙 <TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>의 경우 맵핑에 사용된 사용자 이름은 
<TT
CLASS="LITERAL"
>include_realm</TT
>이 비활성화됐을 시에 <TT
CLASS="LITERAL"
>username/hostbased</TT
>이고, 
<TT
CLASS="LITERAL"
>include_realm</TT
>이 활성화됐을 시에 <TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>이다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>사용자 보안 규칙 이름과 일치하는 영역(realm)을 설정한다. 이 매개 변수가 설정된 경우 해당 영역(realm)의 사용자만 허용된다. 
설정되지 않으면 모든 영역(realm)의 사용자가 연결할 수 있으며, 사용자 이름 맵핑 완료 여부에 달려 있다.
 </P
></DD
></DL
></DIV
><P>
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SSPI-AUTH"
>3.3.4. SSPI 인증</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>는 단일 사인온(sign-on)의 보안 인증을 위한 <SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
> 기술이다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 <TT
CLASS="LITERAL"
>negotiate</TT
>모드에서 SSPI를 사용한다. 
이것은 가능한 경우 <SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>를 사용하고, 그 외에는 <SPAN
CLASS="PRODUCTNAME"
>NTLM</SPAN
>으로 자동 폴백(fall back)된다. 
<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
> 인증은 서버와 클라이언트가 모두 <SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>를 사용하는 경우에만 작동되고, <SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>를 사용할 수 있는 경우에는 비 Windows에서 작동된다.
 </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
> 인증 사용 중에는 <SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>가 <SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>와 동일한 방식으로 작동된다. 
자세한 내용은 <A
HREF="auth-methods.html#GSSAPI-AUTH"
>3.3.3절</A
>을 참조 바란다.
 </P
><P
>다음 환경 설정 옵션이 <SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
>1로 설정되면 인증된 사용자 보안 규칙의 영역(realm) 이름이 사용자 이름 맵핑을 통해 전달되는 시스템 사용자 이름에 포함된다(<A
HREF="auth-username-maps.html"
>3.2절</A
>). 이것은 복수의 영역(realm)에서 사용자를 처리할 때 유용하다.
기본값은 0이지만(시스템 사용자 이름의 영역에 포함되지 않음을 뜻함), 향후 Agens SQL 버전에서는 1로 바뀔 수도 있다. 사용자는 업그레이드할 때 이슈를 피하기 위해 0을 명시적으로 설정할 수 있다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>시스템과 데이터베이스 사용자 이름 사이의 맵핑을 허용한다. 자세한 내용은 <A
HREF="auth-username-maps.html"
>3.2절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>사용자 보안 규칙 이름과 일치하는 영역(realm)을 설정한다. 이 매개 변수가 설정된 경우 해당 영역(realm)의 사용자만 허용된다. 
설정되지 않으면 모든 영역(realm)의 사용자가 연결할 수 있으며, 영역은 사용자 이름 맵핑 완료 여부에 달려 있다.
 </P
></DD
></DL
></DIV
><P>
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-IDENT"
>3.3.5. Ident 인증</A
></H2
><P
>ident 인증 방법은 클라이언트의 운영 체제 사용자 이름을 ident 서버로부터 획득하고, 
허용된 데이터베이스 사용자 이름으로 사용함으로써 작동된다(선택적 사용자 이름 맵핑 사용). 이것은 TCP/IP 연결에서만 지원된다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 로컬(비 TCP/IP) 연결에 대해 ident를 지정하는 경우 피어(peer) 인증이 대신 사용된다(<A
HREF="auth-methods.html#AUTH-PEER"
>3.3.6절</A
> 참조).</P
></BLOCKQUOTE
></DIV
><P
>다음 구성 옵션이 <SPAN
CLASS="PRODUCTNAME"
>ident</SPAN
>에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>시스템과 데이터베이스 사용자 이름 사이의 맵핑을 허용한다. 자세한 내용은 <A
HREF="auth-username-maps.html"
>3.2절</A
>을 참조 바란다.
 </P
></DD
></DL
></DIV
><P>
 </P
><P
><SPAN
CLASS="QUOTE"
>"신분확인 프로토콜(Identification Protocol)"</SPAN
>은 RFC 1413에 설명되어 있다. 실제로 모든 Unix 류의 운영 체제에는 기본적으로 TCP 포트 113에서 listen하는 ident 서버가 내장되어 있다. 
ident 서버의 기본적인 기능은, <SPAN
CLASS="QUOTE"
>"당신의 포트 <TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>에서 출력되어 내 포트 <TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>에 연결되는 연결을 초기화한 사용자는 누구인가?"</SPAN
> 같은 질문에 응답하는 것이다. 
실제 연결이 성립되면 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 <TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>와 <TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>를 모두 알고 있으므로 연결 클라이언트의 호스트에 대한 정보를 ident 서버에서 얻을 수 있으며, 주어진 연결에서 운영 체제 사용자를 판단할 수 있다.
 </P
><P
>이 방법의 단점은 클라이언트의 무결성에 따라 달라진다. 클라이언트 머신을 신뢰할 수 없거나 손상된 경우 공격자(attacker)는 포트 113에서 프로그램을 실행하고, 선택한 사용자 이름으로 리턴할 수 있다. 
따라서 인증 방법은 각 클라이언트 머신이 엄격하게 제어되고, 데이터베이스 및 시스템 관리자의 협력이 긴밀하게 이뤄지는 폐쇄된 네트워크의 경우에만 적합하다. 즉, 사용자는 ident 서버가 실행되는 머신을 신뢰해야 한다. 
다음 경고에 유의해야 한다.
<A
NAME="AEN6065"
></A
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="BLOCKQUOTE"
><TR
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
><TD
VALIGN="TOP"
><P
>신분확인 프로토콜은 인증 또는 액세스 제어 프로토콜로 사용할 수 없다(The Identification Protocol is not intended as an authorization or access control protocol).
 </P
></TD
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="RIGHT"
VALIGN="TOP"
>--<SPAN
CLASS="ATTRIBUTION"
>RFC 1413</SPAN
></TD
><TD
WIDTH="10%"
>&nbsp;</TD
></TR
></TABLE
>
 </P
><P
>일부 ident 서버는 원래 머신의 관리자만 알고 있는 키를 사용하여, 리턴된 사용자 이름을 암호화되도록 하는 비표준 옵션이 있다. 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>는 실제 사용자 이름을 결정하기 위해 리턴된 string의 암호를 해제할 방법이 없으므로 ident 서버에서 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 사용하는 경우에는 이 옵션을 사용해서는 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>안</I
></SPAN
> 된다.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PEER"
>3.3.6. 피어(peer) 인증</A
></H2
><P
>피어(peer) 인증 방법은 클라이언트의 운영 체제 사용자 이름을 커널로부터 획득하고, 허용된 데이터베이스 사용자 이름으로 사용함으로써 작동된다(선택적 사용자 이름 맵핑 사용). 
이 방법은 로컬 연결에만 지원된다.
 </P
><P
>다음 구성 옵션이 <SPAN
CLASS="PRODUCTNAME"
>피어</SPAN
>(<SPAN
CLASS="PRODUCTNAME"
>peer</SPAN
>)에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>시스템과 데이터베이스 사용자 이름 사이의 맵핑을 허용한다. 자세한 내용은 <A
HREF="auth-username-maps.html"
>3.2절</A
>을 참조 바란다.
 </P
></DD
></DL
></DIV
><P>
 </P
><P
>피어(Peer) 인증은 <CODE
CLASS="FUNCTION"
>getpeereid()</CODE
> 함수, <TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
> 소켓 매개 변수 또는 유사 메커니즘이 제공되는 운영 체제에서만 사용할 수 있다. 현재 <SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>가 포함되며, 
<SPAN
CLASS="SYSTEMITEM"
>OS X</SPAN
> 및 <SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
>를 비롯한 <SPAN
CLASS="SYSTEMITEM"
>BSD</SPAN
>가 가장 선호된다.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-LDAP"
>3.3.7. LDAP 인증</A
></H2
><P
>이 인증 방법은 패스워드 검증 방법으로 LDAP를 사용할 때 외에는 <TT
CLASS="LITERAL"
>password</TT
>와 유사하게 작동된다. LDAP는 사용자 이름/패스워드 쌍을 검증할 때에만 사용된다. 
따라서 LDAP를 인증에 사용하기 전에 사용자가 데이터베이스에 존재해야 한다.
 </P
><P
>LDAP 인증은 2가지 모드로 수행할 수 있다. 간단한 바인딩 모드라고 하는 첫 번째 방법은 서버가 <TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>로 구성된 고유한 이름에 바인딩하는 것이다. 
일반적으로 <TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
> 매개 변수는 Active Directory 환경에서 <TT
CLASS="LITERAL"
>cn=</TT
> 또는 <TT
CLASS="REPLACEABLE"
><I
>DOMAIN</I
></TT
><TT
CLASS="LITERAL"
>\</TT
>을 지정하는 데 사용된다. <TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>는 비 Active Directory 환경의 나머지 부분을 지정할 때 사용된다.
 </P
><P
>검색+바인딩 모드라고 하는 두 번째 모드에서 서버는 <TT
CLASS="REPLACEABLE"
><I
>ldapbinddn</I
></TT
> 및 <TT
CLASS="REPLACEABLE"
><I
>ldapbindpasswd</I
></TT
>로 지정 및 고정된 사용자 이름과 패스워드를 사용하여 LDAP 디렉토리에 먼저 바인딩한 다음, 데이터베이스에 로그인하려는 사용자를 검색한다. 
사용자 및 패스워드가 설정되지 않은 경우 디렉토리에 익명으로 바인딩이 시도된다. <TT
CLASS="REPLACEABLE"
><I
>ldapbasedn</I
></TT
>의 서브 트리에서 검색이 수행되고 <TT
CLASS="REPLACEABLE"
><I
>ldapsearchattribute</I
></TT
>와 정확히 일치하는 것을 찾는다. 
이 검색에서 사용자를 찾으면, 서버는 연결을 끊고 로그인이 올바른지 검증하기 위해 클라이언트에서 지정된 패스워드를 사용하여 이 사용자로 디렉토리에 다시 바인딩한다. 
이 모드는 Apache mod_authnz_ldap 및 pam_ldap 같은 다른 소프트웨어의 LDAP 인증 스키마에서 사용되는 것과 동일하다. 이 방법은 사용자 객체들이 디렉토리에 있을 경우 더 유연하게 작용하지만 두 LDAP 서버 연결을 분리시킨다.
 </P
><P
>다음 구성 옵션이 양쪽 모드에 사용된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapserver</TT
></DT
><DD
><P
>연결할 LDAP 서버의 이름 또는 IP 주소. 공백으로 구분된 서버를 여러 개 지정할 수 있다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapport</TT
></DT
><DD
><P
>연결할 LDAP 서버의 포트 번호. 포트가 지정되지 않으면 LDAP 라이브러리의 기본 포트 설정이 사용된다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldaptls</TT
></DT
><DD
><P
>1로 설정하면 TLS 암호화를 사용하여 Agens SQL과 LDAP 서버가 연결된다. 이것은 LDAP 서버로의 트래픽만 암호화한다. 
클라이언트에 대한 연결은 SSL을 사용하지 않는 한 암호화되지 않은 상태가 지속된다.
 </P
></DD
></DL
></DIV
><P>

다음 옵션은 간단 바인딩 모드에만 사용된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapprefix</TT
></DT
><DD
><P
>간단한 바인딩 인증 수행 시 DN 바인딩의 사용자 이름 앞에 추가하는 string.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsuffix</TT
></DT
><DD
><P
>간단한 바인딩 인증 수행 시 DN 바인딩의 사용자 이름 뒤에 추가하는 string.
 </P
></DD
></DL
></DIV
><P>
다음 옵션은 검색+바인딩 모드에만 사용된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapbasedn</TT
></DT
><DD
><P
>검색+바인딩 인증 수행 시 사용자 검색을 시작하는 루트 DN.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbinddn</TT
></DT
><DD
><P
>검색+바인딩 인증 수행 시 검색 수행하기 위해 디렉토리에 바인딩하는 사용자 DN.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbindpasswd</TT
></DT
><DD
><P
>검색+바인딩 인증 수행 시 검색 수행하기 위해 디렉토리에 바인딩하는 사용자의 패스워드.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsearchattribute</TT
></DT
><DD
><P
> 검색+바인딩 인증 수행 시 검색에서 사용자 이름에 대해 일치하는 속성. 속성이 지정되지 않으면 <TT
CLASS="LITERAL"
>uid</TT
> 속성이 사용된다.</P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapurl</TT
></DT
><DD
><P
> RFC 4516 LDAP URL. 이것은 다른 LDAP 옵션 중 일부를 좀 더 간결한 표준 형식으로 작성하는 다른 방법이다. 기본값은 다음과 같다.
</P><PRE
CLASS="SYNOPSIS"
>ldap://<TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
>[:<TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
>]/<TT
CLASS="REPLACEABLE"
><I
>basedn</I
></TT
>[?[<TT
CLASS="REPLACEABLE"
><I
>attribute</I
></TT
>][?[<TT
CLASS="REPLACEABLE"
><I
>scope</I
></TT
>]]]</PRE
><P>
 <TT
CLASS="REPLACEABLE"
><I
>scope</I
></TT
>는 <TT
CLASS="LITERAL"
>base</TT
>, <TT
CLASS="LITERAL"
>one</TT
>, <TT
CLASS="LITERAL"
>sub</TT
> 중 하나여야 하며, 일반적으로 후자이다. 한 가지 속성만 사용되며, 필터 및 확장 같은 표준 LDAP URL의 다른 설정은 지원되지 않는다.</P
><P
> 비 익명 바인딩의 경우 <TT
CLASS="LITERAL"
>ldapbinddn</TT
> 및 <TT
CLASS="LITERAL"
>ldapbindpasswd</TT
>는 별도의 옵션으로 지정되어야 한다.</P
><P
> 암호화된 LDAP 연결을 사용하려면 <TT
CLASS="LITERAL"
>ldapurl</TT
> 외에도 <TT
CLASS="LITERAL"
>ldaptls</TT
> 옵션을 사용해야 한다. <TT
CLASS="LITERAL"
>ldaps</TT
> URL 스키마(다이렉트 SSL 연결)는 지원되지 않는다.</P
><P
> LDAP URL은 현재 Windows가 아니라 OpenLDAP에서만 지원된다.</P
></DD
></DL
></DIV
><P>
 </P
><P
>간단한 바인딩의 구성 옵션과 검색+바인딩의 옵션을 혼용하는 것은 에러이다.
 </P
><P
>간단한 바인딩 LDAP 구성의 예시는 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"</PRE
><P>
데이터베이스 사용자 <TT
CLASS="LITERAL"
>someuser</TT
>로 데이터베이스 서버에 연결이 요청된 경우 Agens SQL은 DN <TT
CLASS="LITERAL"
>cn=someuser, dc=example,
dc=net</TT
> 및 클라이언트에서 제공된 패스워드를 사용하여 LDAP 서버에 바인딩을 시도한다. 
해당 연결이 성공하면 데이터베이스 액세스가 허용된다.
 </P
><P
>검색+바인딩 구성의 예시는 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid</PRE
><P>
데이터베이스 사용자 <TT
CLASS="LITERAL"
>someuser</TT
>로 데이터베이스 서버에 연결이 요청된 경우 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 익명으로(<TT
CLASS="LITERAL"
>ldapbinddn</TT
>가 지정되지 않았으므로) 
LDAP 서버에 바인딩을 시도하고 지정된 베이스 DN 아래에서 <TT
CLASS="LITERAL"
>(uid=someuser)</TT
>에 대한 검색을 수행한다. 
항목이 발견되면 발견된 정보와 클라이언트가 제공한 패스워드를 사용하여 바인딩을 시도한다. 
해당 제2차 연결이 성공하면 데이터베이스 액세스가 허용된다.
 </P
><P
>URL로 작성한 동일한 검색+바인딩 구성은 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap lapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"</PRE
><P>
LDAP에 대한 인증을 지원하는 일부 다른 소프트웨어는 동일한 URL 형식을 사용하므로 설정을 공유하기 쉬워진다.
 </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
> LDAP는 주로 쉼표와 공백을 사용하여 DN의 서로 다른 부분을 구분하므로 
 예시에 표시된 대로 LDAP 옵션을 구성할 때 매개 변수를 큰따옴표로 둘러싸야 하는 경우가 있다.</P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-RADIUS"
>3.3.8. RADIUS 인증</A
></H2
><P
>이 인증 방법은 패스워드 검증 방법으로 RADIUS를 사용할 때 외에는 <TT
CLASS="LITERAL"
>password</TT
>와 유사하게 작동된다. 
RADIUS는 사용자 이름/패스워드 쌍을 검증할 때에만 사용된다. 따라서 RADIUS를 인증에 사용하기 전에 사용자가 데이터베이스에 존재해야 한다.
 </P
><P
>RADIUS 인증을 사용 중인 경우 구성된 RADIUS 서버로 액세스 요청(Access Request) 메시지가 전송된다. 
이 요청은 <TT
CLASS="LITERAL"
>Authenticate Only</TT
> 유형이며, <TT
CLASS="LITERAL"
>user name</TT
> 및 <TT
CLASS="LITERAL"
>password</TT
>(암호화됨), 
<TT
CLASS="LITERAL"
>NAS Identifier</TT
>에 대한 매개 변수가 포함된다. 
요청은 서버와 공유되는 시크릿을 사용하여 암호화된다. 
RADIUS 서버는 <TT
CLASS="LITERAL"
>Access Accept</TT
> 또는 <TT
CLASS="LITERAL"
>Access Reject</TT
>를 사용하여 이 서버에 응답한다. RADIUS 계정에 대한 지원은 없다.
 </P
><P
>다음 구성 옵션이 RADIUS에 대해 지원된다.
 <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>radiusserver</TT
></DT
><DD
><P
> 연결할 RADIUS 서버의 이름 또는 IP 주소. 이 매개 변수는 필수이다.</P
></DD
><DT
><TT
CLASS="LITERAL"
>radiussecret</TT
></DT
><DD
><P
> 보안을 유지하면서 RADIUS 서버와 통신할 때 사용되는 공유 시크릿. 이것은 Agens SQL 및 RADIUS 서버에서 값이 정확하게 동일해야 한다. 
 최소 16자의 string이 권장된다. 이 매개 변수는 필수이다.
 </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>사용되는 암호화 벡터는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>가 <SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>을 지원하도록 빌드된 경우 강력한 방식으로 암호화되어야 한다. 
그 외의 경우에, RADIUS 서버로의 전송은 보안이 되지 않은 애매한 것으로 간주해야 하며, 필요 시 외부 보안 대책을 적용해야 한다.
 </P
></BLOCKQUOTE
></DIV
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusport</TT
></DT
><DD
><P
> 연결할 RADIUS 서버의 포트 번호. 포트가 지정되지 않으면 기본 포트 <TT
CLASS="LITERAL"
>1812</TT
>가 사용된다.</P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusidentifier</TT
></DT
><DD
><P
> RADIUS 요청에서 <TT
CLASS="LITERAL"
>NAS Identifier</TT
>로 사용되는 string. 
 이 매개 변수는 예를 들면, 사용자가 인증하려는 데이터베이스 사용자를 식별하여 RADIUS 서버에서 제2의 매개 변수로 사용될 수 있다. 
 식별자가 지정되지 않으면 기본 <TT
CLASS="LITERAL"
>postgresql</TT
>이 사용된다.</P
></DD
></DL
></DIV
><P>
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-CERT"
>3.3.9. 인증서 인증</A
></H2
><P
>이 인증 방법은 SSL 클라이언트 인증서를 사용하여 인증을 수행한다. 
따라서 SSL 연결에서만 사용 가능하다. 이 인증 방법을 사용하는 경우 서버는 클라이언트가 유효한 인증서를 제공할 것을 요구한다. 
패스워드 프롬프트는 클라이언트로 전송되지 않는다. 
인증서의 <TT
CLASS="LITERAL"
>cn</TT
>(공통 이름) 속성은 요청된 데이터베이스 사용자 이름과 비교되며, 일치하는 경우 로그인이 허용된다. 
사용자 이름 맵핑을 사용하여 <TT
CLASS="LITERAL"
>cn</TT
>을 데이터베이스 사용자 이름과 다르게 할 수 있다.
 </P
><P
>다음 구성 옵션이 SSL 인증서 인증에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>시스템과 데이터베이스 사용자 이름 사이의 맵핑을 허용한다. 자세한 내용은 <A
HREF="auth-username-maps.html"
>3.2절</A
>을 참조 바란다.
 </P
></DD
></DL
></DIV
><P>
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PAM"
>3.3.10. PAM 인증</A
></H2
><P
>이 인증 방법은 인증 메커니즘으로 PAM(Pluggable Authentication Modules)을 사용할 때 외에는 <TT
CLASS="LITERAL"
>password</TT
>와 유사하게 작동된다. 
기본 PAM 서비스 이름은 <TT
CLASS="LITERAL"
>postgresql</TT
>이다. PAM은 사용자 이름/패스워드 쌍을 검증할 때에만 사용된다. 
따라서 PAM을 인증에 사용하기 전에 사용자가 데이터베이스에 존재해야 한다. 
PAM에 대한 자세한 내용은 <A
HREF="http://www.kernel.org/pub/linux/libs/pam/"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>Linux-PAM</SPAN
> 페이지</A
>를 참고 바란다.
 </P
><P
>다음 구성 옵션이 PAM에 대해 지원된다.
<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>pamservice</TT
></DT
><DD
><P
>PAM 서비스 이름.
 </P
></DD
></DL
></DIV
><P>
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> PAM이 <TT
CLASS="FILENAME"
>/etc/shadow</TT
>를 읽도록 설정된 경우 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 root가 아닌 다른 사용자로 시작되므로 
 인증이 실패한다. 
 단, PAM이 LDAP 또는 다른 인증 방법을 사용하도록 설정된 경우 실행되지 않는다.</P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="auth-username-maps.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>사용자 이름 맵</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>인증 문제</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>