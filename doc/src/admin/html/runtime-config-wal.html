<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Write Ahead 로그</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="서버 환경 설정"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="리소스 소비"
HREF="runtime-config-resource.html"><LINK
REL="NEXT"
TITLE="복제"
HREF="runtime-config-replication.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T09:12:38"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="리소스 소비"
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 2. 서버 환경 설정</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="복제"
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-WAL"
>2.5. Write Ahead 로그</A
></H1
><P
>이 설정에 대한 자세한 내용은 <A
HREF="wal-configuration.html"
>13.4절</A
>을 참조 바란다.
 </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-SETTINGS"
>2.5.1. 설정</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-WAL-LEVEL"
></A
><TT
CLASS="VARNAME"
>wal_level</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>wal_level</TT
>은 WAL에 기록되는 정보의 양을 결정한다. 
기본값은 충돌 또는 즉시 셧다운으로부터 복구하기 위해 필요한 정보만 기록하는 <TT
CLASS="LITERAL"
>minimal</TT
>이다. 
<TT
CLASS="LITERAL"
>archive</TT
>는 WAL 아카이브에 필요한 로깅만 추가한다. 
<TT
CLASS="LITERAL"
>hot_standby</TT
>는 대기 서버에서 읽기 전용 쿼리에 필요한 정보를 좀 더 추가한다. 
<TT
CLASS="LITERAL"
>logical</TT
>은 논리적 디코딩을 지원하는 데 필요한 정보를 추가한다. 
각 레벨에는 모두 저수준에서 로깅된 정보가 포함된다. 
이 매개변수는 서버 시작 시 설정된다.
 </P
><P
><TT
CLASS="LITERAL"
>minimal</TT
> 레벨에서, 일부 벌크 실행 WAL 로깅은 안전하게 건너뛸 수 있다. 
그러면 실행이 빨라진다. 
이러한 최적화를 적용할 수 있는 실행에는 다음이 포함된다.
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE TABLE AS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CLUSTER</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>COPY</TT
> 상기는 동일 트랜잭션에서 생성되었거나 또는 레코드가 지워진 테이블에 적용된다.</TD
></TR
></TBODY
></TABLE
><P
></P
>
그러나 최소 WAL에는 베이스 백업 및 WAL 로그로부터 데이터를 재구성하는 데 필요한 정보가 충분하지 않으므로 
WAL 아카이빙(<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
>) 및 스트리밍 복제를 하려면 <TT
CLASS="LITERAL"
>archive</TT
> 이상을 사용해야 한다.
 </P
><P
><TT
CLASS="LITERAL"
>hot_standby</TT
> 레벨에서 <TT
CLASS="LITERAL"
>archive</TT
>와 동일한 정보 및 WAL로부터 실행 트랜잭션의 상태 재구성에 필요한 정보가 로깅된다. 
대기 서버에서 읽기 전용 쿼리를 사용하려면, 운영 서버에서 <TT
CLASS="VARNAME"
>wal_level</TT
>을 <TT
CLASS="LITERAL"
>hot_standby</TT
> 이상으로 설정하고 
<A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY"
>hot_standby</A
>는 대기 서버에서 활성화해야 한다. 
<TT
CLASS="LITERAL"
>hot_standby</TT
>와 <TT
CLASS="LITERAL"
>archive</TT
> 레벨 사용시 측정 가능한 성능 차이는 거의 없는 것으로 생각되므로 
운영상 눈에 띄는 변화가 있을 경우 피드백을 주기 바란다.
 </P
><P
><TT
CLASS="LITERAL"
>논리적</TT
> 수준에서 <TT
CLASS="LITERAL"
>hot_standby</TT
>를 사용하는 것과 동일한 정보 및 
WAL로부터 논리적 변경 세트를 사용하는 데 필요한 정보가 로깅된다. 
<TT
CLASS="LITERAL"
>논리적</TT
> 수준을 사용하면 WAL 볼륨이 증가한다. 
특히 여러 개의 테이블을 <TT
CLASS="LITERAL"
>REPLICA IDENTITY FULL</TT
>로 환경 설정하고 
<TT
CLASS="COMMAND"
>UPDATE</TT
> 및 <TT
CLASS="COMMAND"
>DELETE</TT
> 문을 여러 개 실행하는 경우 그렇다.
 </P
></DD
><DT
><A
NAME="GUC-FSYNC"
></A
><TT
CLASS="VARNAME"
>fsync</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>이 매개변수가 on인 경우 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 업데이트가 물리적으로 디스크에 기록되었는지를 
<CODE
CLASS="FUNCTION"
>fsync()</CODE
> 시스템 호출 또는 상응하는 다양한 메서드(<A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
> 참조)를 사용하여 확인하려고 한다. 
이로써 운영 체제 또는 하드웨어 충돌 후에 데이터베이스 클러스터를 일정한 상태로 복구할 수 있다.
 </P
><P
><TT
CLASS="VARNAME"
>fsync</TT
>를 해제하는 것은 성능상 장점이 있지만, 결과적으로는 정전 또는 시스템 충돌의 경우에 데이터 손상이 복구 불가능할 수 있다. 
따라서 외부 데이터로 전체 데이터베이스를 손쉽게 재생성할 수 있는 경우에만 <TT
CLASS="VARNAME"
>fsync</TT
>를 해제하는 것이 바람직하다.
 </P
><P
><TT
CLASS="VARNAME"
>fsync</TT
>를 해제하는 안전한 방법 중 백업 파일로부터 새 데이터베이스 클러스터를 초기 로딩하여  
폐기하고 재생성할 데이터베이스의 데이터를 일괄 처리하거나, 
자주 재생성되고 장애처리(failover)용으로 사용되지 않는 읽기 전용 데이터베이스를 복제하는 데
 이 데이터베이스 클러스터를 사용하는 방법이 있다.
고성능 하드웨어만을 위해 <TT
CLASS="VARNAME"
>fsync</TT
>를 해제하는 것은 바람직하지 않다.
 </P
><P
><TT
CLASS="VARNAME"
>fsync</TT
>를 해제했다가 다시 설정하는 경우 복구 신뢰도를 위해 커널에서 변경된 모든 버퍼를 내구성이 좋은 저장소로 
강제 이동하는 것이 필요하다. 
이것은 클러스터가 셧다운 중이거나 fsync가 on일 때 <TT
CLASS="COMMAND"
>initdb
--sync-only</TT
>를 실행하거나, <TT
CLASS="COMMAND"
>sync</TT
>를 실행하거나, 파일 시스템의 마운트를 해제하거나, 서버를 리부팅함으로써 가능하다.
 </P
><P
>여러 가지 상황에서 중요하지 않은 트랜잭션에 대해 <A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
>를 해제하면 
데이터 충돌 위험 없이 <TT
CLASS="VARNAME"
>fsync</TT
>를 해제함으로써 잠재적인 성능상 장점을 얻을 수 있다.
 </P
><P
><TT
CLASS="VARNAME"
>fsync</TT
>는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정할 수 있다. 
이 매개변수를 해제할 경우 <A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>의 해제도 고려해야 한다.
 </P
></DD
><DT
><A
NAME="GUC-SYNCHRONOUS-COMMIT"
></A
><TT
CLASS="VARNAME"
>synchronous_commit</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>명령이 <SPAN
CLASS="QUOTE"
>"success"</SPAN
> 표시를 클라이언트에 리턴하기 전에 WAL 레코드가 디스크에 기록될 때까지 트랜잭션 커밋이 기다릴지 여부를 지정한다. 
유효 값은 <TT
CLASS="LITERAL"
>on</TT
> 및 
<TT
CLASS="LITERAL"
>remote_write</TT
>, <TT
CLASS="LITERAL"
>local</TT
>, <TT
CLASS="LITERAL"
>off</TT
>이다. 
기본값 및 안전 설정은 <TT
CLASS="LITERAL"
>on</TT
>이다. 
<TT
CLASS="LITERAL"
>off</TT
>인 경우 success표시가 클라이언트에 전달되는 시간과 서버 충돌 없이 트랜잭션이 정말로 안전하다는 것이 보장되는 시간 사이에 
지연이 생길 수 있다. 
(최대 지연은 <A
HREF="runtime-config-wal.html#GUC-WAL-WRITER-DELAY"
>wal_writer_delay</A
>의 3배이다.) 
<A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>와 달리, 이 매개변수를 <TT
CLASS="LITERAL"
>off</TT
>로 설정하면 데이터베이스 불일치 위험이 발생하지 않는다. 
운영 체제 또는 데이터베이스 충돌은 이른바 최근에 커밋된 트랜잭션이 일부 분실되는 결과가 발생하지만 
데이터베이스 상태는 해당 트랜잭션이 깔끔하게 중단된 것과 같다. 
따라서, 트랜잭션 영속성에 대해 정확한 확실성보다는 성능이 더 중요한 경우에 <TT
CLASS="VARNAME"
>synchronous_commit</TT
>를 해제하는 것이 
유용한 대안일 수 있다. 자세한 내용은 <A
HREF="wal-async-commit.html"
>13.3절</A
>을 참조 바란다.
 </P
><P
><A
HREF="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES"
>synchronous_standby_names</A
>가 설정되면, 트랜잭션의 WAL 레코드가 대기 서버로 복제될 때까지 트랜잭션 커밋이 
기다릴지의 여부를 이 매개변수로도 제어한다. 
<TT
CLASS="LITERAL"
>on</TT
>으로 설정되면, 트랜잭션의 커밋 레코드를 수신했고 디스크에 쓰기 되었다는 응답이 현재의 동기 대기 서버로부터 올 때까지 커밋이 대기한다. 
이것은 운영 서버 및 대기 서버 양쪽에서 데이터베이스 저장소의 손상이 없는 경우에 트랜잭션이 분실되지 않았음을 보장한다. 
<TT
CLASS="LITERAL"
>remote_write</TT
>로 설정되면, 트랜잭션의 커밋 레코드를 수신했고 대기 서버의 운영 체제에 쓰기 되었지만, 
대기 서버의 안정된 저장소에 데이터가 도착했는지는 확실하지 않다는 응답이 현재의 동기 대기 서버로부터 올 때까지 커밋이 대기한다. 
데이터 보존을 위해서는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 대기 서버 인스턴스가 충돌한 경우에도 이 설정으로 충분하지만 
대기 서버가 운영 체제 수준에서 충돌이 발생한 경우는 그렇지 않다.
 </P
><P
>동기 복제를 사용 중인 경우 일반적으로 로컬에서 디스크로 쓰기 되도록 기다리거나, WAL 레코드의 복제를 기다리거나, 
트랜잭션이 비동기적으로 커밋되게 하는 것이 합리적이다. 
그러나, <TT
CLASS="LITERAL"
>local</TT
> 설정은 로컬에서 디스크로 써지는 것은 기다리지만 동기 복제는 기다리지 않는 트랜잭션에 사용할 수 있다. 
<TT
CLASS="VARNAME"
>synchronous_standby_names</TT
>를 설정하지 않으면 <TT
CLASS="LITERAL"
>on</TT
> 및 <TT
CLASS="LITERAL"
>remote_write</TT
>, <TT
CLASS="LITERAL"
>local</TT
> 설정 
모두 동일한 동기화 레벨을 제공하며 트랜잭션 커밋은 로컬에서 디스크로 쓰기만을 기다린다.
 </P
><P
>이 매개변수는 언제든 변경할 수 있다. 모든 트랜잭션의 동작은 사실상 커밋되었을 때의 설정에 따라 결정된다. 
따라서 일부 트랜잭션 커밋은 동기적으로, 그 외에는 비동기적으로 만드는 것이 가능하고 유용하다. 
예를 들면, 기본값이 반대인 경우 구문이 여러 개인 트랜잭션 커밋 하나를 비동기적으로 만들려면 트랜잭션 내에서 <TT
CLASS="COMMAND"
>SET
LOCAL synchronous_commit TO OFF</TT
>를 실행해야 한다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-SYNC-METHOD"
></A
><TT
CLASS="VARNAME"
>wal_sync_method</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>디스크에 WAL을 강제로 업데이트할 때 사용되는 메서드. 
<TT
CLASS="VARNAME"
>fsync</TT
>가 off인 경우 WAL 파일을 일절 강제로 업데이트하지 않기 때문에 이 설정은 무관하다. 가능한 값은 다음과 같다.
 </P
><P
></P
><UL
><LI
><P
> <TT
CLASS="LITERAL"
>open_datasync</TT
> (<CODE
CLASS="FUNCTION"
>open()</CODE
> 옵션 <TT
CLASS="SYMBOL"
>O_DSYNC</TT
>를 사용하여 WAL 파일 쓰기)</P
></LI
><LI
><P
> <TT
CLASS="LITERAL"
>fdatasync</TT
> (커밋마다 <CODE
CLASS="FUNCTION"
>fdatasync()</CODE
> 호출)</P
></LI
><LI
><P
> <TT
CLASS="LITERAL"
>fsync</TT
> (커밋마다 <CODE
CLASS="FUNCTION"
>fsync()</CODE
> 호출)</P
></LI
><LI
><P
> <TT
CLASS="LITERAL"
>fsync_writethrough</TT
> (커밋마다 <CODE
CLASS="FUNCTION"
>fsync()</CODE
> 호출, 모든 디스크 쓰기 캐시에서 write-through 강제로 수행)</P
></LI
><LI
><P
> <TT
CLASS="LITERAL"
>open_sync</TT
> (<CODE
CLASS="FUNCTION"
>open()</CODE
> 옵션 <TT
CLASS="SYMBOL"
>O_SYNC</TT
>를 사용하여 WAL 파일 쓰기)</P
></LI
></UL
><P
><TT
CLASS="LITERAL"
>open_</TT
>* 옵션도 필요 시 <TT
CLASS="LITERAL"
>O_DIRECT</TT
>를 사용한다. 이와 같은 선택이 항상 모든 플랫폼에서 가능한 것은 아니다. 
기본값은 플랫폼에서 지원되는 위의 목록에서 첫 번째 메서드이다. 
단, Linux에서는 <TT
CLASS="LITERAL"
>fdatasync</TT
>가 기본값이다. 기본값이 반드시 이상적인 것은 아니다. 
충돌로부터 안전한 환경 설정을 만들거나 성능을 최적화하려면 값을 변경하거나 시스템 환경 설정의 다른 측면을 변경하는 것이 필요할 수도 있다. 
이러한 측면은 <A
HREF="wal-reliability.html"
>13.1절</A
>에서 다룬다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-FULL-PAGE-WRITES"
></A
><TT
CLASS="VARNAME"
>full_page_writes</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>이 매개변수가 on이면, <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 체크포인트 이후의 각 디스크 페이지를 처음 수정하는 도중에 
해당 페이지의 전체 내용을 WAL에 기록한다. 
이것은, 운영 체제 충돌 시 진행 중인 페이지 쓰기가 부분적으로만 완료되어 디스크 상의 페이지에 옛날 데이터와 새 데이터가 공존할 수 있기 때문에 
필요하다. 
일반적으로 WAL에 저장되는 행 수준(row-level) 변경 데이터는 충돌 후 복구 중에 그러한 페이지를 완전히 복구하는 데 충분하지 않다. 
전체 페이지 이미지를 저장하면 페이지의 올바른 복구가 보장되지만 WAL에 기록해야 하는 데이터량의 증가를 감수해야 한다. 
(WAL 리플레이는 항상 체크포인트에서 시작되므로 체크포인트 이후의 페이지별 첫 번째 변경 중에 해도 충분하다. 
그러므로 전체 페이지 쓰기 비용을 줄이는 한 가지 방법은 체크포인트 간격 매개변수를 늘리는 것이다.)
 </P
><P
>이 매개변수를 해제하면 정상적인 운영 속도가 빨라지지만 시스템 장애 발생 시 손상된 데이터가 복구 불가능하게 되거나 
데이터 손상이 드러나지 않을 수 있다. 
이러한 위험은 규모는 작지만 <TT
CLASS="VARNAME"
>fsync</TT
>을 해제했을 때와 유사하며, 
fsync에 권장되는 것과 환경이 동일할 때만 해제해야 한다.
 </P
><P
>이 매개변수를 해제하는 것은 point-in-time recovery(PITR)용 WAL 아카이빙의 사용에는 영향을 미치지 않는다
(<A
HREF="continuous-archiving.html"
>8.3절</A
> 참조).
 </P
><P
>이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 
기본값은 <TT
CLASS="LITERAL"
>on</TT
>이다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-LOG-HINTS"
></A
><TT
CLASS="VARNAME"
>wal_log_hints</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>이 매개변수가 <TT
CLASS="LITERAL"
>on</TT
>이면, <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 체크포인트 이후의 각 디스크 페이지를 처음 수정하는 도중에는
소위 힌트 비트(hint bits)의 중요하지 않은 수정도 포함하여 해당 페이지의 전체 내용을 WAL에 기록한다.
 </P
><P
>데이터 체크섬이 사용으로 설정되면 힌트 비트(hint bit) 업데이트가 항상 WAL 로깅되고 이 설정은 무시된다. 
데이터베이스에서 데이터 체크섬이 사용으로 설정된 경우 이 설정을 사용하여 WAL 로깅이 추가로 얼마나 발생하는지 테스트할 수 있다.
 </P
><P
>이 매개변수는 서버 시작 시 설정된다. 기본값은 <TT
CLASS="LITERAL"
>off</TT
>이다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-BUFFERS"
></A
><TT
CLASS="VARNAME"
>wal_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>WAL 데이터에 사용되고 아직 디스크에 기록되지 않은 공유 메모리의 합계. 
기본 설정 -1은 <A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>의 1/32번째(약 3%)와 동일한 크기로써 
<TT
CLASS="LITERAL"
>64kB</TT
> 이상, WAL 세그먼트 1개 크기 이하이고, 일반적으로 <TT
CLASS="LITERAL"
>16MB</TT
>이다. 
자동 설정이 너무 크거나 작은 경우에 직접 선택할 수 있으며, 
<TT
CLASS="LITERAL"
>32kB</TT
> 미만은 <TT
CLASS="LITERAL"
>32kB</TT
>로 처리된다. 
이 매개변수는 서버 시작 시 설정 된다.
 </P
><P
>WAL 버퍼의 내용은 모든 트랜잭션 커밋마다 디스크에 쓰기 되므로 극단적으로 큰 값은 별다른 장점이 없을 가능성이 높다. 
그러나, 이 값을 최소한 몇 메가바이트로 설정하면 여러 클라이언트가 한꺼번에 커밋함으로써 busy한 서버의 쓰기 성능이 개선된다. 
기본 설정 -1인 자동 튜닝은 대부분 합리적인 결과를 만든다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-WRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>wal_writer_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>WAL writer의 작업 간 지연을 정한다. 
각 작업 시 writer는 WAL을 디스크에 기록한다. 
그런 다음, <TT
CLASS="VARNAME"
>wal_writer_delay</TT
> 밀리초 동안 슬립한 다음, 반복한다. 
기본값은 200밀리초이다(<TT
CLASS="LITERAL"
>200ms</TT
>). 
다수의 시스템에서 효율적인 슬립 지연 설정은 10밀리초이다. 
<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>를 10의 배수가 아닌 다른 값으로 설정하면 10의 배수로 값을 올림하여 설정한 것과 결과가 동일하다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-COMMIT-DELAY"
></A
><TT
CLASS="VARNAME"
>commit_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>commit_delay</TT
>는 WAL 플러쉬(flush)를 초기화하기 전에 측정된 시간 지연을 마이크로초 단위로 추가한다. 
이것은 시스템 로드가 충분히 커서 주어진 간격 내에 트랜잭션을 추가로 커밋할 준비가 된 경우 
단일 WAL 플러쉬를 통해 대량의 트랜잭션이 커밋되게 함으로써 그룹 커밋 처리량을 개선할 수 있다. 
그러나 이것은 WAL 플러쉬별로 대기 시간을 최대 <TT
CLASS="VARNAME"
>commit_delay</TT
> 마이크로초까지 늘리기도 한다. 
커밋할 준비가 된 트랜잭션이 없을 경우 지연은 낭비되는 시간이므로 쓰기가 곧 시작되는 경우 최소한 <TT
CLASS="VARNAME"
>commit_siblings</TT
>만큼의 다른
트랜잭션이 수행될 때 지연이 수행된다. 
또한 <TT
CLASS="VARNAME"
>fsync</TT
>가 비활성화되면 지연이 수행되지 않는다. 
기본 <TT
CLASS="VARNAME"
>commit_delay</TT
>는 0이다(지연 없음). 
수퍼유저만 이 설정을 변경할 수 있다.
 </P
><P
>9.3 이전의 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 버전에서 <TT
CLASS="VARNAME"
>commit_delay</TT
>는 동작이 다르고 효과도 떨어진다. 
이것은 모든 WAL 플러쉬가 아닌 커밋에만 영향을 주었고 WAL 플러쉬가 곧 완료된 경우에도 환경 설정된 지연 시간 동안 대기했다. 
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3 초반에, 쓸 준비가 된 첫 번째 프로세스는 환경 설정된 시간 간격을 기다리고, 
추후 프로세스는 선행 프로세스의 쓰기 연산이 끝날 때까지 대기한다.
 </P
></DD
><DT
><A
NAME="GUC-COMMIT-SIBLINGS"
></A
><TT
CLASS="VARNAME"
>commit_siblings</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>commit_delay</TT
> 지연을 수행하기 전에 필요한 동시 개방 트랜잭션의 최소 수. 
값이 크면, 지연 간격 중에 커밋 준비가 된 다른 트랜잭션이 최소한 하나 이상일 확률이 높다. 
기본값은 5개 트랜잭션이다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-CHECKPOINTS"
>2.5.2. 체크포인트</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-CHECKPOINT-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>checkpoint_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>자동 WAL 체크포인트들 간 로그 파일 세그먼트의 최대 수(각 세그먼트는 일반적으로 16메가바이트). 
기본값은 3개 세그먼트이다. 이 매개변수를 늘리면 충돌 복구에 필요한 시간을 늘릴 수 있다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>자동 WAL 체크포인트들 간의 최대 시간. 초 단위. 기본값은 5분이다(<TT
CLASS="LITERAL"
>5min</TT
>). 
이 매개변수를 늘리면 충돌 복구에 필요한 시간을 늘릴 수 있다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-COMPLETION-TARGET"
></A
><TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>)&#13;</DT
><DD
><P
> 체크포인트들 간 총 시간 분할로써, 체크포인트들 완료 목표를 지정한다. 기본값은 0.5이다. 
 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-WARNING"
></A
><TT
CLASS="VARNAME"
>checkpoint_warning</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
> 체크포인트 세그먼트 파일을 채우는 체크포인트들이 여기에 지정된 초 수보다 빨리 발생한 경우 서버 로그에 메시지를 기록한다
 (<TT
CLASS="VARNAME"
>checkpoint_segments</TT
>를 증가시키는 것이 권장됨). 
기본값은 30초이다(<TT
CLASS="LITERAL"
>30s</TT
>). 0은 경고를 비활성화한다. 
<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>가 <TT
CLASS="VARNAME"
>checkpoint_warning</TT
> 미만이면 경고가 발생하지 않는다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-ARCHIVING"
>2.5.3. Archiving</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-ARCHIVE-MODE"
></A
><TT
CLASS="VARNAME"
>archive_mode</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>archive_mode</TT
>을 사용하는 것으로 설정하면 완료된 WAL 세그먼트가 <A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
> 설정에 의해 
아카이브 저장소로 전달된다. 
<TT
CLASS="VARNAME"
>archive_mode</TT
> 및 <TT
CLASS="VARNAME"
>archive_command</TT
>는 별개의 변수이므로 아카이빙 모드를 해지하지 않고도 
<TT
CLASS="VARNAME"
>archive_command</TT
>를 변경할 수 있다. 
이 매개변수는 서버 시작 시 설정된다. 
<TT
CLASS="VARNAME"
>wal_level</TT
>이 <TT
CLASS="LITERAL"
>minimal</TT
>로 설정된 경우 <TT
CLASS="VARNAME"
>archive_mode</TT
>를 사용으로 설정할 수 없다.
 </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-COMMAND"
></A
><TT
CLASS="VARNAME"
>archive_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
>완료된 WAL 파일 세그먼트를 아카이브하기 위해 실행하는 로컬 쉘 명령. 
string에서 <TT
CLASS="LITERAL"
>%p</TT
>는 아카이브할 파일의 경로명으로 대체되고 <TT
CLASS="LITERAL"
>%f</TT
>는 파일명으로만 대체된다. 
(경로명은 서버(예: 클러스터의 데이터 디렉토리)의 작업 디렉토리에 상대적이다.) 
<TT
CLASS="LITERAL"
>%</TT
> 문자를 명령에 포함하려면 <TT
CLASS="LITERAL"
>%%</TT
>를 사용해야 한다. 
성공한 경우에만 명령이 0 종료(zero exit) 상태를 리턴하는 것이 중요하다. 
자세한 내용은 <A
HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL"
>8.3.1절</A
>을 참조 바란다.
 </P
><P
>이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 
<TT
CLASS="VARNAME"
>archive_mode</TT
>가 서버 시작 시에 활성화되지 않은 경우 무시된다. 
<TT
CLASS="VARNAME"
>archive_mode</TT
>가 사용으로 설정된 상태에서 <TT
CLASS="VARNAME"
>archive_command</TT
>의 string이 비어 있는 경우(기본값) 
WAL 아카이빙이 일시적으로 비활성화되지만 서버는 명령이 곧 제시될 것이라는 기대를 갖고 WAL 세그먼트 파일을 계속 누적한다. 
<TT
CLASS="VARNAME"
>archive_command</TT
>가 true만 리턴하는 명령으로 설정하면
예를 들어 <TT
CLASS="LITERAL"
>/bin/true</TT
> 같은 경우(Windows에서는 <TT
CLASS="LITERAL"
>REM</TT
>), 아카이빙이 효율적으로 비활성화되지만, 
아카이브 복구에 필요한 WAL 파일의 체인이 끊어지므로 특이한 환경에서만 사용되어야 한다.
 </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>archive_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>는 완료된 WAL 세그먼트를 호출만 한다. 
그러므로, 서버에서는 WAL 트래픽이 발생되지 않아서(WAL 트래픽 발생 시 여유시간이 있거나) 
트랜잭션의 완료 되는 시간과 아카이브 저장소에서 안전하게 기록 되는 사이에 긴 지연이 발생할 수 있다. 
데이터가 아카이브되지 않은 채로 방치되지 않게 하기 위해 서버가 새 WAL 세그먼트 파일로 주기적으로 전환되도록 
<TT
CLASS="VARNAME"
>archive_timeout</TT
>을 설정할 수 있다. 
이 매개변수가 0보다 큰 경우 마지막 세그먼트 파일로 전환한 이후로 여기서 지정된 초 시간을 경과할 때마다, 
그리고 단일 체크포인트들을 비롯한 데이터베이스 작업이 있을 때마다 서버는 새 세그먼트 파일로 전환한다. 
(<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>을 늘리면 유휴 시스템에서 불필요한 체크포인트들이 줄어든다.) 
강제 전환 때문에 일찌감치 종료된 아카이브된 파일의 길이도 전체 파일 길이와 동일하다는 점에 유의해야 한다. 
따라서, <TT
CLASS="VARNAME"
>archive_timeout</TT
>를 매우 짧게 하는 것은 아카이브 저장소를 부풀게 하므로 현명하지 못하다. 
<TT
CLASS="VARNAME"
>archive_timeout</TT
>을 1분 정도로 설정하는 것이 일반적으로 합당하다. 
데이터를 마스터 서버로 빠르게 복사하려면 아카이빙 대신 스트리밍 복제를 사용해야 한다.
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>리소스 소비</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>복제</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>