<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>SQL 덤프</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="백업과 복원"
HREF="backup.html"><LINK
REL="PREVIOUS"
TITLE="백업과 복원"
HREF="backup.html"><LINK
REL="NEXT"
TITLE="파일 시스템 기반 백업"
HREF="backup-file.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T09:12:38"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="백업과 복원"
HREF="backup.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 8. 백업과 복원</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="파일 시스템 기반 백업"
HREF="backup-file.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="BACKUP-DUMP"
>8.1. <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> 덤프</A
></H1
><P
>   이 방법은 백업 프로그램이 백업 대상에 대해서 
   SQL 구문의 파일을 만들고, 
   복원을 할 때는 서버에 이 SQL 구문을 실행해서 
   백업 할 때의 상태로 만드는 기법이다.
   이 방법을 구현한 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 
   유틸리티 프로그램이 pg dump 이다.
   기본적인 사용법은 다음과 같다:
</P><PRE
CLASS="SYNOPSIS"
>pg_dump <TT
CLASS="REPLACEABLE"
><I
>데이터베이스이름</I
></TT
> &gt; <TT
CLASS="REPLACEABLE"
><I
>출력파일</I
></TT
></PRE
><P>
   위와 같이, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령의 결과는 
   표준 출력(stdout)으로 출력된다.
   다음 글에서 이 프로그램이 얼마나 유용하게 쓰이는 지 알 수 있을 것이다.
   위 명령은 텍스트 파일을 만들지만 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령에 
   부가 옵션들을 사용하면, 복원 작업 시 보다 섬세한 처리나 
   병렬 처리를 할 수 있도록 텍스트가 아닌 다른 양식으로도 만들 수 있다.
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램은 여느 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>
   클라이언트 응용 프로그램과 같다(특히 잘 만들어진).
   이 말은 원격 데이터베이스 서버에 대해서 
   그 접속 권한이 있으면, 그 접속 가능한 다른 호스트에서 이 명령을 실행 할 수 있음을 
   의미한다. 다만, 덤프 작업을 하기 때문에 필요에 따라서 
   스키마의 접근 권한이 있어야 하고 테이블의 읽기 권한이 있어야 하는 등 
   그 적절한 접근 권한이 있어야한다. 
   대부분 실무에서는 이 작업은 데이터베이스 슈퍼유저로 실행된다. 
   (물론 해당 데이터베이스 전체를 백업할 수 없는 일반 유저 권한이라도 
   <TT
CLASS="OPTION"
>-n <TT
CLASS="REPLACEABLE"
><I
>schema</I
></TT
></TT
>
   또는 <TT
CLASS="OPTION"
>-t <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
></TT
> 옵션을 사용해서
   자신이 접근 할 수 있는 객체만 백업할 수 있다.)
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램을 실행해서 
   원격 데이터베이스 서버를 지정하기 위해서는
   <TT
CLASS="OPTION"
>-h <TT
CLASS="REPLACEABLE"
><I
>호스트이름</I
></TT
></TT
>, <TT
CLASS="OPTION"
>-p <TT
CLASS="REPLACEABLE"
><I
>포트</I
></TT
></TT
>
   옵션을 사용한다.
   <TT
CLASS="OPTION"
>-h</TT
> 옵션을 사용하지 않으면 
   먼저 <TT
CLASS="ENVAR"
>PGHOST</TT
> 시스템 환경 변수에서 지정된 호스트로 접속을 
   시도하며, 이 값이 지정되어 있지 않으면 로컬 호스트로 접속한다.
   <TT
CLASS="OPTION"
>-p</TT
> 옵션을 사용하지 않으면
   먼저 <TT
CLASS="ENVAR"
>PGPORT</TT
> 시스템 환경 변수에서 지정된 포트로 접속을
   시도하며, 이 값이 지정되어 있지 않으면 이 프로그램이 컴파일 될 때 지정한 포트로 접속한다.
  </P
><P
>   다른 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 클라이언트 응용 프로그램과 
   마찬가지로 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램도 
   데이터베이스 사용자 계정을 특별히 지정하지 않으면 
   현재의 운영체제 시스템 사용자 계정의 이름을 사용한다.
   데이터베이스 사용자 계정을 지정하려면 
   <TT
CLASS="OPTION"
>-U</TT
> 옵션을 사용하며 
   <TT
CLASS="ENVAR"
>PGUSER</TT
> 시스템 환경 변수로도 이 데이터베이스 사용자 계정을
   지정할 수 있으며, 이 값의 사용 우선 순위도 위의 다른 
   시스템 환경 변수들과 같다. 
   위에서 언급한 대로 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램의 데이터베이스
   접속은 클라이언트 인증 메카니즘을 사용한다. 이에 대한
   보다 자세항 사항은 <A
HREF="client-authentication.html"
>3장</A
>에서 다룬다.
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램을 이용한 데이터베이스 백업 방법은 
   파일 시스템 기반 백업과 아카이브 모드 백업 방법에 비교해서 
   다음과 같은 잇점이 있다. 먼저 복원 서버의 버전이 백업 서버의 버전보다
   더 최신인 것도 복원이 가능하다.
   32-bit, 64-bit와 같은 머신 아키텍처가 서로 달라도 가능하다.
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램이 실행되면, 그 실행되는 시점의
   스냅샷 상태로 작업을 진행한다.
   <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램이 실행되는 동안 다른 세션에서
   <TT
CLASS="COMMAND"
>ALTER TABLE</TT
> 명령과 같이 exclusive lock이 발생하지 
   않는 상태이면 대부분의 작업은 특별한 잠김 없이 작업을 진행한다.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-DUMP-RESTORE"
>8.1.1. 덤프 파일 복원하기</A
></H2
><P
>    <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램으로 만든 텍스트 덤프 파일은
        <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 프로그램에서 바로 사용할 수 있다. 
        일반적인 사용법은 다음과 같다.
</P><PRE
CLASS="SYNOPSIS"
>psql <TT
CLASS="REPLACEABLE"
><I
>데이터베이스이름</I
></TT
> &lt; <TT
CLASS="REPLACEABLE"
><I
>입력파일</I
></TT
></PRE
><P>
    <TT
CLASS="REPLACEABLE"
><I
>입력파일</I
></TT
> 자리에 
        <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령으로 만든 덤프 파일을 지정한다.
        <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> 자리에는
        <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 클라이언트가 접속 해서 
        덤프 파일의 명령을 실행할 데이터베이스 이름을 지정한다. 
        주의할 점은 위 명령으로 해당 데이터베이스가 만들어지지는 않는다는 점이다. 
        <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 명령을 실행하기 전에 먼저 
        <TT
CLASS="LITERAL"
>createdb -T template0 <TT
CLASS="REPLACEABLE"
><I
>데이터베이스이름</I
></TT
></TT
> 명령과 같이
    먼저 접속할 데이터베이스를 만들어 놓아야한다. 
    <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 프로그램도 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램과 
        같은 데이터베이스 접속과 관련된 접속 인증 방식으로 
        환경변수와 커맨드라인 옵션을 사용하면 된다.
    <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 프로그램에 대한 자세한 설명은 psql
        설명서에서 다룬다. 일반 텍스트 덤프 파일이 아닌 백업 파일을 복원할 경우는
        pg restore 명령을 이용한다.
   </P
><P
>    SQL 덤프 파일 안에는 각 객체의 접근 권한을 지정하는 명령도 
        포함되어 있기 때문에 그 덤프 파일 안에서 사용하는 모든 사용자들도 
        새 데이터베이스에 미리 만들어야한다.
        해당 사용자가 없으면 이 접근 권한을 설정하는 명령어들은 모두 
        실패할 것이다. (가끔 이것을 의도해서 이렇게 처리하기도 하지만 
        일반적인 방법은 아니다.)
   </P
><P
>    기본적으로 <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 스크립트는 해당 작업 도중
        오류가 발생하면 멈추지 않고 다음 작업을 진행한다.
        만일 이런 기능을 원치 않으면 <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 프로그램을
        실행 할 때, <TT
CLASS="LITERAL"
>ON_ERROR_STOP</TT
> 변수를 지정한다.
        이렇게 하면, 스크립트 실행 도중 오류가 발생했을 때 
        바로 스크립트는 중지되고 <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 실행 
        리턴 코드 3으로 종료된다.
    다음은 그 사용 방법이다.
</P><PRE
CLASS="PROGRAMLISTING"
>psql --set ON_ERROR_STOP=on dbname &lt; infile</PRE
><P>
    이 방법은 스크립트에서 정상적으로 실행된 작업들에 대해서는
        해당 데이터베이스에 반영되었다는 것을 의미한다. 
        트랜잭션 처리 방식 처럼
        모든 스크립트가 정상 처리되어야만 전체가 반영되게 하려면 
        <TT
CLASS="OPTION"
>-1</TT
> 또는 <TT
CLASS="OPTION"
>--single-transaction</TT
> 옵션을 사용해서 
        스크립트 전체를 하나의 트랜잭션으로 처리하도록 한다.
        단점은 많은 작업을 해야하는데 작은 오류 하나로 
        전체가 롤백 되면서 많은 시간을 소비할 수 있다는 점이다.
        대신에 오류가 발생하면 수동으로 일일이 복잡한 데이터베이스 정리
        작업을 하지 않아도 된다.
   </P
><P
>    <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 두 프로그램 모두
        표준 입출력을 사용할 수 있기 때문에 
        파이프를 사용하면 덤프 하면서 바로 다른 데이터베이스 서버에 
        복원할 수도 있다. 사용법은 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>pg_dump -h <TT
CLASS="REPLACEABLE"
><I
>호스트1</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>데이터베이스이름</I
></TT
> | psql -h <TT
CLASS="REPLACEABLE"
><I
>호스트2</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>데이터베이스이름</I
></TT
></PRE
><P>
   </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>중요: </B
>         <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령으로 만들어지는 결과물은
         <TT
CLASS="LITERAL"
>template0</TT
> 데이터베이스 기반으로 변경된 모든 
         작업이 포함된다. 그래서 프로시져 언어, 확장 모듈과 관련된 
         함수들이 모두 포함되어있다. 
         만일 사용의 편의를 위해서 이런 기반 작업들을 <TT
CLASS="LITERAL"
>template1</TT
>
         데이터베이스에 해 두면 일반적인 방법으로 데이터베이스를 만들 때
         <TT
CLASS="LITERAL"
>template1</TT
> 데이터베이스를 참조해서 만들기 때문에 
         복원 작업에서 충돌이 발생할 수 있다. 이것을 방지하기 위해서는 
         위에서 언급한 대로 <TT
CLASS="LITERAL"
>template0</TT
> 데이터베이스를 참조해서 
         새 데이터베이스를 만들어서 사용하는 것이 바람직하다.
    </P
></BLOCKQUOTE
></DIV
><P
>    백업 파일의 복원 작업이 끝난 후에는 
        쿼리 최적화기가 올바른 통계 정보를 사용할 수 있도록 
        ANALYZE 명령을 실행 한다.(
        <A
HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS"
>7.1.3절</A
>과
        <A
HREF="routine-vacuuming.html#AUTOVACUUM"
>7.1.6절</A
> 참조.)
        대용량 데이터베이스 작업에서, 보다 나은 성능을 고려하면 
    <A
HREF="routine-vacuuming.html#VACUUM-FOR-STATISTICS"
>7.1.3절</A
>을 참조해서 
        덤프, 복원 작업을 하기 전에 먼저 서버 환경을 변경하고 
        작업을 진행하는 것도 좋은 방법이다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-DUMP-ALL"
>8.1.2. <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> 명령어 이용하기</A
></H2
><P
>    <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령어는 지정한 하나의 데이터베이스만
        한 번에 백업한다. 또한 데이터베이스 객체에 속하지 않는 
        role(데이터베이스 사용자), 테이블스페이스 정보는 백업되지 않는다.
        데이터베이스 클러스터 기준 모든 정보를 백업받으려면, 
        pg dumpall 프로그램을 이용한다. 
        일반적인 사용법은 다음과 같다.
</P><PRE
CLASS="SYNOPSIS"
>pg_dumpall &gt; <TT
CLASS="REPLACEABLE"
><I
>outfile</I
></TT
></PRE
><P>
    이 덤프 파일은 <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 프로그램에서 다음과 같이 사용한다:
</P><PRE
CLASS="SYNOPSIS"
>psql -f <TT
CLASS="REPLACEABLE"
><I
>덤프파일</I
></TT
> postgres</PRE
><P>
    (정확하게는, 데이터베이스 서버에 접속하기 위해서 <TT
CLASS="LITERAL"
>postgres</TT
>
        데이터베이스 이름을 지정한 것 뿐이지, 실제로는 접속이 끝나면 
        바로 이 데이터베이스에서 작업하기 전에 먼저 데이터베이스 클러스터 전역
        정보부터 복원 작업을 시작한다.)
        <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> 명령을 사용할 때는 접속할 해당 데이터베이스의
        슈퍼유저로 접속해야 한다. 그래야 role, 테이블스페이스 정보들을 
        덤프할 수 있다. 또한 이 덤프된 자료를 복원할 때도 마찬가지다.
        주의할 점은 만일 기본 테이블스페이스 외에 다른 테이블스페이스를 사용하면 
        그 테이블스페이스의 실제 디렉토리도 덤프 하는 서버에서 사용하는 경로와
        똑같이 만들어 놓아야한다.
   </P
><P
>    <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> 명령은 먼저 데이터베이스 사용자를 위한
        role 정보, 다음 테이블스페이스 정보, 다음 기본 템플릿 데이터베이스에 대한 
        덤프 작업을 한 다음 각 데이터베이스를 덤프하기 위해 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>
        프로그램을 호출 한다. 이 말은 각 데이터베이스가 각기 다른 시간에 
        백업 작업을 진행 하기 때문에 데이터베이스간 똑같은 시간대의 스냅샷 형태의 
        자료 덤프는 불가능하다는 의미다.
   </P
><P
>    데이터베이스 클러스터의 서버 전역 객체들만 백업하려면 
    <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> <TT
CLASS="OPTION"
>--globals-only</TT
> 옵션을
    이용한다. 이 경우는 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령을 이용해서
    각각의 데이터베이스를 따로 백업해서 복원하려고 할 때 필요하다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-DUMP-LARGE"
>8.1.3. 대용량 데이터베이스 다루기</A
></H2
><P
>    몇 운영체제는 만들 수 있는 최대 파일 크기가 제한 되어 있어, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령으로 만들어지는 파일이 이
    최대 파일 크기를 초과하는 경우 문제가 될 수 있다.
    다행이, <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령의 출력 내용을 표준 출력(stdout)으로 보낼 수 있기 때문에 표준 유닉스 명령들을 이용하면  
    이런 잠재적인 문제를 피해갈 수 있다. 그 방법은 다음과 같이 여러가지다.
   </P
><DIV
CLASS="FORMALPARA"
><P
><B
>덤프 내용을 압축하라. </B
>     <SPAN
CLASS="APPLICATION"
>gzip</SPAN
>과 같은 압축 프로그램을 사용하는 방법:

</P><PRE
CLASS="PROGRAMLISTING"
>pg_dump <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> | gzip &gt; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz</PRE
><P>

     복원 할 때는,

</P><PRE
CLASS="PROGRAMLISTING"
>gunzip -c <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

     또는,

</P><PRE
CLASS="PROGRAMLISTING"
>cat <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>.gz | gunzip | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>
    </P
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
><TT
CLASS="COMMAND"
>split</TT
> 명령을 이용하라. </B
>     <TT
CLASS="COMMAND"
>split</TT
> 명령은 표준 입력(stdin)으로 들어오는 내용을 지정한 크기로 나누어서 파일로 저장하는 기능을 제공한다.
     다음은 1MB 크기로 나눠서 덤프 파일을 생성하는 예제다:

</P><PRE
CLASS="PROGRAMLISTING"
>pg_dump <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> | split -b 1m - <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE
><P>

     복원 할 때는,

</P><PRE
CLASS="PROGRAMLISTING"
>cat <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>* | psql <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>
    </P
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>의 사용자 정의 포멧 기능을 이용하라. </B
>         만일 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 배포판을 빌드할 때, 
         <SPAN
CLASS="APPLICATION"
>zlib</SPAN
> 압축 라이브러를 사용할 수 있도록 했으면 
         덤프 파일을 만들 때 그 내용을 압축해서 만든다. 이 때 최종 덤프 파일은 
         <TT
CLASS="COMMAND"
>gzip</TT
> 프로그램으로 원본 덤프 파일을 압축 했을 때의
         크기만큼 줄일 수 있다. 또한 이 기능을 이용해서 백업을 하면 
         테이블을 선택적으로 지정해서 그 테이블만 복원할 수도 있다.
         다음은 사용자 정의 포멧을 지정해서 덤프 하는 예제다.

</P><PRE
CLASS="PROGRAMLISTING"
>pg_dump -Fc <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> &gt; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE
><P>

     이렇게 만들어진 덤프 파일은  <SPAN
CLASS="APPLICATION"
>psql</SPAN
>에서 사용할 수 있는 스크립트 파일이 아니다.
         그러므로 다음과 같이 <SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
> 명령을 사용해서 복원 해야한다.

</P><PRE
CLASS="PROGRAMLISTING"
>pg_restore -d <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></PRE
><P>

     자세한 사용법은 pg dump, pg restore 사용설명서를 참조하라.
    </P
></DIV
><P
>    엄청나게 큰 데이터베이스면 <TT
CLASS="COMMAND"
>split</TT
> 명령어와 함께 기타 다른 명령어들을 함께 연결해서 사용할 필요성도 있다.
   </P
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>의 병렬적 덤프 기능을 이용하라. . </B
>     대용량 데이터베이스의 덤프 속도를 높이기 위해서는 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>의 병렬 모드를 사용하면 된다. 
     그러면 테이블들을 동시에 덤프한다. 병렬 처리 수준은 <TT
CLASS="COMMAND"
>-j</TT
> 매개변수로 조절할 수 있다. 병렬적 덤프는 “디렉토리” 아카이브 형식에만 지원된다.

</P><PRE
CLASS="PROGRAMLISTING"
>pg_dump -j <TT
CLASS="REPLACEABLE"
><I
>num</I
></TT
> -F d -f <TT
CLASS="REPLACEABLE"
><I
>out.dir</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

     <TT
CLASS="COMMAND"
>pg_restore -j</TT
>를 이용해서 병렬적 덤프를 복구할 수 있다. 
     이 방식은 “사용자 정의” 혹은 “디렉터리” 아카이브 모드의 아카이브에서 가능하며 <TT
CLASS="COMMAND"
>pg_dump -j</TT
>로 만들어지지 않았어도 상관없다.
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="backup-file.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>백업과 복원</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>파일 시스템 기반 백업</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>