<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>로그 전달 복제에 대한 다른 방법</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="고가용성, 부하 분산, 복제"
HREF="high-availability.html"><LINK
REL="PREVIOUS"
TITLE="장애처리(failover)"
HREF="warm-standby-failover.html"><LINK
REL="NEXT"
TITLE="상시 대기"
HREF="hot-standby.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-30T08:52:27"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="장애처리(failover)"
HREF="warm-standby-failover.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 9. 고가용성, 부하 분산, 복제</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="상시 대기"
HREF="hot-standby.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LOG-SHIPPING-ALTERNATIVE"
>9.4. 로그 전달 복제에 대한 다른 방법</A
></H1
><P
>    운영 서버에서 사용했던 로그를 대기 서버로 보내서 
        복제 기능을 구현하는 방법은
        <TT
CLASS="VARNAME"
>restore_command</TT
> 설정값으로 지정한 명령으로 
        전달 된 파일을 자기 서버에 적용하고, 
        적용할 파일이 없으면 그 명령을 계속 반복하는 식이다.
        이 부분은 앞 장에서 구체적으로 설명했다. 
        여기서는 이 방법이 아닌 8.4 이하 버전에서도 사용할 수 있는 
        데이터베이스 복구 기능을 이용해서 독자적인 
        로그 전달 복제 기법을 설명한다.
        이렇게 하려면 대기 모드로 실행하지 않고 
        단순 복구 모드로 실행하도록 <TT
CLASS="VARNAME"
>standby_mode</TT
> 설정값을
        off로 지정해야한다.
        pg standby 모듈이 이 독자적인 복제 기능을 
        구현해 놓은 것이다.
   </P
><P
>    이 방식에서 주의해야할 점은, 
        운영 서버에서 만들어진 WAL 파일은 그것들이 만들어지는 순서에 따라 
        그대로 대기 서버로 반영 되어야한다는 점이다. 또한 반영 하는 작업은 
        반드시 직렬화 되어서 한 번에 하나의 파일만 적용해야한다.
        대기 서버에서 쿼리를 사용할 수 있게 설정 하면(Hot Standby 참조), 
        WAL 파일 적용 간격에 차이 때문에 자료가 정확하게 운영 서버와 같지 
        않다는 점도 기억해야한다. 
        이 대기 서버로의 자료 반영 지연 현상을 줄이려면, 
        <TT
CLASS="VARNAME"
>archive_timeout</TT
> 설정값을 짧게 하면 된다.
        또한 이 방식으로 구현하면, 스트리밍 방식 복제를 사용할 수 없다는 점도
        기억해야한다.
   </P
><P
>    기본 작동 방식은 일반적인 로그 전달, 복구 방식과 같다.
        트랜잭션 로그를 전달하는 방법은 WAL 레코드가 다 채워진 
        WAL 세그먼트 파일을 서로 전달하고, 받아서 사용하는 길 뿐이다.
        운영 서버에서 만드는 순차적인 WAL 세그먼트 파일들을 
        대기 서버로 옮길 때 누락되는 일이 없도록, 그리고 나중에 만들어진 파일이 
        이전에 만들어진 파일보다 먼저 대기 서버에 도착하는 일이 없도록
        해야한다. 또한 다른 운영 서버에서 만든 WAL 세그먼트 파일과 섞여 
        구분이 안되는 일이 없도록 해야한다.
        대기 기능만 구현하고자 한다면, WAL 파일 전달량은 그렇게 많지는 않다.
   </P
><P
>    복제 기능을 독자적으로 구현하는 열쇠는 <TT
CLASS="VARNAME"
>restore_command</TT
> 
        설정값에 있다. 이 값은 대기 서버가 실행할 때 사용하는 
        <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일 안에 <TT
CLASS="VARNAME"
>restore_command</TT
>
        서버 환경 변수 매개변수 값으로 지정한다.
        여기서 사용하는 명령은 서버가 처리해야하는 파일이 없으면 
        0 아닌 값을 리턴해서 복구 모드를 종료하고 
        일반적인 정상 운영 서버로 실행 되도록 한다. 
        하지만 복제용 대기 서버로 구축하려면
        이 명령은 원하는 파일이 없을 때 그 파일이 생길 때까지(운영 서버가 
        대기 서버로 보내줄 때까지) 기다리고 있다가, 파일이 생겼을 때 
        다시 대기 서버가 복구 작업을 계속 할 수 있어야한다.
        또한 <TT
CLASS="LITERAL"
>.backup</TT
>, <TT
CLASS="LITERAL"
>.history</TT
>이 운영 서버로부터 
        넘어 오면 그 파일은 무시하고, 0 아닌 값을 리턴하면서 이 명령을 끝내야한다.
        이렇게 설명한 모든 부분을 사용자가 직접 프로그래밍 해야한다.
        이 프로그램은 아울러, 장애처리를 위한 운영 역할로 전환할 수 있는 
        기능도 있어야하며, OS 시그널 처리도 있어야 한다.
   </P
><P
>    <TT
CLASS="VARNAME"
>restore_command</TT
> 설정값으로 사용될 프로그램의 의사코드는 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>triggered = false;
while (!NextWALFileReady() &amp;&amp; !triggered)
{
    sleep(100000L);         /* wait for ~0.1 sec */
    if (CheckForExternalTrigger())
        triggered = true;
}
if (!triggered)
        CopyWALFileForRecovery();</PRE
><P>
   </P
><P
>    이런 방식으로 구현된 실제 프로그램을 pg standby 모듈에서 
        제공한다.
        이 모듈은 위에서 설명한 구현 요소들을 모두 구현했다. 
        이 모듈과 함께 사용자 정의 스크립트들을 사용해서 구축할 수도 있을 것이다.
   </P
><P
>    어떻게 대기 서버가 운영 서버로 바뀔 것인가에 대한 설계는 
        꽤 중요한 부분이다. 이 또한 <TT
CLASS="VARNAME"
>restore_command</TT
> 값으로 지정하는 
        명령어에서 담당한다.
        단순하게 이 명령어의 리턴값이 0 아닌 값으로 종료되면 된다.
        0 아닌 값으로 종료되는 상황은 
        어떤 특정 파일이 생겼을 때, 또는 더 나아가 운영 서버가 응답이 없을 때 
        등등 발생할 수 있는 모든 상황을 꼼꼼히 살펴보고 그것을 구현하면 된다.
        문제는 이 명령어 실행은 서버가 각 개별 WAL 파일에 대해서 
    한 번 처리하고 종료되고 다시 실행하는 식으로 작동되기 때문에 
        서버 데몬과 달리 시그널 처리를 하기 힘들다. 그렇기 때문에 
        어떤 특정 파일을 만들어 장애처리 신호로 사용할 때 
        그 파일은 다른 프로세스가 만드는 것이 타당하다.
        한편, 운영 서버의  <TT
CLASS="VARNAME"
>archive_timeout</TT
> 값을 참조해서 
        원하는 WAL 파일이 넘어오지 않을 경우 다음 작업을 할 수 있는 
        시간 제한 기능을 둘 수도 있으나 이 때 네트워크 상태나 운영 서버의 부하 상태도 함께 고려해야한다.
    그렇게 하지 않으면 의도치 않게 장애처리 기능이 작동해서 상황을 더 악화시킬 수도 있다.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="WARM-STANDBY-CONFIG"
>9.4.1. 실행</A
></H2
><P
>    대기 서버 설정은 간단한 절차를 통해서 할 수 있다. 절차들의 세부 내용은 각 참조하는 절을 참고하라.
    <P
></P
></P><OL
TYPE="1"
><LI
><P
>       운영 서버와 대기 서버의 시스템을 최대한 똑같이 설정 하고, 각자 동일한 버전의 
       <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 사용한다. 
      </P
></LI
><LI
><P
>       운영 서버에서 대기 서버의 WAL 아카이브 디렉토리로 연속적인 아카이빙을 설정하라. 
       archive mode,
       archive command,
       archive timeout
       가 운영 서버에 적절하게 설정되도록 확인한다(<A
HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL"
>8.3.1절</A
>을 참조).
      </P
></LI
><LI
><P
>       운영 서버의 기본 백업을 만들고(<A
HREF="continuous-archiving.html#BACKUP-BASE-BACKUP"
>8.3.2절</A
>을 참조), 대기 서버에 데이터를 적재하라.
      </P
></LI
><LI
><P
>       이전에 설명한 것처럼(<A
HREF="continuous-archiving.html#BACKUP-PITR-RECOVERY"
>8.3.4절</A
>을 참조)
       <TT
CLASS="VARNAME"
>restore_command</TT
>가 명시된 <TT
CLASS="FILENAME"
>recovery.conf</TT
>로 지역 WAL 아카이브에서 대기 서버로의 복구 작업을 시작하라.
      </P
></LI
></OL
><P>
   </P
><P
>    복구 작업은 WAL 아카이브를 읽기 전용으로 처리하여, WAL 파일이 대기 서버 시스템에 복사 되면 테이프로 WAL 
    파일이 복사되어 데이터베이스 대기 서버가 동시에 읽을 수 있다. 
    이와 같이 대기 서버는 재난 복구를 목적으로 파일을 장기간 저장하면서 동시에 고가용성을 구현할 수 있다.
   </P
><P
>    테스트를 목적으로 운영 서버와 대기 서버를 같은 시스템에서 실행할 수 있다. 
    이 작업은 server robustness를 개선하지 않기 때문에 고가용성이라 하지 않는다. 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="WARM-STANDBY-RECORD"
>9.4.2. 레코드 기반의 로그 전달</A
></H2
><P
>    레코드 기반으로 로그를 전달하는 것도 가능한데, 사용자가 직접 개발을 해야 된다. 
    또, 전체 WAL 파일이 전달됐을 때에는 hot standby 쿼리에만 변경 사항이 보인다. 
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_xlogfile_name_offset()</CODE
> 함수
    를 호출해서 파일명과 현재 마지막 WAL의 정확한 바이트 오프셋을 구할 수 있다. 
    pg_xlogfile_name_offset 함수는 WAL 파일에 직접 접근할 수 있고 WAL 파일 마지막 데이터를 대기 서버에 복사할 수 있다. 
    이 방법을 쓰면 데이터 손실은 프로그램을 복사하는 폴링(polling) 순환 시기에 발생하는데, 
    손실은 매우 적고, 부분적으로 사용되는 세그먼트 파일을 강제로 아카이빙할 때 낭비하는 대역폭은 없다. 
    대기 서버의 <TT
CLASS="VARNAME"
>restore_command</TT
> 스크립트는 전체 WAL 파일을 다루므로, 점차적으로 
    복사된 데이터는 보통 대기 서버에서 사용할 수 없다. 이 데이터는 운영 서버가 죽었을 때만 사용되는데, 
    마지막 WAL 파일 부분이 대기 서버에 쓰이게 된다. 이 프로세스를 정확하게 실행하려면 
    데이터 복사 프로그램과 <TT
CLASS="VARNAME"
>restore_command</TT
> 스크립트의 조합이 필요하다.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.0 버전 이상은 스트리밍 리플리케이션
    (<A
HREF="warm-standby.html#STREAMING-REPLICATION"
>9.2.5절</A
>을 참조)으로 편리하게 할 수 있다.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="warm-standby-failover.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hot-standby.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>장애처리(failover)</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>상시 대기</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>