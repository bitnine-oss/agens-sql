<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>에러 리포팅 및 로깅</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="서버 환경 설정"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="쿼리 플랜"
HREF="runtime-config-query.html"><LINK
REL="NEXT"
TITLE="실시간 통계"
HREF="runtime-config-statistics.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T09:12:38"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="쿼리 플랜"
HREF="runtime-config-query.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 2. 서버 환경 설정</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="실시간 통계"
HREF="runtime-config-statistics.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-LOGGING"
>2.8. 에러 리포팅 및 로깅</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-LOGGING-WHERE"
>2.8.1. Where To 로그</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-LOG-DESTINATION"
></A
><TT
CLASS="VARNAME"
>log_destination</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
> 및 <SPAN
CLASS="SYSTEMITEM"
>csvlog</SPAN
>, 
<SPAN
CLASS="SYSTEMITEM"
>syslog</SPAN
>를 비롯한 서버 메시지를 로깅하는 몇 가지 메서드를 지원한다. 
Windows의 경우, <SPAN
CLASS="SYSTEMITEM"
>eventlog</SPAN
>로 지원한다. 원하는 로그 대상 목록을 쉼표로 구분하여 이 매개변수를 설정한다. 
기본값은 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>로만 로깅하는 것이다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
><SPAN
CLASS="SYSTEMITEM"
>csvlog</SPAN
>가 <TT
CLASS="VARNAME"
>log_destination</TT
>에 포함된 경우 로그 항목은 프로그램으로 로그를 로딩하기 편리한 
<SPAN
CLASS="QUOTE"
>"컴마로 구분된 값"</SPAN
>(CSV) 형식으로 출력된다. 
자세한 내용은 <A
HREF="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-CSVLOG"
>2.8.4절</A
>을 참조 바란다. 
CSV 형식 로그 출력을 사용으로 설정하려면 <A
HREF="runtime-config-logging.html#GUC-LOGGING-COLLECTOR"
>logging_collector</A
>를 사용으로 설정해야 한다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 대부분의 Unix 시스템에서 <TT
CLASS="VARNAME"
>log_destination</TT
> 옵션의 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>를 사용하려면 
 <SPAN
CLASS="SYSTEMITEM"
>syslog</SPAN
> 데몬의 환경 설정을 변경해야 한다. 
 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 기능 <TT
CLASS="LITERAL"
>LOCAL0</TT
> ~ <TT
CLASS="LITERAL"
>LOCAL7</TT
>(<A
HREF="runtime-config-logging.html#GUC-SYSLOG-FACILITY"
>syslog_facility</A
> 참조)로 로깅할 수 있지만 대부분의 플랫폼에서 기본값 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 환경 설정은 
 모든 해당 메시지를 취소한다. 
 이것이 작동되게 하려면 다음과 같은 문장을,
</P><PRE
CLASS="PROGRAMLISTING"
>local0.*/var/log/postgresql</PRE
><P>
 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 데몬의 환경 설정 파일에 추가해야 할 수 있다.</P
><P
> Windows에서 <TT
CLASS="VARNAME"
>log_destination</TT
>의 <TT
CLASS="LITERAL"
>eventlog</TT
> 옵션을 사용하는 경우 이벤트 소스와 라이브러리를 운영 체제에 등록해서 
 Windows 이벤트 뷰어가 이벤트 로그 메시지를 명확하게 표시하도록 해야 한다. 
 자세한 내용은 <A
HREF="event-log-registration.html"
>1.11절</A
>을 참조 바란다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOGGING-COLLECTOR"
></A
><TT
CLASS="VARNAME"
>logging_collector</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
> 이 매개변수는 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>로 전송된 로그 메시지를 캡처하여 로그 파일로 리다이렉트하는 <I
CLASS="FIRSTTERM"
>logging collector</I
> 
 백그라운드 프로세스를 활성화한다. 
 일부 메시지 유형은 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 출력에 나타나지 않을 수 있으므로 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>에 로깅하는 것보다 이 방법은 대체로 유용하다. 
 (공통된 예시 중 한 가지는 동적 링커 실패 메시지이고, 또 다른 예시는 <TT
CLASS="VARNAME"
>archive_command</TT
> 같은 스크립트에서 생성된 에러 메시지이다.) 
 이 매개변수는 서버 시작 시 설정 된다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> logging collector를 사용하지 않고 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>에 로깅하는 것이 가능하다. 
 서버의 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>가 다이렉트된 곳이면 어디든 로그 메시지가 출력된다. 
 그러나, 해당 메서드는 로그 파일을 로테이션하는 편리한 방법을 제공하지 않으므로 로그 양이 적을 때만 적당하다. 
 또한 logging collector를 사용하지 않는 일부 플랫폼은 여러 프로세스가 동일한 로그 파일에 동시에 쓰기 때문에 
 서로가 덮어쓰기 되므로 결과적으로 로그 출력이 왜곡되거나 분실된다.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>logging collector는 메시지 분실을 방지하는 용도로 고안되었다. 
이것은 부하가 매우 심한 경우에, 컬렉터가 뒤쳐졌을 경우 서버 프로세스가 추가 로그 메시지의 전송을 시도하면서 차단이 일어날 수 있다. 
반대로, 기록할 수 없을 때는 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>가 메시지를 드롭하는데, 
이것은 이러한 상황에서 일부 메시지를 로깅하는 데는 실패했지만 시스템의 나머지는 블로킹하지 않음을 의미한다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOG-DIRECTORY"
></A
><TT
CLASS="VARNAME"
>log_directory</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>logging_collector</TT
>를 사용으로 설정하면 이 매개변수는 로그 파일이 생성되는 디렉토리를 결정한다. 
절대 경로 또는 클러스터 데이터 디렉토리에 대한 상대 경로로 설정할 수 있다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 
기본값은 <TT
CLASS="LITERAL"
>pg_log</TT
>이다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-FILENAME"
></A
><TT
CLASS="VARNAME"
>log_filename</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>logging_collector</TT
>를 사용으로 설정하면 이 매개변수는 생성된 로그 파일의 파일 이름을 설정한다. 
값은 <CODE
CLASS="FUNCTION"
>strftime</CODE
> 패턴으로 처리되므로, <TT
CLASS="LITERAL"
>%</TT
> 이스케이프를 사용하여 시간에 따라 바뀌는 파일 이름을 지정할 수 있다. 
(시간대에 의존적인 <TT
CLASS="LITERAL"
>%</TT
> 이스케이프가 있을 경우 <A
HREF="runtime-config-logging.html#GUC-LOG-TIMEZONE"
>log_timezone</A
>에서 지정된 시간대로 계산된다.) 
지원되는 <TT
CLASS="LITERAL"
>%</TT
> 이스케이프는 Open Group의 <A
HREF="http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html"
TARGET="_top"
>strftime</A
> 규격에 등재된 것과 유사하다. 
시스템의 <SPAN
CLASS="SYSTEMITEM"
>strftime</SPAN
>이 직접 사용되지는 않으므로 플랫폼 특정(비표준) 확장자가 효력이 없다. 
기본값은 <TT
CLASS="LITERAL"
>postgresql-%Y-%m-%d_%H%M%S.log</TT
>이다.
 </P
><P
>이스케이프 없이 파일 이름을 지정하면 로그 로테이션 유틸리티를 사용하여 결국에는 전체 파일이 채워지는 것을 방지하는 계획을 세워야 한다. 
8.4 이전 버전에서, <TT
CLASS="LITERAL"
>%</TT
> 이스케이프가 사용되지 않으면 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 새 로그 파일 생성 시간 epoch를 추가했었는데, 이 기능은 사라졌다. 
 </P
><P
><TT
CLASS="VARNAME"
>log_destination</TT
>에서 CSV 형식 출력을 사용으로 설정한 경우 타임스탬프 로그 파일 이름 뒤에 
<TT
CLASS="LITERAL"
>.csv</TT
>가 추가되어 CSV 형식 출력 파일 이름이 만들어진다. 
(<TT
CLASS="VARNAME"
>log_filename</TT
>이 <TT
CLASS="LITERAL"
>.log</TT
>로 끝나는 경우 접미사가 대신 사용된다.)
 </P
><P
>이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-FILE-MODE"
></A
><TT
CLASS="VARNAME"
>log_file_mode</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>Unix 시스템에서, 이 매개변수는 <TT
CLASS="VARNAME"
>logging_collector</TT
>가 사용으로 설정된 경우 로그 파일에 대한 권한을 설정한다. 
(Microsoft Windows에서 이 매개변수는 무시된다.) 
매개변수 값은, <CODE
CLASS="FUNCTION"
>chmod</CODE
> 및 <CODE
CLASS="FUNCTION"
>umask</CODE
> 시스템 쉘에서 수용되는 형식으로 지정된 숫자 형식이어야 한다. 
(관례적인 8진수 형식을 사용하려면 <TT
CLASS="LITERAL"
>0</TT
>(영)으로 시작되는 숫자여야 한다.)
 </P
><P
>기본 권한은, 서버 소유자만 로그 파일을 읽거나 쓸 수 있는 <TT
CLASS="LITERAL"
>0600</TT
>이다. 일반적으로 유용한 다른 설정은, 
소유자 그룹의 멤버가 파일을 읽을 수 있는 <TT
CLASS="LITERAL"
>0640</TT
>이다. 
그러나, 해당 설정을 사용하려면 클러스터 데이터 디렉토리 바깥에서도 파일을 저장하도록 <A
HREF="runtime-config-logging.html#GUC-LOG-DIRECTORY"
>log_directory</A
>를 변경해야 한다. 
로그 파일에 중요한 데이터가 포함되어 있을 수도 있으므로 어떤 경우든 로그 파일을 누구나 읽을 수 있게 하는 것은 현명하지 못하다.
 </P
><P
>이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-ROTATION-AGE"
></A
><TT
CLASS="VARNAME"
>log_rotation_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>logging_collector</TT
>를 사용으로 설정하면 이 매개변수는 개별 로그 파일의 최대 수명을 결정한다. 
여기서 지정된 분 시간이 경과된 후 새로운 로그 파일이 생성된다. 
시간을 기준으로 새 로그 파일을 생성하지 않으려면 0으로 설정한다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-ROTATION-SIZE"
></A
><TT
CLASS="VARNAME"
>log_rotation_size</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>logging_collector</TT
>를 사용으로 설정하면 이 매개변수는 개별 로그 파일의 최대 크기를 결정한다. 
여기서 지정된 킬로바이트가 로그 파일에 방출된 후 새로운 로그 파일이 생성된다. 
크기를 기준으로 새 로그 파일을 생성하지 않으려면 0으로 설정한다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-TRUNCATE-ON-ROTATION"
></A
><TT
CLASS="VARNAME"
>log_truncate_on_rotation</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>logging_collector</TT
>가 사용으로 설정된 경우 이 매개변수에 의해 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>가 이름이 동일한 기존 로그 파일에 추가하는 것이 아니라 파일을 비운다(덮어쓰기). 
단, 비우기는 서버 시작 시 또는 크기 기준 로테이션이 아니라 시간 기준 로테이션에 의해 새 파일이 열린 경우에만 실행된다. 
off인 경우에는 모든 경우에 기존 파일이 추가된다. 
예를 들면, <TT
CLASS="LITERAL"
>postgresql-%H.log</TT
> 같은 <TT
CLASS="VARNAME"
>log_filename</TT
>과 함께 이 설정을 사용하면 24시간마다 
로그 파일을 생성하고 주기적으로 덮어쓰기 된다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
>예: 7일간 로그를 유지하고, 1일 1로그 파일의 이름을 <TT
CLASS="LITERAL"
>server_log.Mon</TT
>, <TT
CLASS="LITERAL"
>server_log.Tue</TT
> 등으로 명명하고, 
마지막 주의 로그를 이 주의 로그로 자동 덮어쓰기 하려면 <TT
CLASS="VARNAME"
>log_filename</TT
>은 <TT
CLASS="LITERAL"
>server_log.%a</TT
>로 설정하고, 
<TT
CLASS="VARNAME"
>log_truncate_on_rotation</TT
>은 <TT
CLASS="LITERAL"
>on</TT
>으로 설정하고, <TT
CLASS="VARNAME"
>log_rotation_age</TT
>는 
<TT
CLASS="LITERAL"
>1440</TT
>으로 설정해야 한다.
 </P
><P
>예: 24시간 로그를 유지하고, 1시간당 1개 로그 파일을 생성하되, 로그 파일 크기가 1GB를 초과하면 곧장 로테이션되게 하려면 
<TT
CLASS="VARNAME"
>log_filename</TT
>은 <TT
CLASS="LITERAL"
>server_log.%H%M</TT
>으로 설정하고, <TT
CLASS="VARNAME"
>log_truncate_on_rotation</TT
>은 
<TT
CLASS="LITERAL"
>on</TT
>으로 설정하고, <TT
CLASS="VARNAME"
>log_rotation_age</TT
>는 <TT
CLASS="LITERAL"
>60</TT
>으로 설정하고, 
<TT
CLASS="VARNAME"
>log_rotation_size</TT
>는 <TT
CLASS="LITERAL"
>1000000</TT
>으로 설정해야 한다. 
<TT
CLASS="VARNAME"
>log_filename</TT
> 파일에서 <TT
CLASS="LITERAL"
>%M</TT
>을 포함하면 크기 구동 로테이션으로 
시간의 초기 파일 이름과는 다른 파일 이름이 선택되도록 할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-SYSLOG-FACILITY"
></A
><TT
CLASS="VARNAME"
>syslog_facility</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>syslog</SPAN
>에 로깅하도록 설정된 경우 이 매개변수는 사용할 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> <SPAN
CLASS="QUOTE"
>"facility"</SPAN
>를 결정한다.
<TT
CLASS="LITERAL"
>LOCAL2</TT
>, <TT
CLASS="LITERAL"
>LOCAL3</TT
>, <TT
CLASS="LITERAL"
>LOCAL4</TT
>,
<TT
CLASS="LITERAL"
>LOCAL5</TT
>, <TT
CLASS="LITERAL"
>LOCAL6</TT
>, <TT
CLASS="LITERAL"
>LOCAL7</TT
> 중에서 선택할 수 있으며, 기본값은 <TT
CLASS="LITERAL"
>LOCAL0</TT
>이다. 
시스템의 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 데몬에 관한 문서를 참조하기 바란다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-SYSLOG-IDENT"
></A
><TT
CLASS="VARNAME"
>syslog_ident</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
> <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>에 로깅하도록 설정된 경우 이 매개변수는 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
> 로그에서 
 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 메시지를 식별하기 위해 사용되는 프로그램 이름을 결정한다. 기본값은 <TT
CLASS="LITERAL"
>postgres</TT
>이다. 
 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.</P
></DD
><DT
><A
NAME="GUC-EVENT-SOURCE"
></A
><TT
CLASS="VARNAME"
>event_source</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>event log</SPAN
>에 로깅하도록 설정된 경우 이 매개변수는 syslog 로그에서 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 메시지를 식별하기 위해 사용되는 프로그램 이름을 결정한다. 
기본값은 <TT
CLASS="LITERAL"
>Agens SQL</TT
>이다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-LOGGING-WHEN"
>2.8.2. When To 로그</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-CLIENT-MIN-MESSAGES"
></A
><TT
CLASS="VARNAME"
>client_min_messages</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>클라이언트로 전송할 메시지 레벨을 제어한다. 유효 값은 <TT
CLASS="LITERAL"
>DEBUG5</TT
> 및 
<TT
CLASS="LITERAL"
>DEBUG4</TT
>, <TT
CLASS="LITERAL"
>DEBUG3</TT
>, <TT
CLASS="LITERAL"
>DEBUG2</TT
>, 
<TT
CLASS="LITERAL"
>DEBUG1</TT
>, <TT
CLASS="LITERAL"
>LOG</TT
>, <TT
CLASS="LITERAL"
>NOTICE</TT
>, 
<TT
CLASS="LITERAL"
>WARNING</TT
>, <TT
CLASS="LITERAL"
>ERROR</TT
>, <TT
CLASS="LITERAL"
>FATAL</TT
>, 
<TT
CLASS="LITERAL"
>PANIC</TT
>이다. 각 레벨에는 이전 레벨들을 모두 포함한다.
레벨이 뒤로 갈수록 메시지가 로그에 적게 전송된다. 기본값은 <TT
CLASS="LITERAL"
>NOTICE</TT
>이다. 
여기서 <TT
CLASS="LITERAL"
>LOG</TT
> 순위는 <TT
CLASS="VARNAME"
>log_min_messages</TT
>에서의 순위와 다르다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-MIN-MESSAGES"
></A
><TT
CLASS="VARNAME"
>log_min_messages</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>서버 로그에 기록할 메시지 레벨을 제어한다. 유효 값은 <TT
CLASS="LITERAL"
>DEBUG5</TT
> 및 <TT
CLASS="LITERAL"
>DEBUG4</TT
>,
<TT
CLASS="LITERAL"
>DEBUG3</TT
>, <TT
CLASS="LITERAL"
>DEBUG2</TT
>, <TT
CLASS="LITERAL"
>DEBUG1</TT
>,
<TT
CLASS="LITERAL"
>INFO</TT
>, <TT
CLASS="LITERAL"
>NOTICE</TT
>, <TT
CLASS="LITERAL"
>WARNING</TT
>,
<TT
CLASS="LITERAL"
>ERROR</TT
>, <TT
CLASS="LITERAL"
>LOG</TT
>, <TT
CLASS="LITERAL"
>FATAL</TT
>, and
<TT
CLASS="LITERAL"
>PANIC</TT
>이다. 각 레벨에는 이전 레벨들을 모두 포함한다.
레벨이 뒤로 갈수록 메시지가 로그에 적게 전송된다. 
기본값은 <TT
CLASS="LITERAL"
>WARNING</TT
>이다. 여기서 <TT
CLASS="LITERAL"
>LOG</TT
> 순위는 <TT
CLASS="VARNAME"
>log_min_messages</TT
>에서의 순위와 다르다.
수퍼유저만 이 설정을 변경할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-MIN-ERROR-STATEMENT"
></A
><TT
CLASS="VARNAME"
>log_min_error_statement</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>에러 상태를 유발한 SQL 문 중에 어떤 SQL문이 서버 로그에 기록될 지를 제어한다. 
메시지가 지정된 심각도 이상인 경우 해당 SQL 문이 로그 항목에 포함된다. 
유효 값은 <TT
CLASS="LITERAL"
>DEBUG5</TT
> 및 
<TT
CLASS="LITERAL"
>DEBUG4</TT
>, <TT
CLASS="LITERAL"
>DEBUG3</TT
>,
<TT
CLASS="LITERAL"
>DEBUG2</TT
>, <TT
CLASS="LITERAL"
>DEBUG1</TT
>,
<TT
CLASS="LITERAL"
>INFO</TT
>, <TT
CLASS="LITERAL"
>NOTICE</TT
>,
<TT
CLASS="LITERAL"
>WARNING</TT
>, <TT
CLASS="LITERAL"
>ERROR</TT
>,
<TT
CLASS="LITERAL"
>LOG</TT
>,
<TT
CLASS="LITERAL"
>FATAL</TT
>, <TT
CLASS="LITERAL"
>PANIC</TT
>이다. 
기본값은 에러 또는 로그 메시지, 심각한 에러, 패닉을 유발한 구문(statement)을 로깅하는 <TT
CLASS="LITERAL"
>ERROR</TT
>이다. 
실패하는 구문의 로깅을 효율적으로 해제하려면 이 매개변수를 <TT
CLASS="LITERAL"
>PANIC</TT
>으로 설정해야 한다. 수퍼유저만 이 설정을 변경할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-MIN-DURATION-STATEMENT"
></A
><TT
CLASS="VARNAME"
>log_min_duration_statement</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
> 최소한 지정된 밀리 초 동안 구문이 실행된 경우 완료된 구문별로 지속 시간이 로깅되게 한다. 
 이것을 0으로 설정하면 모든 구문의 기간이 인쇄된다. -1(기본값)은 로깅되는 구문 기간을 비활성화한다. 
 예를 들어, <TT
CLASS="LITERAL"
>250ms</TT
>로 설정하면 250ms 이상 실행된 모든 SQL문이 로깅된다. 
 이 매개변수를 활성화하면 애플리케이션에서 최적화되지 않은 쿼리를 찾아내는 데 도움이 된다. 수퍼유저만 이 설정을 변경할 수 있다.</P
><P
> 확장 쿼리 프로토콜을 사용하는 클라이언트의 경우 Parse 및 Bind, Execute 단계의 지속 시간이 각각 로깅된다.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 이 옵션을 <A
HREF="runtime-config-logging.html#GUC-LOG-STATEMENT"
>log_statement</A
>와 함께 사용하면 로그 메시지 지연 시간에 <TT
CLASS="VARNAME"
>log_statement</TT
>가 반복되지 않으므로 
 구문 텍스트가 로깅되지 않는다. 
 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>를 사용하지 않는 경우 프로세스 ID 또는 세션 ID를 사용하여 
 구문 메시지를 추후 지연 시간 메시지에 연결할 수 있도록 <A
HREF="runtime-config-logging.html#GUC-LOG-LINE-PREFIX"
>log_line_prefix</A
>를 사용하여 PID 또는 세션 ID를 로깅하는 것이 좋다.</P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
><P
> <A
HREF="runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS"
>표 2-1</A
>은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 사용되는 메시지 심각도 레벨을 설명한다. 
 로깅 출력이 <SPAN
CLASS="SYSTEMITEM"
>syslog</SPAN
> 또는 Windows의 <SPAN
CLASS="SYSTEMITEM"
>eventlog</SPAN
>에 전송되는 경우 
 심각도 레벨은 표에 나타난 대로 해석된다.</P
><DIV
CLASS="TABLE"
><A
NAME="RUNTIME-CONFIG-SEVERITY-LEVELS"
></A
><P
><B
>표 2-1. 메시지 심각도 레벨</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>심각도</TH
><TH
>용도</TH
><TH
><SPAN
CLASS="SYSTEMITEM"
>syslog</SPAN
></TH
><TH
><SPAN
CLASS="SYSTEMITEM"
>eventlog</SPAN
></TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>DEBUG1..DEBUG5</TT
></TD
><TD
>개발자를 위한 상세 정보를 제공한다.</TD
><TD
><TT
CLASS="LITERAL"
>DEBUG</TT
></TD
><TD
><TT
CLASS="LITERAL"
>INFORMATION</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>INFO</TT
></TD
><TD
><TT
CLASS="COMMAND"
>VACUUM VERBOSE</TT
>로부터 출력 같은 사용자가 암시적으로 요청한 정보를 제공한다.</TD
><TD
><TT
CLASS="LITERAL"
>INFO</TT
></TD
><TD
><TT
CLASS="LITERAL"
>INFORMATION</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>NOTICE</TT
></TD
><TD
>긴 식별자 잘라내기에 대한 공지 같이 사용자에게 유익한 정보가 제공된다.</TD
><TD
><TT
CLASS="LITERAL"
>NOTICE</TT
></TD
><TD
><TT
CLASS="LITERAL"
>INFORMATION</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>WARNING</TT
></TD
><TD
>트랜잭션 블록 외부로 <TT
CLASS="COMMAND"
>COMMIT</TT
> 같은 문제의 가능성이 있는 경고를 제공한다.</TD
><TD
><TT
CLASS="LITERAL"
>NOTICE</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WARNING</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ERROR</TT
></TD
><TD
>현재 명령이 중단된 원인이 되는 에러를 알려준다.</TD
><TD
><TT
CLASS="LITERAL"
>WARNING</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ERROR</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>LOG</TT
></TD
><TD
> 체크포인트 작업 같이 관리자가 관심 있어 할 정보를 알려준다.</TD
><TD
><TT
CLASS="LITERAL"
>INFO</TT
></TD
><TD
><TT
CLASS="LITERAL"
>INFORMATION</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>FATAL</TT
></TD
><TD
>현재 세션이 중단된 원인이 되는 에러를 알려준다.</TD
><TD
><TT
CLASS="LITERAL"
>ERR</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ERROR</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>PANIC</TT
></TD
><TD
>모든 데이터베이스 세션이 중단된 원인이 되는 에러를 알려준다.</TD
><TD
><TT
CLASS="LITERAL"
>CRIT</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ERROR</TT
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-LOGGING-WHAT"
>2.8.3. What To 로그</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-APPLICATION-NAME"
></A
><TT
CLASS="VARNAME"
>application_name</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="VARNAME"
>application_name</TT
>은 <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
> 글자 수(표준 빌드에서 64자) 이내의 string일 수 있다. 
이것은 일반적으로 서버 연결 시 애플리케이션에 의해 설정된다. 
이름은 <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> 뷰에 표시되고 CSV 로그 항목에 포함된다. 
<A
HREF="runtime-config-logging.html#GUC-LOG-LINE-PREFIX"
>log_line_prefix</A
> 매개변수를 통해 일반 로그 항목에 포함될 수도 있다. 
인쇄 가능한 ASCII 문자만 <TT
CLASS="VARNAME"
>application_name</TT
> 값으로 사용된다. 
다른 문자는 물음표(<TT
CLASS="LITERAL"
>?</TT
>)로 대체된다.
 </P
></DD
><DT
><TT
CLASS="VARNAME"
>debug_print_parse</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
<BR><TT
CLASS="VARNAME"
>debug_print_rewritten</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
<BR><TT
CLASS="VARNAME"
>debug_print_plan</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>이 매개변수는 다양한 디버깅 출력을 활성화한다. 
설정된 경우 결과로 나온 파싱 트리 또는 쿼리 재작성 출력, 실행된 각 쿼리별로 실행 플랜이 인쇄된다. 
이 메시지는 <TT
CLASS="LITERAL"
>LOG</TT
> 메시지 수준으로 출력되므로 기본적으로 서버 로그에 나타나지만 클라이언트로 전송되지는 않는다. 
<A
HREF="runtime-config-logging.html#GUC-CLIENT-MIN-MESSAGES"
>client_min_messages</A
> 및/또는 <A
HREF="runtime-config-logging.html#GUC-LOG-MIN-MESSAGES"
>log_min_messages</A
>를 조절하여 변경할 수 있다. 
이 매개변수의 기본값은 off이다.
 </P
></DD
><DT
><TT
CLASS="VARNAME"
>debug_pretty_print</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>설정된 경우, <TT
CLASS="VARNAME"
>debug_pretty_print</TT
>는 <TT
CLASS="VARNAME"
>debug_print_parse</TT
> 또는 <TT
CLASS="VARNAME"
>debug_print_rewritten</TT
>, 
<TT
CLASS="VARNAME"
>debug_print_plan</TT
>에 의해 생성된 메시지를 들여쓰기 한다. 
따라서 가독성이 증가하는 대신, off로 설정된 경우의 <SPAN
CLASS="QUOTE"
>"compact"</SPAN
> 형식보다 출력이 길어진다. 기본값은 on이다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-CHECKPOINTS"
></A
><TT
CLASS="VARNAME"
>log_checkpoints</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
> 체크포인트들 및 재시작포인트들(restartpoints)이 서버 로그에 로깅되게 한다. 
 일부 통계는 작성된 버퍼 수 및 작성할 때 소요된 시간을 비롯한 로그 메시지에 포함된다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 기본값은 off이다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-CONNECTIONS"
></A
><TT
CLASS="VARNAME"
>log_connections</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>서버로의 각 연결 시도 및 성공한 클라이언트 인증 완료가 로깅되게 한다. 이 매개변수는 세션 시작 후에는 변경할 수 없다. 기본값은 off이다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 같은 일부 클라이언트 프로그램은 패스워드가 필수인지 판단하면서 
 2번 연결을 시도하므로<SPAN
CLASS="QUOTE"
>"connection received"</SPAN
> 메시지가 중복되어 나타나도 문제를 뜻하지는 않는다. </P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOG-DISCONNECTIONS"
></A
><TT
CLASS="VARNAME"
>log_disconnections</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>이것은 세션을 중단할 때 외에는 <TT
CLASS="VARNAME"
>log_connections</TT
>와 유사하게 서버 로그에 한 줄을 출력하고 세션의 지속 시간을 포함한다. 
기본값은 off이다. 이 매개변수는 세션 시작 후에는 변경할 수 없다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-DURATION"
></A
><TT
CLASS="VARNAME"
>log_duration</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>완료된 모든 문의 지속 시간이 로깅 되게 한다. 기본값은 <TT
CLASS="LITERAL"
>off</TT
>이다. 수퍼유저만 이 설정을 변경할 수 있다.
 </P
><P
>확장 쿼리 프로토콜을 사용하는 클라이언트의 경우 Parse 및 Bind, Execute 단계의 지속 시간이 각각 로깅된다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 이 옵션과 <A
HREF="runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT"
>log_min_duration_statement</A
>를 0으로 설정하는 것의 차이는 
 <TT
CLASS="VARNAME"
>log_min_duration_statement</TT
>를 초과하면 쿼리 텍스트가 강제로 로깅되지만, 이 옵션은 그렇지 않다는 것이다. 
 따라서 <TT
CLASS="VARNAME"
>log_duration</TT
>이 <TT
CLASS="LITERAL"
>on</TT
>으로 설정되고 <TT
CLASS="VARNAME"
>log_min_duration_statement</TT
>가 양의 값을 갖는 경우 
 모든 지속 시간이 로깅되지만 쿼리 텍스트는 임계값을 초과하는 문인 경우에만 포함된다. 
 이러한 동작은 고부하 설치에서 통계를 수집할 때 유용하다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOG-ERROR-VERBOSITY"
></A
><TT
CLASS="VARNAME"
>log_error_verbosity</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>로깅된 각 메시지에 대해 서버 로그에 작성되는 상세 내역을 제어한다. 유효 값은, 각각 메시지에 표시되는 필드를 나타내는 <TT
CLASS="LITERAL"
>TERSE</TT
> 및 
<TT
CLASS="LITERAL"
>DEFAULT</TT
>, <TT
CLASS="LITERAL"
>VERBOSE</TT
>이다. 
<TT
CLASS="LITERAL"
>TERSE</TT
>는 <TT
CLASS="LITERAL"
>DETAIL</TT
> 및 <TT
CLASS="LITERAL"
>HINT</TT
>,
<TT
CLASS="LITERAL"
>QUERY</TT
>, <TT
CLASS="LITERAL"
>CONTEXT</TT
> 에러 정보의 로깅을 제외한다. 
<TT
CLASS="LITERAL"
>VERBOSE</TT
> 출력은 <TT
CLASS="SYMBOL"
>SQLSTATE</TT
> 에러 코드 및 소스 코드 파일 이름, 함수 이름 및 에러 발생 줄 번호를 포함한다. 
수퍼유저만 이 설정을 변경할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-HOSTNAME"
></A
><TT
CLASS="VARNAME"
>log_hostname</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>기본적으로, 연결 로그 메시지는 연결 호스트의 IP 주소만 표시한다. 이 매개변수를 활성화하면 호스트 이름도 로깅된다. 
호스트 이름 설정에 따라 이것이 상당한 성능을 요구한다.
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-LINE-PREFIX"
></A
><TT
CLASS="VARNAME"
>log_line_prefix</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
> 이것은 각 로그 줄의 처음에 출력되는 <CODE
CLASS="FUNCTION"
>printf</CODE
> 스타일 string이다. 
 <TT
CLASS="LITERAL"
>%</TT
> 문자는 <SPAN
CLASS="QUOTE"
>"이스케이프 시퀀스"</SPAN
>로 시작되며 아래 요약된 상태 정보로 대체된다. 미인식 이스케이프는 무시된다. 
 다른 문자는 로그 줄에 직접 복사된다. 
 일부 이스케이프는 세션 프로세스만 인식 하고, 메인 서버 프로세스 같은 백그라운드 프로세스는 빈 것으로 처리한다.
 상태 정보는 % 뒤, 옵션 앞에 숫자 리터럴을 지정함으로써 왼쪽 또는 오른쪽에 정렬될 수 있다. 
 음의 값은 최소 너비를 갖도록 상태 정보를 오른쪽에서 공백으로 채우고, 양의 값은 왼쪽에서 공백으로 채운다. 
 패딩(padding)은 로그 파일의 가독성을 늘릴 때 유용하다. 
 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 
 기본값은 비어 있는 string이다.
 <DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN3622"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Escape</TH
><TH
>Effect</TH
><TH
>Session only</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>%a</TT
></TD
><TD
>애플리케이션 이름</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%u</TT
></TD
><TD
>사용자 이름</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%d</TT
></TD
><TD
>데이터베이스 이름</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%r</TT
></TD
><TD
>원격 호스트 이름 또는 IP 주소 및 원격 포트</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%h</TT
></TD
><TD
>원격 호스트 이름 또는 IP 주소</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%p</TT
></TD
><TD
>프로세스 ID</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%t</TT
></TD
><TD
>밀리초 없는 타임스탬프</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%m</TT
></TD
><TD
>밀리초 있는 타임스탬프</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%i</TT
></TD
><TD
>명령 태그: 세션의 현재 명령 유형</TD
><TD
>yes</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%e</TT
></TD
><TD
>SQLSTATE 에러 코드</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%c</TT
></TD
><TD
>세션 ID: 아래 참조</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%l</TT
></TD
><TD
>1부터 시작하는 각 세션 또는 프로세스의 로그 줄 번호</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%s</TT
></TD
><TD
>프로세스 시작 타임스탬프</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%v</TT
></TD
><TD
>가상 트랜잭션 ID(backendID/localXID)</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%x</TT
></TD
><TD
>트랜잭션 ID(아무것도 할당되지 않은 경우 0)</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%q</TT
></TD
><TD
>출력은 하지 않지만 이 시점에서 중단을 위한 비 세션 프로세스를 표시하며, 세션 프로세스에 의해 무시된다.</TD
><TD
>no</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>%%</TT
></TD
><TD
>리터럴 <TT
CLASS="LITERAL"
>%</TT
></TD
><TD
>no</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
 <TT
CLASS="LITERAL"
>%c</TT
> 이스케이프는 점으로 구분된 4바이트 16진수(선행 0 없음) 2개로 환경 설정되는 의사 고유(quasi-unique) 세션을 인쇄한다. 
 숫자는 프로세스 시작 시간 및 프로세스 ID이므로 해당 항목의 인쇄 공간 절약 방법으로 <TT
CLASS="LITERAL"
>%c</TT
>를 사용할 수도 있다. 
 예를 들면, <TT
CLASS="LITERAL"
>pg_stat_activity</TT
>의 세션 식별자를 생성하려면 아래 쿼리를 사용한다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT to_hex(EXTRACT(EPOCH FROM backend_start)::integer) || '.' ||
 to_hex(pid)
FROM pg_stat_activity;</PRE
><P>

 </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
> <TT
CLASS="VARNAME"
>log_line_prefix</TT
>에 비어 있지 않은 값을 설정하면 보통은 마지막 문자가 공백이 되도록 해서 로그 줄의 나머지와 
 육안상 구분이 되게 해야 한다. 
 문장 부호를 사용할 수도 있다.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
> <SPAN
CLASS="APPLICATION"
>Syslog</SPAN
>는 자체 타임스탬프와 프로세스 ID 정보를 생성하므로 <SPAN
CLASS="APPLICATION"
>syslog</SPAN
>에 로깅하는 경우 
 사용자는 이러한 이스케이프를 포함하는 것을 원하지 않을 수도 있다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOG-LOCK-WAITS"
></A
><TT
CLASS="VARNAME"
>log_lock_waits</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>잠금 획득을 위해 세션이 <A
HREF="runtime-config-locks.html#GUC-DEADLOCK-TIMEOUT"
>deadlock_timeout</A
> 이상 대기한 경우 로그 메시지를 생성할 것인지를 제어한다. 
잠금 대기가 성능 저하의 원인이 되는지를 판단할 때 유용하다. 기본값은 <TT
CLASS="LITERAL"
>off</TT
>이다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-STATEMENT"
></A
><TT
CLASS="VARNAME"
>log_statement</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)&#13;</DT
><DD
><P
>로깅할 SQL 문을 제어한다. 유효 값은 <TT
CLASS="LITERAL"
>none</TT
>(off), <TT
CLASS="LITERAL"
>ddl</TT
>, <TT
CLASS="LITERAL"
>mod</TT
>, <TT
CLASS="LITERAL"
>all</TT
>(모든 구문)이다. 
<TT
CLASS="LITERAL"
>ddl</TT
>은 <TT
CLASS="COMMAND"
>CREATE</TT
> 및 <TT
CLASS="COMMAND"
>ALTER</TT
>, 
<TT
CLASS="COMMAND"
>DROP</TT
>문 같은 모든 데이터 정의문을 로깅한다. 
<TT
CLASS="LITERAL"
>mod</TT
>는 모든 <TT
CLASS="LITERAL"
>ddl</TT
>문과 <TT
CLASS="COMMAND"
>INSERT</TT
> 및
<TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>, <TT
CLASS="COMMAND"
>TRUNCATE</TT
>, <TT
CLASS="COMMAND"
>COPY FROM</TT
>같은 데이터 수정문을 로깅한다. 
<TT
CLASS="COMMAND"
>PREPARE</TT
> 및 <TT
CLASS="COMMAND"
>EXECUTE</TT
>, 
<TT
CLASS="COMMAND"
>EXPLAIN ANALYZE</TT
>문도 포함된 명령이 적절한 타입인 경우 로깅된다. 
확장 쿼리 프로토콜을 사용하는 클라이언트의 경우 Execute 메시지를 수신하면 로깅이 발생되고, 
Bind 매개변수의 값이 포함된다(작은따옴표를 겹쳐서 사용).
 </P
><P
>기본값은 none이다. 수퍼유저만 이 설정을 변경할 수 있다.
 </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 기본 파싱이 완료되어 문 타입이 결정된 후에만 로그 메시지가 발생되므로 
 <TT
CLASS="VARNAME"
>log_statement</TT
> = <TT
CLASS="LITERAL"
>all</TT
> 설정에 의해서도 간단한 구문 에러가 포함된 구문은 로깅되지 않는다. 
 확장 쿼리 프로토콜의 경우 이 설정은 Execute 단계 전에 실패한 구문을 로깅하지 않는다(예: 파싱 분석 또는 플래닝 도중). 
 해당 구문을 로깅하려면 <TT
CLASS="VARNAME"
>log_min_error_statement</TT
>를 <TT
CLASS="LITERAL"
>ERROR</TT
>(또는 그 이상)로 설정해야 한다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-LOG-TEMP-FILES"
></A
><TT
CLASS="VARNAME"
>log_temp_files</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>임시 파일 이름과 크기의 로깅을 제어한다. 정렬, 해시 및 임시 쿼리 결과를 위해 임시 파일을 생성할 수 있다. 
로그는 각 임시 파일이 삭제된 경우 입력된다. 
0 값은 모든 임시 파일 정보를 로깅하고, 양의 값은 크기가 지정된 킬로바이트 이상일 때만 로깅된다. 
기본값은, 해당 로깅이 비활성화되는 -1이다. 수퍼유저만 이 설정을 변경할 수 있다.
 </P
></DD
><DT
><A
NAME="GUC-LOG-TIMEZONE"
></A
><TT
CLASS="VARNAME"
>log_timezone</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
>서버 로그에 작성되는 타임스탬프에 사용할 시간대를 설정한다. <A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>TimeZone</A
>과 달리, 
이 값은 클러스터 차원(cluster-wide)의 값이므로 모든 세션이 일관되게 타임스탬프를 알려준다. 
내장 기본값은 <TT
CLASS="LITERAL"
>GMT</TT
>이지만, 일반적으로 <TT
CLASS="FILENAME"
>postgresql.conf</TT
>에 오버라이드되고 
<SPAN
CLASS="APPLICATION"
>initdb</SPAN
>는 시스템 환경에 해당되는 곳에 설정을 설치한다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-LOGGING-CSVLOG"
>2.8.4. CSV 형식 로그 출력 사용</A
></H2
><P
><TT
CLASS="VARNAME"
>log_destination</TT
> 목록에서 <TT
CLASS="LITERAL"
>csvlog</TT
>를 포함하면 로그 파일을 데이터베이스 테이블에 편리하게 가져올 수 있다. 
이 옵션은 쉼표로 구분된 값(<ACRONYM
CLASS="ACRONYM"
>CSV</ACRONYM
>) 형식으로 로그 줄을 출력하며, 밀리초의 타임스탬프 및 사용자 이름, 데이터베이스 이름, 
프로세스 ID, 클라이언트 호스트:포트 번호, 세션 ID, 세션별 줄 번호, 명령 태그, 세션 시작 시간, 
가상 트랜잭션 ID, 일반 트랜잭션 ID, 에러 심각도, SQLSTATE 코드, 에러 메시지, 에러 메시지 상세, 힌트, 에러 유발 내부 쿼리(있을 경우), 
에러 위치의 문자 카운트, 에러 문맥, 에러 유발 사용자 쿼리(있을 경우 및 <TT
CLASS="VARNAME"
>log_min_error_statement</TT
>에서 활성화된 경우), 
에러 위치의 문자 카운트, Agens SQL 소스 코드에서 에러의 위치(<TT
CLASS="VARNAME"
>log_error_verbosity</TT
>가 <TT
CLASS="LITERAL"
>verbose</TT
>로 설정된 경우), 
애플리케이션 이름의 칼럼으로 환경 설정되어 있다. CSV 형식 로그 파일 출력을 저장하기 위한 샘플 테이블 정의는 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE postgres_log
(
log_time timestamp(3) with time zone,
user_name text,
database_name text,
process_id integer,
connection_from text,
session_id text,
session_line_num bigint,
command_tag text,
session_start_time timestamp with time zone,
virtual_transaction_id text,
transaction_id bigint,
error_severity text,
sql_state_code text,
message text,
detail text,
hint text,
internal_query text,
internal_query_pos integer,
context text,
query text,
query_pos integer,
location text,
application_name text,
PRIMARY KEY (session_id, session_line_num)
);</PRE
><P>
 </P
><P
>로그 파일을 이 테이블로 가져오려면 <TT
CLASS="COMMAND"
>COPY FROM</TT
> 명령을 사용해야 한다.
</P><PRE
CLASS="PROGRAMLISTING"
>COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;</PRE
><P>
 </P
><P
> CSV 로그 파일 가져오기를 단순화하려면 몇 가지 작업이 필요하다.
 <P
></P
></P><OL
TYPE="1"
><LI
><P
>로그 파일에 대한 일관되고, 예측 가능한 네이밍 체계를 제공하려면 <TT
CLASS="VARNAME"
>log_filename</TT
> 및 <TT
CLASS="VARNAME"
>log_rotation_age</TT
>를 설정해야 한다. 
이로써 사용자는 파일 이름과 개별 로그 파일이 완료되는 시점을 예상할 수 있으므로 가져오기에 대한 대비를 할 수 있다.
 </P
></LI
><LI
><P
><TT
CLASS="VARNAME"
>log_rotation_size</TT
>를 0으로 설정하면 로그 파일 이름을 예상하기 어려워지므로 크기 기반 로그 파일 로테이션이 비활성화된다.
 </P
></LI
><LI
><P
> 오래된 로그 데이터가 새 데이터와 동일한 파일에 혼재되지 않게 하려면 <TT
CLASS="VARNAME"
>log_truncate_on_rotation</TT
>을 
 <TT
CLASS="LITERAL"
>on</TT
>으로 설정해야 한다.</P
></LI
><LI
><P
> 위의 테이블 정의에는 프라이머리 키 규격이 포함되어 있다. 이것은 동일한 정보를 두 번 가져오는 실수를 방지하는 데 유용하다. 
 <TT
CLASS="COMMAND"
>COPY</TT
> 명령은 한 번에 가져올 모든 데이터를 커밋하므로 에러 발생 시 가져오기 전체가 실패하게 된다. 
 로그 파일을 일부만 가져오고, 나중에 완료 시 다시 파일을 가져오는 경우 프라이머리 키 위반 때문에 가져오기가 실패할 수 있다. 
 가져오기 전에 로그가 완료되고 닫힐 때까지 기다려야 한다. 
 이 절차는 또한 기록이 아직 완료되지 않은 일부 라인을 가져오는 실수를 함으로써 <TT
CLASS="COMMAND"
>COPY</TT
>가 실패하게 되는 사태를 방지한다.</P
></LI
></OL
><P></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-query.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-statistics.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>쿼리 플랜</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>실시간 통계</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>