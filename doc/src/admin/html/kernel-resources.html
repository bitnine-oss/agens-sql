<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>커널 리소스 관리</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="서버 설정 및 운용"
HREF="runtime.html"><LINK
REL="PREVIOUS"
TITLE="데이터베이스 서버 시작"
HREF="server-start.html"><LINK
REL="NEXT"
TITLE="서버 셧다운"
HREF="server-shutdown.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T09:12:38"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="데이터베이스 서버 시작"
HREF="server-start.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 1. 서버 설정 및 운용</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="서버 셧다운"
HREF="server-shutdown.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="KERNEL-RESOURCES"
>1.4. 커널 리소스 관리</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 특히 서버의 사본들을 동일한 시스템에서 실행 하는 경우 또는 대규모 설치 하는 경우, 운영 체제 자원들을 한계치까지 쓰기도 한다.
   이 절에서는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>가 사용하는 커널 자원 및 커널 자원 소비와 관련된 문제 해결 단계를 다룬다.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYSVIPC"
>1.4.1. 공유 메모리 및 세마포어</A
></H2
><P
>    공유 메모리 및 세마포어는 통칭 <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="SYSTEMITEM"
>System V</SPAN
> <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>"</SPAN
>라고 한다.
    (<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>과 무관한 메시지 큐와 함께)
    <SPAN
CLASS="SYSTEMITEM"
>Windows</SPAN
> 외에 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 이러한 기능을 자체적으로 제공하는 경우 
    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 실행하려면 이 기능이 요구된다.
   </P
><P
>    이 기능이 없으면 서버 시작 시 <SPAN
CLASS="ERRORNAME"
>잘못된 시스템 호출</SPAN
> 에러가 발생한다. 
    이 경우 커널을 다시 환경 설정하는 것 외에는 대안이 없다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 커널 없이 작동되지 않는다. 
    이 상황은 최신 운영 체제에서는 거의 일어나지 않는다.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 하드 <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>제한을 초과한 경우 서버는 시작을 거부하고 문제와 조치를 설명하는 에러 메시지를 남긴다. 
    (<A
HREF="server-start.html#SERVER-START-FAILURES"
>1.3.1절</A
> 참조) 관련 커널 매개변수의 이름은 각종 시스템 간에 동일하며, 
    <A
HREF="kernel-resources.html#SYSVIPC-PARAMETERS"
>표 1-1</A
>에 대략적인 내용이 나와 있다. 
    단, 매개변수 설정 방법은 다를 수 있다. 일부 플랫폼별 설정방법은 아래에 나와 있다.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>       <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 9.3 이전에는 서버 시작 시 훨씬 더 많은 System V 공유 메모리가 필요했다. 
       오래된 버전에서 서버를 실행할 경우 문서에서 서버 버전을 참고하기 바란다.
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="SYSVIPC-PARAMETERS"
></A
><P
><B
>표 1-1. <SPAN
CLASS="SYSTEMITEM"
>System V</SPAN
> <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
> 매개변수</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>이름</TH
><TH
>설명</TH
><TH
>적절한 값</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMAX</TT
></TD
><TD
>공유 메모리 세그먼트의 최대 크기(바이트)</TD
><TD
>최소 1kB(서버 사본이 다수 실행되는 경우 그 이상)</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMIN</TT
></TD
><TD
>공유 메모리 세그먼트의 최소 크기(바이트)</TD
><TD
>1</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMALL</TT
></TD
><TD
>사용 가능한 공유 메모리의 총 양(바이트 또는 페이지)</TD
><TD
>바이트인 경우 <TT
CLASS="VARNAME"
>SHMMAX</TT
>와 동일. 페이지인 경우 <TT
CLASS="LITERAL"
>ceil(SHMMAX/PAGE_SIZE)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMSEG</TT
></TD
><TD
>프로세스당 공유 메모리 세그먼트의 최대 수</TD
><TD
>1개 세그먼트만 필요하지만 기본값이 훨씬 큼</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMNI</TT
></TD
><TD
>시스템 차원(system-wide)의 공유 메모리 세그먼트의 최대 수</TD
><TD
><TT
CLASS="VARNAME"
>SHMSEG</TT
>와 동량 외 다른 애플리케이션의 여유분</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMNI</TT
></TD
><TD
>세마포어 식별자의 최대 수(예: 세트)</TD
><TD
>최소한 <TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + 4) / 16)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMNS</TT
></TD
><TD
>시스템 차원(system-wide)의 세마포어 최대 수</TD
><TD
><TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + 4) / 16) * 17</TT
> 외 다른 애플리케이션의 여유분</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMSL</TT
></TD
><TD
>세트별 세마포어 최대 수</TD
><TD
>최소한 17</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMAP</TT
></TD
><TD
>세마포어 맵에서 항목 수</TD
><TD
>텍스트 참조</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMVMX</TT
></TD
><TD
>세마포어 최대 값</TD
><TD
>최소한 1000 (기본값은 대체로 32767; 필요한 경우 외에는 변경하지 말 것)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 서버 사본별로 System V 공유 메모리 바이트가 필요하다(64비트 플랫폼의 경우 보통 48바이트). 
    최신 운영 체제에서 이 정도 양은 손쉽게 할당 가능하다. 
    그러나, 여러 서버 사본을 실행하거나 다른 애플리케이션도 System V 공유 메모리를 사용할 때는
    바이트 단위의 공유 메모리 최대 크기인 <TT
CLASS="VARNAME"
>SHMMAX</TT
>를 늘리거나
    시스템 차원(system-wide)의 System V 공유 메모리인 <TT
CLASS="VARNAME"
>SHMALL</TT
>를 늘려야 할 수도 있다.
    <TT
CLASS="VARNAME"
>SHMALL</TT
>는 대부분의 시스템에서 바이트 단위가 아닌 페이지 단위로 처리된다는 점에 유의하라.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 경우, 공유 메모리 세그먼트의 최소 크기(<TT
CLASS="VARNAME"
>SHMMIN</TT
>)는 많아야 약 32바이트에 불과하기 때문에(대개 1) 
    문제의 원인이 될 가능성은 낮다. 
    시스템 차원(system-wide)의 세그먼트 최대 수(SHMMNI) 또는 프로세스당 최대 수(<TT
CLASS="VARNAME"
>SHMSEG</TT
>)는 
    시스템이 영(0)으로 설정해 놓지 않는 한 문제의 원인이 될 가능성은 낮다.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 16개의 세트 중에서 연결당 1개의 세마포어
    (<A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>)와 autovacuum worker 프로세스당(<A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
>) 1개의 세마포어를 사용한다. 
    각 세트는 타 애플리케이션의 세마포어 세트와의 충돌을 감지하는 <SPAN
CLASS="QUOTE"
>"매직 넘버"</SPAN
>가 포함된 17번째 세마포어를 갖고 있다. 
    시스템에서 세마포어 최대 수는 <TT
CLASS="VARNAME"
>SEMMNS</TT
>에 의해 설정되며, 최소한 
    <TT
CLASS="VARNAME"
>max_connections</TT
> + <TT
CLASS="VARNAME"
>autovacuum_max_workers</TT
> + 각각 허용된 16개 연결에 1 추가 + worker 이어야 한다(<A
HREF="kernel-resources.html#SYSVIPC-PARAMETERS"
>표 1-1</A
> 공식 참조). 
    매개변수 <TT
CLASS="VARNAME"
>SEMMNI</TT
>는 시스템 상 동시에 존재할 수 있는 세마포어 세트의 개수를 제한한다. 
    최소한 <TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + 4) / 16)</TT
> 이어야 한다. 
    수용하는 연결 수를 줄이면 실패 시 임시 방편으로 해결할 수 있지만, <CODE
CLASS="FUNCTION"
>semget</CODE
> 함수로부터 <SPAN
CLASS="QUOTE"
>"No space
    left on device"</SPAN
>라는 애매한 메시지도 받게 된다.
   </P
><P
>    경우에 따라서는 
    <TT
CLASS="VARNAME"
>SEMMAP</TT
>를 적어도 
    <TT
CLASS="VARNAME"
>SEMMNS</TT
>와 유사하게 늘릴 필요가 있을 수 있다. 이 매개변수는 세마포어 자원 맵의 크기를 정하며, 
    이 맵에는 세마포어의 서로 인접한 블록들이 각기 필요로 하는 엔트리가 들어 있다.
    해제된 세마포어 세트는 해제된 블록에 인접하고 있는 엔트리에 추가되거나 새로운 엔트리에 등록된다. 
    맵이 꽉 차면 해제된 세마포어는 사라진다(재부팅될 때까지). 
    세마포어 공간이 쪼개질수록 가용한 세마포어가 점점 적어진다.
   </P
><P
>    세트에 포함될 수 있는 세마포어 수를 결정하는 <TT
CLASS="VARNAME"
>SEMMSL</TT
>은 
    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 경우 최소 17이어야 한다.
   </P
><P
>    <TT
CLASS="VARNAME"
>SEMMNU</TT
> 및 <TT
CLASS="VARNAME"
>SEMUME</TT
> 같은 <SPAN
CLASS="QUOTE"
>"semaphore undo"</SPAN
>와 관련된 기타 설정은 
    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에 영향을 미치지 않는다.
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>AIX</SPAN
>
      </DT
><DD
><P
>        모든 메모리가 공유 메모리로 사용되도록 설정되므로, 적어도 5.1 버전에서는 <TT
CLASS="VARNAME"
>SHMMAX</TT
>같은 매개변수를 설정할 필요가 없다. 
        SHMMAX는 <SPAN
CLASS="APPLICATION"
>DB/2</SPAN
> 같은 다른 데이터베이스에서 일반적으로 사용되는 설정의 한 종류이다.</P
><P
> 그러나, 파일 크기(<TT
CLASS="VARNAME"
>fsize</TT
>)와 파일 수(<TT
CLASS="VARNAME"
>nofiles</TT
>)의 기본 하드 제한이 너무 낮으므로 
       전역 <TT
CLASS="COMMAND"
>ulimit</TT
> 정보를 <TT
CLASS="FILENAME"
>/etc/security/limits</TT
>에서 변경해야 될 수도 있다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>
      </DT
><DD
><P
>        기본 설정은 <TT
CLASS="COMMAND"
>sysctl</TT
> 또는 <TT
CLASS="COMMAND"
>loader</TT
> 인터페이스를 사용하여 변경할 수 있다. 
        아래 매개변수들은 <TT
CLASS="COMMAND"
>sysctl</TT
>을 사용하여 설정할 수 있다.
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl kern.ipc.shmall=32768</KBD
>
<SAMP
CLASS="PROMPT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl kern.ipc.shmmax=134217728</KBD
></PRE
><P>
        재부팅 시에 이 설정을 유지하려면 
        <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>를 수정해야 한다.
       </P
><P
>        이러한 세마포어 관련 설정은 <TT
CLASS="COMMAND"
>sysctl</TT
>을 사용한 경우, 
        읽기 전용이지만 <TT
CLASS="FILENAME"
>/boot/loader.conf</TT
>에서 다르게 설정할 수 있다.
</P><PRE
CLASS="PROGRAMLISTING"
>kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256</PRE
><P>
        수정된 설정이 적용되려면 재부팅이 필요하다. 
        (참고: FreeBSD는 <TT
CLASS="VARNAME"
>SEMMAP</TT
>를 사용하지 않는다. 오래된 버전은 <TT
CLASS="VARNAME"
>SEMMAP</TT
>를 적용하지만 <TT
CLASS="LITERAL"
>kern.ipc.semmap</TT
>설정은 무시하고, 
        새 버전은 둘 다 무시한다.)
       </P
><P
>        사용자는 커널 환경 설정을 하여 공유 메모리를 RAM에서 잠그고 스왑되지 않게 할 수 있다. 
        이것은 <TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>를 설정해서 <TT
CLASS="COMMAND"
>sysctl</TT
>를 사용하면 된다.
       </P
><P
>        <SPAN
CLASS="APPLICATION"
>sysctl</SPAN
>의 <TT
CLASS="LITERAL"
>security.jail.sysvipc_allowed</TT
>를 활성화하여 FreeBSD jail에서 실행할 시, 
        서로 다른 jail에서 실행 중인 <SPAN
CLASS="APPLICATION"
>postmaster</SPAN
>들은 각기 다른 시스템 사용자로부터 실행되야 한다.
        루트 사용자가 아닌 경우 서로 다른 jail에서 사용자가 공유 메모리 또는 세마포어를 간섭하지 못하게 하고, 
        PostgreSQL IPC 클린업 코드가 제대로 작동되어 보안에 이점이 있다.
        (FreeBSD 6.0 이상에서 IPC 클린업 코드는 서로 다른 jail에서 동일한 포트로 postmaster를 실행하는 것을 막기 때문에 
        다른 jail의 프로세스를 인식하지 못한다.)
       </P
><P
>        <SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
> 4.0 이전 버전은 
        <SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>처럼 작동된다(아래 참조).
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>
      </DT
><DD
><P
>        <SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>5.0 이상에서, IPC 매개변수는 <TT
CLASS="COMMAND"
>sysctl</TT
>을 사용하여 조절 가능하다. 예를 들면 다음과 같다.
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kern.ipc.shmmax=16777216</KBD
></PRE
><P>
        재부팅 시에도 설정을 유지하려면 
        <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>를 수정해야 한다.
       </P
><P
>       사용자는 커널 환경 설정을 하여 공유 메모리를 RAM에서 잠그고 스왑되지 않게 할 수 있다. 
       이것은 <TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>를 설정해서 <TT
CLASS="COMMAND"
>sysctl</TT
>을 사용하면 가능하다.
       </P
><P
>        <SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
> 5.0 이전 버전에서 <TT
CLASS="LITERAL"
>option</TT
>이 아니라 
        <TT
CLASS="LITERAL"
>options</TT
>란 키워드로 설정해야 하는 매개변수 외에는 
        <SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
> (아래 참조)처럼 작동된다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>
      </DT
><DD
><P
>        <TT
CLASS="VARNAME"
>SYSVSHM</TT
> 옵션 및 <TT
CLASS="VARNAME"
>SYSVSEM</TT
>은 커널이 컴파일된 경우에 활성화되어야 한다(기본으로 설정돼 있음).  
        공유 메모리의 최대 크기는 옵션 <TT
CLASS="VARNAME"
>SHMMAXPGS</TT
> (페이지 단위)에 의해 결정된다. 
        다음 예시는 다양한 매개변수 설정 방법을 보여준다.
</P><PRE
CLASS="PROGRAMLISTING"
>option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256</PRE
><P>
       </P
><P
>        사용자는 커널 환경 설정을 하여 공유 메모리를 RAM에서 잠그고 스왑되지 않게 할 수 있다. 
        이것은 <TT
CLASS="COMMAND"
>sysctl</TT
> 설정 <TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>를 사용하면 가능하다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
>
      </DT
><DD
><P
>        기본 설정만으로도 정상적으로 설치 가능하다. <SPAN
CLASS="PRODUCTNAME"
>HP-UX</SPAN
> 10에서 
        <TT
CLASS="VARNAME"
>SEMMNS</TT
>의 출고시 기본 설정은 128인데, 거대 데이터베이스 사이트에는 너무 작을 수 있다.
       </P
><P
>        <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
> 매개변수는 <SPAN
CLASS="GUIMENU"
>커널 환경 설정</SPAN
>-&gt;<SPAN
CLASS="GUIMENUITEM"
>환경 설정 변수</SPAN
> 아래의 <SPAN
CLASS="APPLICATION"
>시스템 
        관리 매니저</SPAN
> (<ACRONYM
CLASS="ACRONYM"
>SAM</ACRONYM
>)에서 설정할 수 있다. 완료 시 <SPAN
CLASS="GUIBUTTON"
>새 커널 생성하기</SPAN
>를 선택해야 한다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>리눅스</SPAN
>
      </DT
><DD
><P
>        최대 세그먼트 크기 기본값은 32 MB이며, 최대 총 크기 기본값은 2097152 페이지이다. 
        <SPAN
CLASS="QUOTE"
>"huge pages"</SPAN
>를 이용한 특수한 커널 환경 설정일 때 외에 페이지는 거의 항상 4096바이트이다(확인하려면 <TT
CLASS="LITERAL"
>getconf PAGE_SIZE</TT
> 사용).
       </P
><P
>        공유 메모리 크기 설정은 <TT
CLASS="COMMAND"
>sysctl</TT
> 인터페이스를 통해 변경 가능하다. 예를 들어, 16GB로 설정하려면 아래처럼 입력한다.
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kernel.shmmax=17179869184</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kernel.shmall=4194304</KBD
></PRE
><P>
        또, <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
> 파일로 재부팅 시에도 이 설정을 보존할 수 있다. 이는 매우 바람직한 설정 방법이다.
       </P
><P
>        오래된 버전에는 <TT
CLASS="COMMAND"
>sysctl</TT
> 프로그램이 없을 수도 있지만 <TT
CLASS="FILENAME"
>/proc</TT
> 파일 시스템을 처리하여 동일하게 변경할 수 있다.
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>echo 17179869184 &gt;/proc/sys/kernel/shmmax</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>echo 4194304 &gt;/proc/sys/kernel/shmall</KBD
></PRE
><P>
       </P
><P
>        남은 기본 설정 값은 아주 넉넉한 크기로 지정돼 있어, 굳이 변경할 필요가 없다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OS X</SPAN
>
      </DT
><DD
><P
>        OS X에서 공유 메모리를 환경 설정하는 방법은 다음과 같은 변수 및 값이 포함된 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
> 파일을 생성하는 것이다.
</P><PRE
CLASS="PROGRAMLISTING"
>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024</PRE
><P>
        일부 OS X 버전에서는 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>전체 5개</I
></SPAN
>의 공유 메모리 매개변수를 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>에 설정해야 한다. 그렇게 하지 않으면 설정이 무시된다.
       </P
><P
>        OS X 최근 버전에서는 <TT
CLASS="VARNAME"
>SHMMAX</TT
> 설정 값이 정확히 4096의 배수가 아니면 무시된다.
       </P
><P
>        <TT
CLASS="VARNAME"
>SHMALL</TT
>은 이 플랫폼에서 4 kB로 적용된다.
       </P
><P
>        OS X 구 버전에서는 공유 메모리 매개변수에 대한 변경 내용이 적용되려면 재부팅 해야 한다. 
        10.5는 현재, <SPAN
CLASS="APPLICATION"
>sysctl</SPAN
>을 사용하여 <TT
CLASS="VARNAME"
>SHMMNI</TT
>를 제외한 모든 변수가 변경 가능하다. 
        그러나 재부팅 시 값이 유지될 수 있도록 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>를 통해 원하는 값을 설정하는 것이 최선의 방법이다.
       </P
><P
>        <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
> 파일은 OS X 10.3.9 버전 이상에서만 유효하다. 이전 10.3.x 버전을 실행 중인 경우, <TT
CLASS="FILENAME"
>/etc/rc</TT
>
        파일을 편집하여 다음 명령으로 값을 변경해야 한다.
</P><PRE
CLASS="PROGRAMLISTING"
>sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall</PRE
><P>
       <TT
CLASS="FILENAME"
>/etc/rc</TT
>는 일반적으로 OS X 시스템 업데이트 시 덮어쓰기 되므로 업데이트가 있을 때마다 사용자는 위 편집을 반복해야 한다.
       </P
><P
>        OS X 10.2 이전 버전에서는 <TT
CLASS="FILENAME"
>/System/Library/StartupItems/SystemTuning/SystemTuning</TT
> 파일에서 이 명령을 편집해야 한다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>SCO 오픈서버</SPAN
>
      </DT
><DD
><P
>        기본 환경 설정에서 세그먼트당 512 kB의 공유 메모리만 허용된다. 
        설정을 변경하려면 먼저 <TT
CLASS="FILENAME"
>/etc/conf/cf.d</TT
>디렉토리로 이동해야 한다. 
        <TT
CLASS="VARNAME"
>SHMMAX</TT
>의 현재 값을 표시하려면 다음을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>./configure -y SHMMAX</PRE
><P>
        <TT
CLASS="VARNAME"
>SHMMAX</TT
>에 새 값을 설정하려면 다음을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>./configure SHMMAX=<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></PRE
><P>
        여기서 <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>는 사용하려는 새 값이다(바이트 단위). 
        <TT
CLASS="VARNAME"
>SHMMAX</TT
>를 설정한 후에는 커널을 리빌드한다.
</P><PRE
CLASS="PROGRAMLISTING"
>./link_unix</PRE
><P>
        그런 다음 재부팅한다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
> 2.6 에서 2.9 까지(Solaris 6 ~ Solaris 9)
      </DT
><DD
><P
>        해당 설정은 <TT
CLASS="FILENAME"
>/etc/system</TT
>에서 변경 가능하다. 예를 들면 다음과 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32</PRE
><P>
        변경 내용을 적용하려면 재부팅이 필요하다. 
        이전 Solaris 버전에서 공유 메모리에 대한 내용은 <A
HREF="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"
TARGET="_top"
>http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html</A
>
        을 참조 바란다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
> 2.10 (Solaris
      10) 이상<BR><SPAN
CLASS="SYSTEMITEM"
>OpenSolaris</SPAN
></DT
><DD
><P
>        Solaris 10 이상 및 OpenSolaris에서 기본 공유 메모리 및 세마포어 설정은 대부분의 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 애플리케이션에서는 충분하다. 
        이제 Solaris는 시스템 <ACRONYM
CLASS="ACRONYM"
>RAM</ACRONYM
>의 1/4을 <TT
CLASS="VARNAME"
>SHMMAX</TT
> 기본값으로 설정한다. 
        이 설정을 조정하려면 <TT
CLASS="LITERAL"
>agens</TT
> 사용자에 대한 프로젝트 설정을 사용해야 한다. 예를 들면, <TT
CLASS="LITERAL"
>root</TT
>로 다음을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>projadd -c "Agens SQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U agens -G agens user.agens</PRE
><P>
       </P
><P
>        위 명령은 <TT
CLASS="LITERAL"
>user.agens</TT
> 프로젝트를 추가하고 <TT
CLASS="LITERAL"
>agens</TT
> 사용자에 대한 공유 메모리 최대값을 8GB로 설정한다.
        다음 사용자 로그인 시 적용되거나 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 재시작 시 적용된다(리로드 아님). 
        위 명령은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 <TT
CLASS="LITERAL"
>agens</TT
> 그룹의 <TT
CLASS="LITERAL"
>agens</TT
> 사용자로 실행되는 것으로 간주한다. (서버는 재부팅할 필요 없다.)
       </P
><P
>        데이터베이스 서버가 다수 연결된 경우, 커널을 다음과 같이 설정할 것을 권한다.
</P><PRE
CLASS="PROGRAMLISTING"
>project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)</PRE
><P>
       </P
><P
>        또, zone 내에서 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 실행할 경우, zone의 자원 사용 제한도 올려야 할 필요가 있다. 
        <TT
CLASS="LITERAL"
>projects</TT
> 및 <TT
CLASS="COMMAND"
>prctl</TT
>에 대한 자세한 내용은 <I
CLASS="CITETITLE"
>시스템 관리자 가이드</I
>의 "2장: 프로젝트와 태스크"를 참조 바란다.
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
>
      </DT
><DD
><P
>        <SPAN
CLASS="PRODUCTNAME"
>UnixWare</SPAN
> 7에서 공유 메모리 세그먼트의 최대 크기는 기본적으로 512 kB이다. <TT
CLASS="VARNAME"
>SHMMAX</TT
>의 현재 값을 보고 싶으면 다음을 입력하라.
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idtune -g SHMMAX</PRE
><P>
        이것은 현재값 및 기본값, 최소값, 최대값을 보여준다. <TT
CLASS="VARNAME"
>SHMMAX</TT
>에 새로운 값을 설정하려면 다음을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idtune SHMMAX <TT
CLASS="REPLACEABLE"
><I
>새로운 값</I
></TT
></PRE
><P>
        여기서 <TT
CLASS="REPLACEABLE"
><I
>새로운 값</I
></TT
>은 사용하고자 하는 바이트 단위의 값이다. <TT
CLASS="VARNAME"
>SHMMAX</TT
>를 설정한 후에는 커널을 리빌드 하라.
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idbuild -B</PRE
><P>
        그리고 재부팅하라.
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN642"
>1.4.2. 자원 제한</A
></H2
><P
>    Unix 계열의 운영 체제는 사용자의 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버에도 영향을 미칠 수 있는 자원 제한 형태가 다양하다. 
    그 중 사용자별 프로세스 수, 프로세스당 개방 파일 수, 각 프로세스에서 사용 가능한 메모리 양에 대한 제한이 특히 중요하다. 
    이러한 제한들은 각각 <SPAN
CLASS="QUOTE"
>"하드"</SPAN
> 및 <SPAN
CLASS="QUOTE"
>"소프트"</SPAN
> 제한이 있다. 
    소프트 제한이 실제로 적용되는 것이고, 사용자가 하드 제한까지 증가 시킬 수 있다. 
    하드 제한은 root 사용자만 변경할 수 있다.
    시스템 호출 <CODE
CLASS="FUNCTION"
>setrlimit</CODE
>는 이 매개변수의 설정을 담당한다. 
    쉘에 내장된 명령어 <TT
CLASS="COMMAND"
>ulimit</TT
>(Bourne 쉘) 또는 <TT
CLASS="COMMAND"
>limit</TT
> (<SPAN
CLASS="APPLICATION"
>csh</SPAN
>)는 커맨드 라인에서 자원 제한을 제어하는 데 사용된다. 
    BSD 계열 시스템에서 로그인 시 <TT
CLASS="FILENAME"
>/etc/login.conf</TT
> 파일은 다양한 자원 제한 설정을 제어한다. 
    자세한 내용은 운영 체제 문서를 참조 바란다. 
    관련 매개변수는 <TT
CLASS="VARNAME"
>maxproc</TT
> 및 <TT
CLASS="VARNAME"
>openfiles</TT
>, <TT
CLASS="VARNAME"
>datasize</TT
> 이 있다. 예제는 아래와 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</PRE
><P>
    (<TT
CLASS="LITERAL"
>-cur</TT
>는 소프트 제한이다. 하드 제한을 설정하려면 <TT
CLASS="LITERAL"
>-max</TT
>를 덧붙인다.)
   </P
><P
>    커널은 일부 자원에 대해 시스템 차원(system-wide)의 제한을 가질 수 있다.
    <P
></P
></P><UL
><LI
><P
>      <SPAN
CLASS="PRODUCTNAME"
>Linux</SPAN
>의 <TT
CLASS="FILENAME"
>/proc/sys/fs/file-max</TT
>는 커널이 지원하는 오픈 파일의 최대 수를 결정한다. 
      다른 수를 적거나 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>에 값을 추가하면 변경된다.
      프로세스당 최대 제한 파일 개수는 커널이 컴파일되는 시점에 적용된다. 자세한 내용은 
      <TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/proc.txt</TT
>를 참조 바란다.
      </P
></LI
></UL
><P>
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 연결당 프로세스 1개를 사용하므로 최소한 연결된 프로세스 개수 이상 지정해야 한다.
    이것은 머신 1대에 여러 개의 서버를 실행하는 경우에 중요하다.
   </P
><P
>    오픈 파일에 대한 기본적인 제한은 시스템 자원를 부적절하게 분할하지 않기 위해서, 
    여러 사용자가 머신에 공존할 수 있도록 <SPAN
CLASS="QUOTE"
>"대체로 용인되는"</SPAN
> 값으로 설정된다. 
    필요에 따라 머신 1대에서 여러 개의 서버를 실행할 수 있는데, 이 중 특정 서버의 제한만 변경할 수도 있다.
   </P
><P
>    일부 시스템에서는 프로세스들이 여러 개의 파일들을 열 수 있게 한다. 
    그러면 몇 개의 프로세스만 실행해도 시스템 차원(system-wide)의 제한이 쉽게 초과된다. 
    이러한 상황이 발생할 경우, 시스템 차원(system-wide)의 제한을 변경하고 싶지 않으면
    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 <A
HREF="runtime-config-resource.html#GUC-MAX-FILES-PER-PROCESS"
>max_files_per_process</A
> 환경 설정 매개변수를 설정하여 오픈 파일 개수를 제한할 수 있다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LINUX-MEMORY-OVERCOMMIT"
>1.4.3. 리눅스 메모리 오버커밋</A
></H2
><P
>    리눅스 2.4 이상에서의 기본적인 가상 메모리 동작은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 경우 최적화 되어 있지 않다. 
    커널이 메모리 오버커밋을 이행하는 방식 때문에, <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 또는 다른 프로세스의 메모리 수요가 
    시스템의 가상 메모리 소진의 원인이 되는 경우, 커널은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> postmaster(마스터 서버 프로세스)를 종료해야 한다.
   </P
><P
>    이 경우가 발생하면 다음과 같은 커널 메시지가 나타난다(해당 메시지를 찾아 보려면 시스템 문서 및 환경 설정 참조).
</P><PRE
CLASS="PROGRAMLISTING"
>Out of Memory: Killed process 12345 (agens).</PRE
><P>
    이것은 <TT
CLASS="FILENAME"
>agens</TT
> 프로세스가 메모리 압박 때문에 종료되었음을 뜻한다. 
    기존 데이터베이스 연결이 정상 작동되더라도 새로운 연결은 수락되지 않는다. 
    복구하려면 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 재시작해야 한다.
   </P
><P
>    이 문제를 방지하는 방법 중 하나는 다른 프로세스 때문에 머신의 메모리가 소진되지 않을 것이 확실한 머신에서 
    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 실행하는 것이다. 
    실제 메모리와 스왑 공간이 소진된 경우에만 메모리 부족(OOM) 킬러가 호출되기 때문에 메모리에 여유가 없는 경우에는 
    운영 체제의 스왑 공간을 늘리면 문제를 방지하는 데 도움이 된다.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 자체가 메모리 부족의 원인인 경우 
    환경 설정을 변경하면 문제를 방지할 수 있다. 경우에 따라 메모리 관련 환경 설정 매개변수, 특히 
    <A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
><TT
CLASS="VARNAME"
>shared_buffers</TT
></A
> 및 <A
HREF="runtime-config-resource.html#GUC-WORK-MEM"
><TT
CLASS="VARNAME"
>work_mem</TT
></A
>을 줄이는 것이 도움이 된다. 
    그 외에는 데이터베이스 서버 자체로의 연결을 너무 많이 허용하는 것이 문제의 원인일 수 있다. 대체로, 
    <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
><TT
CLASS="VARNAME"
>max_connections</TT
></A
>를 줄이는 대신 외부 연결 풀링 소프트웨어를 이용하는 것이 좋다.
   </P
><P
>    리눅스 2.6 이상에서 커널의 동작을 수정해서 메모리 <SPAN
CLASS="QUOTE"
>"오버커밋"</SPAN
>을 방지할 수 있다. 
    이 설정으로 <A
HREF="http://lwn.net/Articles/104179/"
TARGET="_top"
>OOM killer</A
>의 호출이 전적으로 방지되는 않지만 가능성은 확연히 줄어든다.
    <TT
CLASS="COMMAND"
>sysctl</TT
>을 통해 엄격한 오버커밋 모드를 선택하면 된다.
</P><PRE
CLASS="PROGRAMLISTING"
>sysctl -w vm.overcommit_memory=2</PRE
><P>
    위 동작을 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>에 엔트리로 입력해도 된다.
    <TT
CLASS="VARNAME"
>vm.overcommit_ratio</TT
>을 수정하고 싶으면, 커널 문서 파일 <TT
CLASS="FILENAME"
>Documentation/vm/overcommit-accounting</TT
>을 참조 바란다.
   </P
><P
>    <TT
CLASS="VARNAME"
>vm.overcommit_memory</TT
>를 사용하는 또다른 방법은 postmaster 프로세스의 프로세스 특정 
    <TT
CLASS="VARNAME"
>oom_score_adj</TT
> 값을 <TT
CLASS="LITERAL"
>-1000</TT
>으로 설정하는 것이다. 
    그렇게 함으로써 OOM 킬러의 타겟이 되는 것을 면할 수 있다. 이렇게 하는 가장 간단한 방법은 아래와 같다.
</P><PRE
CLASS="PROGRAMLISTING"
>echo -1000 &#62; /proc/self/oom_score_adj</PRE
><P>
    postmaster를 호출하기 전에 상기 명령을 postmaster의 시작 스크립트에서 실행하는 것이다. 
    이 액션은 root로 실행하지 않으면 아무런 효력이 없으므로 root권한 소유의 시작 스크립트를 이용하는 것이 가장 간단하다. 
    <TT
CLASS="VARNAME"
>CPPFLAGS</TT
>에 추가된 <TT
CLASS="LITERAL"
>-DLINUX_OOM_SCORE_ADJ=0</TT
>로 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 빌드할 수도 있다.
    이는 postmaster 자식 프로세스를 일반 <TT
CLASS="VARNAME"
>oom_score_adj</TT
> 값인 0으로 실행해서 OOM 킬러가 필요시 사용될 수 있다.
   </P
><P
>이전 리눅스 커널은 <TT
CLASS="FILENAME"
>/proc/self/oom_score_adj</TT
>의 이전 버전인 <TT
CLASS="FILENAME"
>/proc/self/oom_adj</TT
>을 같은 기능으로 제공한다.
비활성 시 설정하는 값이 <TT
CLASS="LITERAL"
>-1000</TT
>이 아니라 <TT
CLASS="LITERAL"
>-17</TT
>인 것 외에는 동일하게 작동한다. 
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>의 빌드 플래그는 <TT
CLASS="LITERAL"
>-DLINUX_OOM_ADJ=0</TT
>이다.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>일부 공급업체의 Linux 2.4 커널은 2.6 오버커밋 <TT
CLASS="COMMAND"
>sysctl</TT
> 매개변수의 초기 소스 코드를 가지고 있는 것으로 알려져 있다. 
이전 소스 코드로 2.4 커널에서 <TT
CLASS="LITERAL"
>vm.overcommit_memory</TT
>를 2로 설정하는 것은 안 좋다.
실제 커널 소스 코드를 확인하여( <TT
CLASS="FILENAME"
>mm/mmap.c</TT
> 파일에서 <CODE
CLASS="FUNCTION"
>vm_enough_memory</CODE
> 참조) 
2.4 설치 시 사용자 커널에서 어떤 소스를 사용하는지 확인하는 것이 좋다. 
<TT
CLASS="FILENAME"
>overcommit-accounting</TT
> 문서 파일이 존재한다고 해서 오버커밋이 지원된다고 생각해서는 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>안</I
></SPAN
> 된다. 
의심스러울 경우는 커널 전문가 또는 커널 공급업체에게 문의 하라.
   </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LINUX-HUGE-PAGES"
>1.4.4. 리눅스 huge pages</A
></H2
><P
>huge pages는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 처럼 서로 인접해 있는 거대한 메모리를 사용 시 오버헤드를 줄여준다.
<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 이 huge pages을 활성화하려면 <TT
CLASS="VARNAME"
>CONFIG_HUGETLB_PAGE=y</TT
> 및 
<TT
CLASS="VARNAME"
>CONFIG_HUGETLBFS=y</TT
>를 사용하는 커널이 필요하다. 
시스템 설정 <TT
CLASS="VARNAME"
>vm.nr_hugepages</TT
>도 튜닝해야 한다. 
필요한 huge pages 수를 추정하려면 huge pages를 활성화하지 않고 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 시작해서 
proc 파일 시스템에서 <TT
CLASS="VARNAME"
>VmPeak</TT
> 값을 확인해야 한다.
</P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>head -1 /path/to/data/directory/postmaster.pid</KBD
>
4170
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>grep ^VmPeak /proc/4170/status</KBD
>
VmPeak:  6490428 kB</PRE
><P>
<TT
CLASS="LITERAL"
>6490428</TT
> / <TT
CLASS="LITERAL"
>2048</TT
>(이 경우 <TT
CLASS="VARNAME"
>PAGE_SIZE</TT
>는 <TT
CLASS="LITERAL"
>2MB</TT
>)는 대략 
<TT
CLASS="LITERAL"
>3169.154</TT
> 이므로 huge pages는 최소 <TT
CLASS="LITERAL"
>3170</TT
>가 필요하다.
</P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w vm.nr_hugepages=3170</KBD
></PRE
><P>
가끔씩 커널이 huge pages를 할당하지 못하는 경우, 해당 명령을 반복하거나 재부팅을 해야 한다. 
재부팅 시 이 설정을 유지하려면 <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>에 엔트리를 추가해야 한다.
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>는 기본적으로 huge pages를 가능하면 사용하는 것이고, 실패 시 정상 페이지로 폴백(fallback)하는 것이다. 
huge pages를 강제로 사용하려면 <A
HREF="runtime-config-resource.html#GUC-HUGE-PAGES"
><TT
CLASS="VARNAME"
>huge_pages</TT
></A
>를 <TT
CLASS="LITERAL"
>on</TT
>으로 설정하면 된다.
huge pages가 충분하지 않으면 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 시작하지 못할 수도 있다.
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>리눅스</SPAN
> huge pages 기능에 대한 자세한 설명은 <A
HREF="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"
TARGET="_top"
>https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</A
>를 읽어 보기 바란다.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="server-start.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="server-shutdown.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>데이터베이스 서버 시작</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>서버 셧다운</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>