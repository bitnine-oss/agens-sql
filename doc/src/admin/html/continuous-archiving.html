<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>아카이브 모드 백업(Continuous Archiving)과, (Point-in-Time Recovery, PITR)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="백업과 복원"
HREF="backup.html"><LINK
REL="PREVIOUS"
TITLE="파일 시스템 기반 백업"
HREF="backup-file.html"><LINK
REL="NEXT"
TITLE="고가용성, 부하 분산, 복제"
HREF="high-availability.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-30T08:52:27"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="파일 시스템 기반 백업"
HREF="backup-file.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 8. 백업과 복원</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="고가용성, 부하 분산, 복제"
HREF="high-availability.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONTINUOUS-ARCHIVING"
>8.3. 아카이브 모드 백업(Continuous Archiving)과, (Point-in-Time Recovery, PITR)</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는 미리 쓰기 기록
   (선행 기입 로그, <I
CLASS="FIRSTTERM"
>write ahead log</I
>, WAL)을 
   데이터베이스 클러스터 디렉토리 안 <TT
CLASS="FILENAME"
>pg_xlog/</TT
>
   디렉토리에서 관리하고 있다.
   이 로그는 데이터베이스의 데이터 파일에 대한 모든 수정 기록을 
   보관하고 있다. 이 로그를 만드는 가장 첫번째 이유는
   서버가 갑자기 중지되었을 경우 미처 데이터 파일에 
   적용하지 못한 작업(체크포인트 작업이 안된)을 이 로그에서 읽어서 
   그대로 <SPAN
CLASS="QUOTE"
>"다시 실행해서"</SPAN
> 서버를 안전하게 복구하기 위해서이다.
   이 방법을 그대로 응용하면 이 로그를 준비된 다른 서버로 보내서 
   이 로그의 내용을 그대로 재실행해서 원본 서버와 똑같은 상태를 
   만들 수 있다. (물론 특정 시점까지만 실행하면 데이터베이스를 
   특정시점으로 되돌릴 수도 있다.)
   여기서 소개하고 있는 백업과 복원 방법은 지금까지 이야기한 것보다 
   훨씬 복잡하다. 하지만 다음과 같은 장점이 있다.

  <P
></P
></P><UL
><LI
><P
>     파일 시스템을 백업할 때, 파일 시스템 상태에 대해서 신경 쓸 필요가 없다.
     복원할 때 WAL 파일의 내용을 재실행 하면서 마치 데이터베이스가 갑자기 중지되었을 때 
     복구하는 기법과 같이 데이터베이스를 안전하게 복원한다.
     즉, 파일 시스템의 스냅샷 기능을 고려할 필요 없이 <SPAN
CLASS="APPLICATION"
>tar</SPAN
>와 같은 간단한 
     프로그램으로 백업 작업을 할 수 있다.
    </P
></LI
><LI
><P
>     복원 작업에 필요한 WAL 파일의 수량에 제한이 없기 때문에 
     백업을 시작하는 시점 뒤부터 생길 WAL 로그만 정확하게 보관하면 
     백업 기간이 아무리 길어도 상관 없다.
     이 점은 자주 전체 백업을 할 수 없는 대용량 데이터베이스 백업에서 유용하다.
    </P
></LI
><LI
><P
>     복원을 할 때 WAL 파일의 내용을 끝까지 재실행할 필요가 없다.
     이 말은 특정 시점에서 이 작업을 멈출 수 있다는 것이다.
     이렇게 하면 특정 시점의 데이터베이스 상태로 복원이 가능하다.
     이것을 특정시점 복구 <I
CLASS="FIRSTTERM"
>point-in-time recovery</I
> 기능이라고 한다.
    </P
></LI
><LI
><P
>     다른 호스트에 베이스 백업을 복원해 놓고 
     운영 서버에서 만들어지는 WAL 파일들을 주기적으로 서버에 
     반영 하면, 운영 서버 장애가 발생했을 때 빠르게 대응할 수 있다.
     이렇게 운영하는 방법을 <I
CLASS="FIRSTTERM"
>warm standby</I
> 시스템 구축 기법이라고 한다.
    </P
></LI
></UL
><P>
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>    <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 명령과
    <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> 명령을 이용해서 만든 백업 파일은 
    데이터베이스의 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>논리적</I
></SPAN
> 백업이기 때문에 실제 데이터베이스에서 
    일어난 모든 기록을 보관하고 있지 않다. 그래서 
    파일 시스템 기반 백업이나 아카이브 모드 백업에서는 사용할 수 없다.
   </P
></BLOCKQUOTE
></DIV
><P
>   파일 시스템 기반 백업에서 이야기한 것과 같이 이 백업/복원 작업도 
   데이터베이스의 특정 부분을 대상으로 할 수 없고 데이터베이스 클러스터 전체를 대상으로 한다.
   또한 아카이브 로그를 다루는 여유 공간도 상당히 필요하다.
   베이스 백업량도 많고 업무량도 많아서 WAL 파일을 많이 만들면 
   베이스 백업과 WAL 파일을 처리하기 위한 비용도 상당히 많이 든다.
   하지만 고가용성 데이터베이스 시스템으로 운영해야하는 환경에서는 
   여전히 이 방법이 가장 추천할 만한 방법이다.
  </P
><P
>   이 아카이브 모드 백업(다른 데이터베이스에서는 흔히 <SPAN
CLASS="QUOTE"
>"온라인 백업"</SPAN
>이라고 함)을 이용한
   복원 작업을 무사히 마치려면, 적어도 베이스 백업을 시작하기 직전의 WAL 파일부터 베이스 백업이
   끝나는 시점까지 새로 생긴 WAL 파일들이 필요하다.
   그래서 이 백업 방식을 사용하려면 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>먼저</I
></SPAN
> 아카이브 로그 백업에 대한 정책을 수립하고, 
   베이스 백업을 진행해야 한다.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-ARCHIVING-WAL"
>8.3.1. WAL의 아카이브 파일 만들기</A
></H2
><P
>    내부적으로 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 시스템은 데이터베이스를 조작하는데 끊임 없이 순차적으로 WAL 레코드를 만든다.
    이것을 물리적인 디스크 공간에 저장하기 위해서 WAL <I
CLASS="FIRSTTERM"
>세그먼트 파일</I
>로 
    나눠서 저장한다. 이 하나의 WAL 파일은 기본적으로 16MB 크기의 파일이다(이 크기는 서버를 컴파일 할 때 결정된다).
    이 파일명은 WAL 순서에 따른 해당 번호를 사용한다.
    WAL 아카이브 파일을 만들지 않도록 설정하면 이 파일은 몇 개만 만들어지며, 
    이것 가운데 더이상 사용하지 않는 로그 파일을 찾아서 <SPAN
CLASS="QUOTE"
>"재사용"</SPAN
>한다.
    내부적으로 WAL 레코드들의 상태 정보를 찾아서 이미 체크포인트 작업이 일어난 것에 대해서는 더 이상 사용하지 않는 상태로 바꾸고, 
    그 자리에 새로운 WAL 레코드를 기록하는 방식으로 재사용한다.
   </P
><P
>    WAL 아카이브 파일을 만들면 어떤 WAL 세그먼트 파일을 재사용하기 전에 
    기존에 있던 WAL 레코드 정보를 다른 곳(같은 호스트 내일 수도 있고, NFS
    마운트 위치일 수도 있고, 심지어 테이프 같은 곳일 수도 있다)에 따로 
    보관하는 작업을 한다. 보관하는 방법은 관리자가 직접 지정한다.
    이미 똑같은 이름의 파일이 있는 경우에 대해서도 관리자가 결정하도록 한다.
    다만 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버에서는 WAL 세그먼트 파일을 재사용할 
    때 그 전에 관리자가 설정한 <SPAN
CLASS="QUOTE"
>"보관하는 방법"</SPAN
>에 따른 
    작업만 수행한다. 이 아카이브 보관 방법으로 단순하게 <TT
CLASS="LITERAL"
>cp</TT
> 명령을 
    이용할 수도 있고, 이보다 훨씬 복잡한 사용자 정의 쉘 스크립트를 사용할 수도 있고,
    백업 솔루션의 명령을 쓸 수도 있다. 이 부분은 전적으로 관리자 몫이다.
   </P
><P
>    WAL 아카이브 파일을 만들려면, 환경설정 매개변수 wal level의 값으로
    <TT
CLASS="LITERAL"
>archive</TT
> (또는 <TT
CLASS="LITERAL"
>hot_standby</TT
>)를 지정한다.
    그 다음 환경설정 매개변수 archive mode 값에는 <TT
CLASS="LITERAL"
>on</TT
>,
    환경설정 매개변수 archive command 값에는 적당한 시스템 명령어를 지정한다. 
    이 설정은 모두 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 안에서 설정한다.
    <TT
CLASS="VARNAME"
>archive_command</TT
> 값으로 지정할 쉘 명령어에는
    <TT
CLASS="LITERAL"
>%p</TT
> (WAL 로그파일 절대경로), <TT
CLASS="LITERAL"
>%f</TT
> (보관할 로그 파일 이름) 예약 인자를 
    사용할 수 있다.
    <TT
CLASS="LITERAL"
>%</TT
> 글자 그대로 써야할 경우면 <TT
CLASS="LITERAL"
>%%</TT
>를 입력한다.
    일반적으로 이 설정 값은 다음과 같은 형태로 사용된다.
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</PRE
><P>
    위 설정은 단순하게 WAL 세그먼트 파일을 <TT
CLASS="FILENAME"
>/mnt/server/archivedir</TT
> 디렉토리로 이름을 똑같게 해서 복사하는 설정이다.
    위 예제는 Unix와 Windows 운영체제에 대한 한 예제일 뿐이다. 
    실제 설정은 해당하는 운영체제에 맞게 변경 되어야한다.
    <TT
CLASS="LITERAL"
>%p</TT
> <TT
CLASS="LITERAL"
>%f</TT
> 예약 인자들은 다음과 같이 변경되어 실제로 명령이 실행된다.
</P><PRE
CLASS="PROGRAMLISTING"
>test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</PRE
><P>
    이렇게 실행 하면 WAL 로그파일을 항상 특정 위치에 새롭게 만들 것이다.

   </P
><P
>    이 아카이브 명령은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버를 실행했던 
    시스템 사용자 권한으로 실행된다. 그래서 WAL 세그먼트 파일을 처리하는 
    것과 같이 이 파일의 아카이브 파일도 처리시 보안 정책을 고려해야한다. 
    누구나 읽고 덮어 쓰고 지울 수 있으면 치명적인 보안 사고가 발생할 수 있음을 주의해야 한다.
   </P
><P
>    또 하나 주의할 사항은 아카이브 명령의 쉘 실행 리턴값은 그 명령이 성공 했을 경우 0(zero) 아니면 
    다른 값이 되도록 해야한다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버는 이 리턴값으로
    로그 파일을 잘 보관했는지 실패했는지를 판단하고, 성공했으면 
    원본 로그 파일을 지우거나 재사용하고, 실패하면 성공할 때까지 재시도한다.
   </P
><P
>    이 아카이브 명령으로 이미 있는 파일을 덮어쓰지 않도록 해야한다.
    덮어 쓰면 복원 작업시 의도치 않은 오류가 발생할 수 있다.
    (해당 파일은 이미 다른 데이터베이스에서 생성했거나 사용할 수도 있기 때문이다.)
    로그 파일이 이미 있으면 끊임 없이 오류를 발생시키기 때문에 관리자가 
    수동으로 처리하는 것이 가장 안전하다.
   </P
><P
>    로그 파일을 보관 하는 작업을 하기 전에 먼저 그 파일이 이미 존재 하는지 확인하고, 
    존재하는 경우 해당 명령어가 0 아닌 값을 리턴하도록 설정하는 것이 좋다. 
    Unix에서는 이 작업을 위해, <TT
CLASS="COMMAND"
>test</TT
> 명령을
    제공하고 있다. 일부 Unix 플랫폼에서는 이미 있는 파일을 덮어쓰지 않기 위해
    <TT
CLASS="COMMAND"
>cp</TT
> 명령에서 <TT
CLASS="OPTION"
>-i</TT
> 옵션을 제공하는데 
    이 명령을 사용할 때는 반드시 리턴값을 확인해야 한다. (GNU <TT
CLASS="COMMAND"
>cp</TT
>
    명령은 로그 파일이 존재하는 경우 0 값을 리턴하는데, 이는 바람직하지 않다.)
   </P
><P
>    WAL 파일을 따로 저장하는 작업을 할 때, 
    운영상 작업을 수동으로 중지 하는 경우 혹은 저장 공간이 부족해서 저장 작업이 실패하는 경우가 반복될 수 있으므로 잘 생각해 봐야 한다.
    예를 들어, WAL 세그먼트 파일을 테이프 저장장치로 보관하려고 하는데, 해당 장치가 자동으로 테이프 교환을 하지 않고 테이프에 여유 공간이 없으면 
    사용자가 테이프를 바꾸기 전까지 계속해서 파일 기록 작업을 실행했다가 오류를 내고 다시 실행할 것이다.
    이렇게 되면, <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리에서는 테이프 저장장치로
    자료가 안전하게 복사되지 않았기 때문에 해당 WAL 세그먼트 파일을 삭제하거나
    재사용하지 않을 것이고, 이후 만들어지는 새로운 WAL 세그먼트 파일들은 
    계속 쌓여서 결국 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리의 여유 공간이 
    없어지고 서버가 PANIC 오류를 발생시키면서 중지하게 된다. 
   </P
><P
>    또한 WAL 파일을 따로 저장할 때의 그 저장 장치의 자료 기록 속도도 함께 
    고민해야 한다. 정상적으로 작업이 진행된다 하더라도 WAL 파일을 만들어내는 
    속도가 그 파일을 따로 보관하는 속도보다 빠르면, 똑같은 문제가 발생할 
    수 있다. 물론 따로 보관하는 속도가 다소 늦더라도 정상적으로 이루어지고  
    <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리에 여유공간이 충분히 있으면 별 문제 되지는 않지만, 
    그렇지 않을 경우 위 문제가 발생할 여지가 있다.
    이 기능을 사용하기 전에 충분히 이 부분에 대한 문제를 고민해 
    보아야하며, 관리자는 이 기능이 의도된 대로 잘 작동하는지 감시해야한다.
   </P
><P
>    저장 파일의 경로는 최대 64 개의 ASCII 글자면 되고, 파일 이름은 <TT
CLASS="LITERAL"
>%f</TT
>
    예약어를 사용해야하며, (즉, 디렉토리까지만 바꿀 수 있다.) 
    원본 WAL 세그먼트 파일은 <TT
CLASS="LITERAL"
>%p</TT
> 예약어를 사용해야한다.
   </P
><P
>    WAL 파일에는 트랜잭션 작업 정보만 담겨있기 때문에 
    <TT
CLASS="FILENAME"
>postgresql.conf</TT
>, <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>, <TT
CLASS="FILENAME"
>pg_ident.conf</TT
>
    파일의 변경 사항이 이 백업 방법으로는 복원 되는 데이터베이스에 반영되지 않는 점을 주의해야 한다.
    이 환경설정 파일 백업은 시스템의 일반 파일 백업 정책에 따라 백업하길 바란다.
    이 환경설정 파일 백업을 위해서 해당 파일의 위치를 바꾸려면, <A
HREF="runtime-config-file-locations.html"
>2.2절</A
> 항목을 참조하라.
   </P
><P
>    아카이브 명령은 WAL 파일 가운데 서버에 모두 반영된(롤백되거나 커밋 되어 체크포인트 작업이 끝난) 파일에 대해서 실행된다.
    즉, 작업량이 아주 적은 데이터베이스의 경우라면 아카이브 명령이 실행되는 간격이 아주 길어진다. 
    이 간격에서 데이터베이스 장애가 생기면 자료 손실이 그 간격 동안 생기게 되므로 WAL 세그먼트 파일의 모든 
    내용이 처리되기 전에 특정 시간이 지나면 강제로 아카이브 명령을 사용해서 
    이 세그먼트 파일을 따로 저장해야 하는데, 이는 <TT
CLASS="VARNAME"
>archive_timeout</TT
> 값을 
    짧게 지정하면 된다. 이 설정값을 너무 짧게 잡으면 디스크 공간을 낭비하는 
    단점이 생긴다. 일반적으로 이 설정값은 분 단위가 적당하다.
   </P
><P
>    또한 사용자가 강제로 세그먼트 파일을 <CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
> 함수를 이용해서 바꿀 수 있다. 
    일반적으로 대량 자료 입력, 변경, 삭제 작업이 일어나고 이것에 대한 즉시 백업이 필요한 경우에 이 함수를 사용한다. 
   </P
><P
>    <TT
CLASS="VARNAME"
>wal_level</TT
> 값을 <TT
CLASS="LITERAL"
>minimal</TT
>로 설정하게 되면 이 WAL 로그를 따로 보관해서 
    그것을 기반으로 복원 하는 기능을 사용할 수 없다. 
    이 설정을 사용하면 WAL 파일에 복원 관련 정보를 보관하지 않기 때문이다. 
    그렇기 때문에 <TT
CLASS="VARNAME"
>wal_level</TT
> 설정값을 변경하면 서버를 재실행해야한다. 
    하지만 <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값은 환경 설정 파일을 다시 로드하는 것으로도 충분하다.
    필요에 따라서 운영 중에 이 작업이 중지되어야할 필요도 있기 때문이다.
    그렇게 하려면 <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값으로 빈문자열(<TT
CLASS="LITERAL"
>''</TT
>)로 지정하면 된다. 
    그러면 <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값이 다시 WAL 파일을 복사하는 작업을 하기 전까지 
    <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리에 계속 남아있게 된다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-BASE-BACKUP"
>8.3.2. 베이스 백업 만들기</A
></H2
><P
>   베이스 백업을 만드는 가장 손쉬운 방법은 pg basebackup 툴을 사용하는 것이다.
   이 툴을 이용하면 일반적인 파일이나 tar 묶음 파일로 베이스 백업 파일을 만들 수 있다. 
   pg basebackup 툴을 이용하는 방법보다 유연하게 백업을 하고 싶으면, 저수준 API를 이용해서 사용자 정의 백업 방식을 구현할 수 있다.
   (<A
HREF="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP"
>8.3.3절</A
> 참조)
   </P
><P
>   베이스 백업을 만드는 데 걸리는 시간은 우려할 필요가 없다. 
   하지만 운영 서버가 <TT
CLASS="VARNAME"
>full_page_writes</TT
> 비활성화 상태로 운영 되고 있으면, 
   베이스 백업을 하는 동안 자동으로 <TT
CLASS="VARNAME"
>full_page_writes</TT
> 설정이 활성화 되어
   서버의 성능이 약간 떨어질 것이다.
   </P
><P
>   이 베이스 백업을 이용해서 복구 작업을 하면, 베이스 백업 작업에서 파일 시스템 복사를 
   시작하는 시점부터 복사가 끝나는 시점까지 만든 모든 WAL 파일을 따로 보관하고 있어야 한다.
   어떤 파일부터 따로 보관해야 하는지는 베이스 백업을 시작하는 시점부터 백업이 끝나는 시점까지
   생성된 WAL 파일을 <I
CLASS="FIRSTTERM"
>백업 내역 파일</I
>에 기록해 둔다. 이 파일의 이름은 
   복구에 필요한 WAL 파일의 첫번째 파일 이름을 사용한다. 예를 들어서, 
   필요한 파일이 <TT
CLASS="LITERAL"
>0000000100001234000055CD</TT
> 이라면, 백업 내역 파일은 
   <TT
CLASS="LITERAL"
>0000000100001234000055CD.007C9330.backup</TT
> 파일이다. 이 파일 또한 pg_xlog 디렉토리
   안에 있으면, 베이스 백업이 끝나 이 파일이 만들어졌을 때 아카이빙 작업에 의해 WAL 세그먼트 파일과 
   함께 따로 보관하는 장소에 복사된다. (WAL 세그먼트 파일 이름 뒤에 있는 정보는 
   파일의 정확한 시작 위치인데 이 부분은 무시해도 좋다.) 베이스 백업이 끝나면 
   백업 내역 파일의 이름을 보고 알파벳 순으로 그 이름보다 이전이면 복구를 하는데 사용되지 않는다. 
   그러므로 다중 백업 환경이 아니면 오래된 WAL 세그먼트 파일들은 파일 시스템에서 삭제되어도 
   무방하다. 다중 백업 환경이면 각 백업 복구에 필요한 모든 WAL 세그먼트 파일들을 
   잘 정리해 두어야한다.
   </P
><P
>   백업 내역 파일은 크기가 작은 단순 텍스트 파일이다. 
   이 파일에는 pg basebackup 툴에서 자동으로 지정한 백업 라벨과 백업 복구에 필요한 WAL 세그먼트 파일 이름 정보와 백업 시간이 기록되어있다.
   백업본을 구분하기 위해 라벨을 사용할 때, 이 백업 내역 파일을 이용한다.
   </P
><P
>   베이스 백업 주기는 전체 백업량과 그 백업 간격 사이 만들어지는 WAL 세그먼트 파일의 양, 백업 파일을 보관하는 속도, 
   여유 공간, 복구할 때 소요되는 시간까지 여러 부분을 고려해야한다. 
   &mdash; WAL 세그먼트 파일이 많으면 베이스 백업을 준비해도 그 파일을 모두 반영하는데 시간이 필요하기 때문이다. 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP"
>8.3.3. 저수준 API를 이용한 베이스 백업 만들기</A
></H2
><P
>   저수준 API를 이용해서 베이스 백업을 만드는 방법은 pg basebackup 툴을 사용할 때보다 몇 단계의 작업이 추가 되기는 하지만 상대적으로 간단하다.
   이렇게 작업할 때 가장 주의해야 할 점은 다음 설명할 각 단계가 반드시 정상적으로 수행된 경우에만 다음 단계 작업이 되야한다는 점이다.
  <P
></P
></P><OL
TYPE="1"
><LI
><P
>    서버가 아카이브 모드로 설정되어 있고 WAL 세그먼트 파일들을 따로 보관하는 작업이 실행되는 상태여야 한다.
    </P
></LI
><LI
><P
>    해당 데이터베이스에 슈퍼유저로 접속해서 다음 명령을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('라벨');</PRE
><P>
    <TT
CLASS="LITERAL"
>라벨</TT
> 자리에는 어떤 문자열이 와도 상관 없다. 
    관리자가 해당 백업 작업에 대한 식별자로 사용되는 문자열이면 된다.
    (백업본을 저장하려고 하는 디렉토리의 전체 경로를 이 이름으로 정하는 것도 좋은 방법이다.)
    <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 함수는 먼저 데이터 클러스터 디렉토리에 <TT
CLASS="FILENAME"
>backup_label</TT
> 이라는 파일을 만들고, 
    그 안에 지정한 라벨 문자열과 백업을 시작하는 시간을 기록한다.
    이 파일은 복구할 때 꼭 필요한 파일이기 때문에 백업 결과물에 이 파일이 없거나 손상되었으면 백업 작업을 처음부터 다시 해야한다.
    </P
><P
>    접속한 데이터베이스의 클러스터 디렉토리의 위치는 몰라도 된다. 
    <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 함수의 실행 결과가 오류를 발생시키면 그에 적합한 조치를 취해야겠지만 
    오류를 내지 않으면 이 작업의 내부 작업에 대해서는 신경쓰지 않아도 된다.
    </P
><P
>         기본적으로, <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 함수 실행을 끝내는데, 꽤 긴 시간이 소요되기도 한다. 
         백업 시작 전에 이 함수로 체크포인트 작업을 하는데, 체크포인트에 필요한 I/O가 기본적으로 내부 체크포인트 간격만큼 지속된다.
         (환경 설정 매개변수 <A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>를 참조)
         이는 쿼리 처리 작업에 끼치는 영향을 최소로 줄여주기 때문에 유용하다.
         만일 이렇게 긴 기다림의 시간 없이 바로 백업 준비를 위한 작업을 
         곧바로 하려면 다음과 같은 명령을 사용한다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label', true);</PRE
><P>
     위 명령은 최대한 빨리 체크포인트 작업을 진행시킨다.
    </P
></LI
><LI
><P
>         데이터 클러스터 디렉토리를 시스템 차원에서 백업한다. 
         이 백업 방법은 파일 시스템 백업하는 어떤 방법으로든지 가능하다.
         예를 들면, (<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>, 
         <SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
> 명령어를 사용하는 것이 아니라) <SPAN
CLASS="APPLICATION"
>tar</SPAN
>, <SPAN
CLASS="APPLICATION"
>cpio</SPAN
>같은 
         명령어를 사용하는 것을 말한다. 이 백업 작업을 하는 동안 데이터베이스를 중지 하면 안된다.
    </P
></LI
><LI
><P
>         파일 시스템 차원의 데이터베이스 클러스터 디렉토리에 대한 백업이 
         끝나면 다시 해당 데이터베이스에 슈퍼유저로 접속해서 다음 명령을 실행한다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_stop_backup();</PRE
><P>
     이 작업은 데이터베이스 서버 쪽에 이제 백업이 끝났으니, 지금까지 사용했던 WAL 세그먼트 파일들은 아카이브 보관 작업 처리하는 
         쪽으로 넘기고 새 WAL 세그먼트 파일로 바꾸어서 다시 서버를 일상적인 상태로 실행한다.
    </P
></LI
><LI
><P
>         다음 이 마지막 로그 파일을 보관 하는 작업이 완료되면 베이스 백업은 끝난다.
         <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령이 끝나는 시점은 마지막 사용했던 WAL 파일이 
         <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값으로 지정된 명령으로 무사히 처리되었을 때다. 
         <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령은 <TT
CLASS="VARNAME"
>archive_mode</TT
> 설정값이 on 상태일 때만 실행되며, 
         이 명령이 실행되기 직전까지 사용하고 있던 WAL 파일은 반드시 정상적으로 보관처리가 되어야 끝난다. 
         일반적인 환경에서 이 명령은 짧은 시간 안에 끝나지만, 예상했던 것보다 이 명령 시간이 
         오래 걸리면, <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값으로 지정된 작업에 문제가 있는지 살펴보고, 그 원인을 해결해야한다. 
         또한 <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값이 비어 있어도 이 명령은 끝나지 않는다.
         <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값으로 지정된 작업은 성공 할 때까지 반복 한다는 점도 주의 해야한다.  
         필요하면, <TT
CLASS="VARNAME"
>statement_timeout</TT
> 설정값을 지정해서 <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 작업이 무한 대기 상태로 
         빠지는 것을 막을 수도 있다.
    </P
></LI
></OL
><P>
   </P
><P
>   베이스 백업을 할 때 위와 같은 순서로 직접 하나 하나 작업을 진행할 수도 있지만 pg basebackup 응용 프로그램을 이용할 수도 있다.
   이 프로그램은 위 작업을 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버로 연결해서 
   해당 쿼리를 실행하고, 리플리케이션 프로토콜을 이용해서 데이터 파일들을 복사하고, 
   마무리까지 (필요하다면, 백업 중간에 변경 된 xlog 파일의 적용까지) 
   한 번에 할 수 있다. 또한 이 프로그램은 <CODE
CLASS="FUNCTION"
>pg_start_backup()</CODE
>/<CODE
CLASS="FUNCTION"
>pg_stop_backup()</CODE
>
   함수를 이용하는 파일 시스템 기반 베이스 백업을 하고 있는 중에도 사용할 수 있다.
   </P
><P
>    몇몇 파일 시스템 백업 툴들은 파일 복사 도중에 그 파일이 변경되면 경고나 오류를 내는 경우도 있다.
        운영 중인 데이터베이스를 대상으로 베이스 백업을 만들고 있는 상황에서 이 경고나 오류는 정상적인 것이다.
        하지만 이 베이스 백업 작업 자체의 오류와 위 파일이 변경되어서 발생하는 오류를 구분할 필요가 있다. 예를 들어서, 
        <SPAN
CLASS="APPLICATION"
>rsync</SPAN
> 프로그램의 어떤 버전은 <SPAN
CLASS="QUOTE"
>"사라져 버린 원본 파일"</SPAN
>에 대한 처리를 할 때, 
        실행 결과 리턴값을 다르게 처리한다. 이것을 이용하면 리턴값을 조사해서 정상적인 처리와 오류 처리를 구분하는 
        백업 스크립트를 작성할 수도 있을 것이다.
        또한, 어떤 <SPAN
CLASS="APPLICATION"
>tar</SPAN
> 버전에서는 위와 같은 경우와 물리적인 묶는 작업 실패에 대한 구분을 하지 않고 같은 리턴 값으로
        작업이 종료되기도 한다. 다행히, GNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
> 1.16 이후 버전부터는 백업 도중 원본 파일이 변경된 경우는 1, 
        그 외 오류인 경우는 2를 리턴하면서 종료한다.
   </P
><P
>    <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 명령이 실행되고 <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령을 실행하기 전까지 파일 시스템을 
        복사하는 작업 시간에 대해서는 신경 쓰지 않아도 된다. 
        데이터 클러스터 전체를 시스템 차원의 백업 시간과 같이(또는 이 보다 더 늦게) 
        처리 되어도 괜찮다. 단, 서버 환경 설정이 <TT
CLASS="VARNAME"
>full_page_writes</TT
> off 
        상태로 운영되고 있던 서버이면 <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 명령을 실행할 때 
        이 값이 on 되기 때문에 <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령이 
        실행되기 전까지 그 만큼의 성능 저하가 발생 할 것이다.
        이 작업에서 신경 써야 할 부분은 베이스 백업 작업이 길어지고 있을 때 
        또 새로운 백업을 시도할 경우 이 명령은 무시 되고 그 백업 스크립트 
        오류로 <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령이 의도되지 않게 실행되어 
        기존 베이스 백업 작업을 망치는 경우다. 이 베이스 백업을 할 때는 
        반드시 위에서 언급한 절차가 모두 순차적으로 끝나야 한다. 중간 작업이 실패하면, 
        그 백업본은 사용할 수 없다.
   </P
><P
>   백업본을 만들 때는 반드시 데이터 클러스터 디렉토리(대개, 이 디렉토리의 이름은 <TT
CLASS="FILENAME"
>/usr/local/pgsql/data</TT
> 이다.)
   안에 있는 모든 파일을 보관해야한다. 
   또한 기본 테이블스페이스 외에 다른 사용자 정의 테이블스페이스를 사용하면 그 파일들로 모두 보관해야한다. 
   그렇게 하지 않으면 복원 작업이 정상적으로 이루어지지 않는다.
   </P
><P
>    한편, 데이터 클러스터 디렉토리에 대한 백업본을 만들 때 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리를 빼야한다.
        이는 클러스터 디렉토리 안에 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리를 두지 않고 그냥 심볼릭 링크로 만들어 사용하면 손쉽게 처리할 수 있다. 
        또한 복원 작업을 손쉽게 하기 위해서 데이터베이스 서버가 실행 중일 때만 생기는 <TT
CLASS="FILENAME"
>postmaster.pid</TT
>,
        <TT
CLASS="FILENAME"
>postmaster.opts</TT
> 파일들의 백업본을 만들 때, 제외해두면 좋다. 
        이 파일들이 있으면, <SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
> 명령으로 서버를 실행하려고 할 때 문제가 발생한다. 
        그래서 수동으로 정리작업을 해 주어야한다.
   </P
><P
>    디렉터리 안에 덤프파일을 만들어서 리플리케이션 슬롯 대신 백업 일부로 사용할 수 있다. 
    그렇게 하지 않으면 대기 서버를 만들 때마다 마스터 서버에 연결된 리플리케이션 사용자가 계속 마스터 서버의 슬롯을 업데이트하고, 
    hot standby feedback이 활성화된 상태에선 마스터가 폭발할 지도 모른다. 
    백업이 새 마스터를 만들 때만 사용된다 하더라도 리플리케이션 슬롯을 복사하는 것은 좋지 않다. 
    슬롯의 컨텐츠도 새 마스터가 연결된 때에는 이미 오래된 정보일 가능성이 높기 때문이다.
   </P
><P
>    이 백업본을 정상적으로 사용하려면 파일 시스템 백업을 시작 한 뒤부터 생긴 WAL 세그먼트 파일들을 모두 보관하고 있어야 한다.
        이 작업을 쉽게 할 수 있도록 <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 함수가
        실행 되면 <I
CLASS="FIRSTTERM"
>백업 내역 파일</I
>을 만들어 WAL 아카이브 영역 쪽에서 
        즉시 보관한다. 이 파일 이름은 백업을 시작하면서 첫 체크포인트 작업을 한 다음 세그먼트 번호로 결정된다.
    예를 들어, WAL 세그먼트 파일의 백업이 필요한 파일 이름이 <TT
CLASS="LITERAL"
>0000000100001234000055CD</TT
>면, 백업 내역 파일의 이름은 
        <TT
CLASS="LITERAL"
>0000000100001234000055CD.007C9330.backup</TT
>으로 된다. 
        (이 이름의 두번째 부분은 해당 세그먼트 내의 정확한 위치를 나타내는데, 크게 신경쓰지 않아도 된다.)
        이렇게 해서 이 파일 이름의 세그먼트 파일과 파일 시스템 백업 과정에 생긴 
        WAL 세그먼트 파일들만 보관하면, 정상적인 복구가 가능하다. 즉, 이 백업 시작 전 
        세그먼트 파일들은 더 이상 필요 없다. (일반적으로 쓸모 없는 파일들은 
        16진수로, 백업 내역 파일의 이름보다 작다.) 하지만, 
        현재 베이스 백업으로 복원이 불가능한 경우를 대비해서 
        이전 WAL 세그먼트 파일들도 따로 보관해 둘 필요도 있다.
   </P
><P
>    백업 내역 파일은 작은 텍스트 파일이다. 이 파일 안에는 
        <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 함수를 실행할 때 지정한 
        라벨 문자열이 있고 파일 시스템 백업 시작, 종료 시간, 각 WAL 세그먼트 파일 이름이 기록되어 있다.
        파일 시스템 백업과 관련된 라벨을 잘 이용하면 여러 개의 베이스 백업본을 독립적으로 보관할 수 있으며 
        필요에 따라 그 라벨을 보고 선택적으로 복원 작업을 할 수 있다.
   </P
><P
>    정상적인 복원 작업이 이루어지게 하려면, 이처럼 마지막 베이스 백업 작업을 
        끝낸 뒤부터 다음 베이스 백업 작업을 할 때까지의 간격에 대해서 
        고민할 필요가 있다. 간격이 길면, 그 만큼 복원 작업에서 사용될 
        WAL 세그먼트 파일이 많아지기 때문이다. 또한 백업 저장 장치의 
        공간도 고려되어야 한다. 백업 저장 장치의 입출력 속도와 여유 공간과 데이터베이스 서버에서 만들어내는 WAL 세그먼트 파일들과
        베이스 백업을 하는 동안 데이터베이스 서버의 서비스 영향도
        모두 고려해서 가장 적당한 백업 주기를 선택하는 것이 좋다.
   </P
><P
>    또한, 데이터베이스 클러스터 디렉토리 안에 있는 <TT
CLASS="FILENAME"
>backup_label</TT
> 파일도
        신경써야한다. 이 파일은 <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
> 함수가 실행될 때 만들어지며 
        <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 함수가 실행될 때, 해당 디렉토리에서는 삭제 되고 
        WAL 세그먼트 파일 백업 처리와 같은 방식으로 보관된다.  
        즉, 베이스 백업본에는 반드시 이 <TT
CLASS="FILENAME"
>backup_label</TT
> 파일이 있게 된다. 
        베이스 백업이 완료되면 실행 되는 서버 쪽에서는 이 파일이
        없어야하고, 백업본에는 이 파일이 있는 것이 정상이다.
        만일 그렇지 않다면, 해당 베이스 백업은 비정상적으로 처리된 것이다.
        따라서 백업 도중 데이터베이스 서버가 중지 되어 버린 경우 이 점을 감안해서 베이스 백업본을 사용할 수 있는지를 판단해야한다.
     또한, 이 <TT
CLASS="FILENAME"
>backup_label</TT
> 파일은 복구 작업에 반드시 필요한 정보들을 
     포함 하고 있기 때문에, 이 파일은 임의로 삭제 해서는 안된다.

   </P
><P
>    서버가 중지된 상태라면, 간단하게 데이터베이스 클러스터 디렉토리 전체를 
        백업하는 것으로도 충분하다.  이 때는 당연히 <CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>,
        <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 함수를 사용하지 않는다. 그러므로 
        서버가 정상적으로 중지된 것이 아니라면 서버가 복원될 때 이 WAL 파일을 
        사용할 수 있도록 수동으로 따로 보관해야할 필요가 있다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-PITR-RECOVERY"
>8.3.4. 아카이브 모드 백업을 이용한 복구</A
></H2
><P
>    이제 최악의 사고가 일어났을 때 아카이브 모드 백업 방식으로 보관해둔 백업을 가지고 데이터베이스 서버를 복구하는 방법에 대해서 설명한다.
    작업 순서는 다음과 같다.
  <P
></P
></P><OL
TYPE="1"
><LI
><P
>     서버가 실행 중이면, 먼저 서버를 중지한다.
    </P
></LI
><LI
><P
>         만일 시스템의 디스크 공간이 넉넉하면, 데이터베이스 클러스터 디렉토리 전체 및 관련된 사용자 정의 테이블스페이스의 파일들과 
         필요한 WAL 세그먼트 파일들을 모두 임시 장소에 복사해야 한다.
         이 작업을 기존에 운영 중이던 시스템에서 하려면, 적어도 두 배 이상의 디스크 공간이 필요하게 된다. 
         이런 여유 공간이 없으면 적어도 기존 데이터베이스 서버의 클러스터 디렉토리 안에 있는 
         <TT
CLASS="FILENAME"
>pg_xlog</TT
> 파일들과 서버 환경 설정 파일들 만이라도 저장한다.
     백업한 WAL 세그먼트 파일들과 미처 백업 되지 못한 WAL 세그먼트 파일들을 모두 저장하면 서버가 중지되기 직전의 상태로 복구될 수 있다.
    </P
></LI
><LI
><P
>         기존 서버용 데이터 클러스터 디렉토리와 기존 테이블스페이스용 디렉토리를 모두 
         지운다. 
    </P
></LI
><LI
><P
>         백업 파일을 원래의 위치에 그대로 복사한다. 이 때 작업하는 사용자는 데이터베이스 서버를 
         실행하는 시스템 사용자여야한다. (<TT
CLASS="LITERAL"
>root</TT
>로 작업하면, 반드시 
         해당 소유주로 변경해야한다!) 그래서 파일 접근 권한과 소유주를 시스템 사용자와 
         같게 맞추어야한다. 다음 사용자 정의 테이블스페이스를 사용할 때  
         <TT
CLASS="FILENAME"
>pg_tblspc/</TT
> 디렉토리 내에 심볼릭 링크로 되어 있는 원본 디렉토리와 
         그 안에 있는 모든 파일을 복사해 둔다.
    </P
></LI
><LI
><P
>         <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리는 비워둔다. 만일 이 디렉토리 안에 파일이 있으면 
         지워야한다. 복구 작업에서 이 디렉토리 안에 필요한 파일들은 자동으로 만들어진다. 
         만일 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리를 백업 대상에서 제외했으면 
         디렉토리를 만들거나 심볼릭 링크를 만들어 데이터베이스 서버가 해당 디렉토리를 
         사용할 수 있도록 한다. 이 때도 이 디렉토리의 접근권한과 소유주가 데이터베이스
         서버를 실행하는 시스템 사용자만 사용할 수 있는지 확인해야한다.
         만일 심볼릭 링크면 혹시 옛 데이터베이스에서 사용하는 원본 경로와 같아서
         옛 자료들을 덮어쓸 수도 있는지 꼭 확인해야한다.
    </P
></LI
><LI
><P
>         만일 WAL 세그먼트 파일에 대한 백업본이 없으면 
         2단계에서 복사해 둔 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 내의 파일들을 복구하려는 곳으로 복사한다. 
         (옮기지 말고 복사하길 권한다. 아직 복구가 완벽하게 이루어지지 않았기 때문에, 복사가 안전하다.)
    </P
></LI
><LI
><P
>         데이터베이스 클러스터 디렉토리 안에 <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일을
         만든다. (이 파일의 내용에 대한 자세한 설명은 <A
HREF="recovery-config.html"
>10장</A
> 참조)
         또한 복구 과정 중에 외부에서 접근할 수 없도록 
         임시로 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일을 수정하는 것도 좋은 방법이다.
    </P
></LI
><LI
><P
>         서버를 실행한다. 서버는 복구 모드로 가동되면서 
         필요한 WAL 파일들을 찾아서 반영되지 않았던 트랜잭션들을 
         일괄 처리하기 시작한다. 복구 작업 도중 외부 영향으로 서버가 
         중지 되면, 단순히 서버를 재실행해서 복구 작업을 계속 
         진행한다. 복구 작업이 끝나면 서버는 복구 모드로 재실행 되는 것을 막기 위해 
         <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일을 <TT
CLASS="FILENAME"
>recovery.done</TT
> 이름으로 바꾸고
         정상 실행 상태로 클라이언트의 접속을 기다린다. 
    </P
></LI
><LI
><P
>         이제 데이터베이스로 접속해서 자료가 정상인지 살펴보고 만일 원하는 대로 복구 되지 않았으면 서버 로그를 살펴보면서 
         1단계부터 다시 진행한다. 자료가 모두 정상이고, 데이터베이스 상태도 정상이면 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일의 내용을
         원래대로 수정해서 외부 접속도 허용한다.
    </P
></LI
></OL
><P>
   </P
><P
>    이 복구 방법의 핵심은 어떻게 백업 WAL 세그먼트 파일을 데이터베이스에 
        적용시키냐는 것과 그 복구를 어느 시점까지 할 것이냐이다.
        이것을 <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일에서 지정한다.
        이 파일을 만드는 간단한 방법은 먼저 데이터베이스 배포판의
        <TT
CLASS="FILENAME"
>share/</TT
> 디렉토리 안에 <TT
CLASS="FILENAME"
>recovery.conf.sample</TT
> 파일을
        복사해서 필요한 부분만 수정해서 사용하는 것이다.
        <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일에서 꼭 필요한 부분은
        <TT
CLASS="VARNAME"
>restore_command</TT
> 부분이다.
    이 설정은 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 백업본 WAL 세그먼트 파일을 
        어떻게 적용시킬 것인가에 대한 정의다.
        간단하게 설명하면 서버 환경 설정 가운데 <TT
CLASS="VARNAME"
>archive_command</TT
>
        설정과 반대되는 명령을 지정하면 된다. 여기서 사용되는 예약어는 
        <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값을 지정할 때와 같다. 
        <TT
CLASS="LITERAL"
>%f</TT
> 값은 백업 아카이브 디렉토리 안에 있는 파일이름이 되고, 
        <TT
CLASS="LITERAL"
>%p</TT
> 값은 트랜잭션 로그 파일로 대체된다. (상대 경로를 사용하면, 
        서버를 실행하는 현재 디렉토리를 기준으로 처리된다.) <TT
CLASS="LITERAL"
>%%</TT
> 예약어는
        <TT
CLASS="LITERAL"
>%</TT
> 문자로 처리된다. 다음은 일반적인 이 설정값이다.
</P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'cp /mnt/server/archivedir/%f %p'</PRE
><P>
    위 설정은 <TT
CLASS="FILENAME"
>/mnt/server/archivedir</TT
> 디렉토리 안에 있는 
        미리 백업 해둔 WAL 세그먼트 파일들을 복구 작업을 진행할 때 
        사용한다. 물론 이 명령은 사용하는 백업 장치에 따라서
        훨씬 복잡할 수도 있으며, 테이프 백업 장치처럼 
        해당 테이프를 마운트하고 원하는 위치로 이동하는 등 일부 
        명령어들을 포함하여 직접 쉘 스크립트를 만들어서 사용할 수도 있다.
   </P
><P
>    여기서 중요한 점은 여기서 지정한 작업이 실패 했을 경우 
    그 작업의 리턴값이 0이 아닌(nonzero) 것이어야 한다는 점이다.
    이 작업은 아카이브 백업 디렉토리 안에 없는 파일도 요청한다.
    이 때 이 작업의 결과는 반드시 0이 아닌 리턴값을 리턴해야한다.
    이 상황은 오류가 아니다. 해당 스크립트에서 명령어가 없다거나 서버가 정상 종료되면서 
    복구작업을 하는 프로세스로 <SPAN
CLASS="SYSTEMITEM"
>SIGTERM</SPAN
>
    시그널을 보내는 경우가 아닌 기타 다른 시그널로 그 작업이 
    중지 되는 경우가 오류 상황이다. 이런 상황에는 복구 작업이 중지 되고, 
    서버는 정상 작동을 하지 않고 멈춘다.
   </P
><P
>        서버는 <TT
CLASS="LITERAL"
>.backup</TT
> 또는 <TT
CLASS="LITERAL"
>.history</TT
> 이름으로 끝나는 
        파일을 찾을 수 있는데, 이 때 그 파일이 없으면 그 파일이 없다고 (0 아닌 값을 리턴함으로써)
        서버 쪽에 알려주어야한다. 
        또한, <TT
CLASS="LITERAL"
>%f</TT
> 파일 이름과 서버 쪽으로 복사되는 <TT
CLASS="LITERAL"
>%p</TT
> 파일 이름이 
        항상 같지는 않다. 그렇기 때문에, 쉘 스크립트를 직접 만들어 사용하면 
        이 부분에 대한 처리에 실수가 없도록 주의해야한다.
   </P
><P
>    아카이브 백업 디렉토리에서 WAL 세그먼트 파일을 못 찾으면 
        데이터 클러스터 안에 있는 <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 디렉토리 안에서 찾는다.
        혹시 처리해야할 WAL 세그먼트 파일이 더 있는데 
        미처 백업 되지 않은 것이 있으면 그것까지도 처리해 준다.
        하지만 똑같은 파일이름으로 아카이브 백업 디렉토리 안에 이미 
        그 파일이 있으면 그 파일이 적용되고, <TT
CLASS="FILENAME"
>pg_xlog/</TT
> 안에 있던 
        파일은 무시되고 새로운 WAL 세그먼트 이름으로 그 로그를 반영한다. 그렇기 때문에, 
        복구 작업 전에 반드시 WAL 세그먼트 파일들을 잘 정리해야한다.
   </P
><P
>    일반적으로 복구 작업은 아카이브 백업 디렉토리 안에 가장 마지막 로그 파일을 반영하고 
        그 다음 파일이 없을 때까지 찾기 때문에, 
        복구 로그의 마지막은 어떤 파일을 찾을 수 없다는 <SPAN
CLASS="QUOTE"
>"file not found"</SPAN
> 메시지가 출력된다.
        또한 복구 작업을 시작하면서 <TT
CLASS="FILENAME"
>00000001.history</TT
> 형태의 파일을
        찾기도한다. 이 모든 경우는 정상적인 복구 과정 속에서 생기는 로그이다. 
        자세한 이야기는 <A
HREF="continuous-archiving.html#BACKUP-TIMELINES"
>8.3.5절</A
>에서 설명하고 있다.
   </P
><P
>    복구 작업은 <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일에서 
        복구 <A
HREF="recovery-target-settings.html"
>중지 지점</A
>을 
        지정해서 원하는 지점에서 복구 작업을 중지할 수도 있다. 
        이 지점을 <SPAN
CLASS="QUOTE"
>"복구 타겟(recovery target)"</SPAN
>이라고 한다.
        이 기능은 미숙한 데이터베이스 관리자가 실수로 중요 테이블을 삭제하는 것 같은 
        운영상 실수에 대한 복구를 지원하는데 유용하다.
        <SPAN
CLASS="QUOTE"
>"복구 타겟"</SPAN
>은 특정 시각으로 지정할 수도 있고 
        관리자가 미리 지정한 어떤 문자열일 수도 있고 
        특정 트랜잭션 ID로 지정할 수도 있다.
        사고가 어느 트랜잭션 ID에서 발생했는지 알 수 있는 툴을 사용할 수 없으면 
        단순히 특정 시각 또는 관리자가 미리 지정한 어떤 문자열을 지정하는 것이 
        복구 작업을 하기에 손쉽다.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
>          복구 작업을 멈출 시점은 베이스 백업 시간 이후여야 한다.  
          <CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> 명령이 실행된 시간보다 늦은 시점으로 지정해야 한다.
          베이스 백업을 사용해서 데이터 클러스터 파일들을 파일 시스템 차원으로 백업하고 있었던 시간대로 복구할 수는 없다. 
          이 작업이 필요하면 이전 베이스 백업 자료와 해당 WAL 백업 파일들이 필요하다.
     </P
></BLOCKQUOTE
></DIV
><P
>    만일 WAL 파일 자체에 문제가 있으면 정상적으로 처리한 트랜잭션까지만 적용되고 복구 작업을 멈추고, 서버도 중지된다. 
    이런 경우에는 문제가 발생한 시점을 파악해서 처음부터 다시 그 시점 전까지만 <SPAN
CLASS="QUOTE"
>"복구 타겟"</SPAN
> 으로 지정해서 복구한다.
    복구 작업 도중 외부적인 영향으로 작업이 중지 되면 (시스템 리부팅, disk full, .... 이런 이유들) 문제의 원인을 해결해야 한다. 
    그리고나서 단순히 서버를 재실행하면 복구 작업을 이어서 계속 진행한다. 복구 작업은 일반 실행환경에서의 체크 포인트 작업과 같이 재실행된다.
    내부적으로 <TT
CLASS="FILENAME"
>pg_control</TT
> 파일을 주기적으로 갱신해서 이미 반영된 로그들에 대해서는 더이상 재작업을 하지 않도록 하기 때문에 
    중복처리에 대한 염려는 안해도 된다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIMELINES"
>8.3.5. 타임라인</A
></H2
><P
>    어떤 데이터베이스를 특정 시점으로 복원하는 것은 마치 
        공상과학 소설에서 나오는 시간여행이나 다원우주론 같이 
        복잡한 여러 문제점을 만든다.
        예를 들어서, 그 데이터베이스의 최초의 변경 내역에서
        화요일 오후 5시 15분에 중요한 테이블을 지웠고, 
        그것을 수요일 아침까지 몰랐다고 치자. 관리자는 
        침착하게 백업 자료를 가지고, 화요일 오후 5시 14분까지 
        복구를 하고, 서버를 운영했다. 이렇게 해서 두 번째 변경 내역이 
        진행되었고, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>이</I
></SPAN
> 데이터베이스 변경 내역에서는 
        그 테이블이 삭제 되지 않고 계속 운영 되었다. 하지만, 
        좀 있다가 판단해 보니, 이 판단이 바람직한 것이 아닌 것 같아 
        다시 최초의 변화 내역 기준으로 수요일 아침 데이터베이스 상태로
        (그 중요 테이블이 지원진 채로 운영된 상태) 다시 되돌아 가야할 
        필요가 생긴다. 단순하게 생각하면, 이미 한 번 과거로 되돌아 갔고, 
        거기서 이미 WAL 파일을 덮어써 버렸기 때문에, 이 작업이 불가능할 것 같다.
        이 문제를 해결하기 위해서 백업 WAL 세그먼트 파일을 이용한 데이터베이스
        복구 작업을 할 때, 서버가 각각의 복구 작업에 필요한 WAL 세그먼트 파일의
        이름을 다르게 해서 사용한다.
   </P
><P
>    이것을 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는 <I
CLASS="FIRSTTERM"
>타임라인</I
>이라는
        개념으로 설명하고 있다.
        복구 작업이 끝나고, 데이터베이스가 새롭게 실행되면 
        새로운 타임라인 ID로 WAL 레코드를 만든다.
        이 타임라인 ID는 WAL 세그먼트 파일 이름의 한 부분으로 사용되어
        같은 트랜잭션 번호에 대해서도 다른 WAL 파일을 만들 수 있도록 해서 
        예전 데이터베이스 변경 내역 정보를 덮어쓰지 않도록 한다.
        이런 방식이면 얼마든지 다양한 타임라인이 존재할 수 있다.
        필요 없는 기능 같아 보이기는 하지만 이 기능이 가끔 구원자 역할을 톡톡히 한다.
        복구시점을 정확히 모르고 그 시점을 정확하게 찾을 때까지 계속 복구 작업을 
        해야 하는 상황에 아주 유용하게 사용된다.
        타임라인 정보가 없으면 이런 작업은 거의 관리가 안될 정도로 복잡해저버린다.
        타임라인을 사용하면 이미 분기 되어 더이상 사용하지 않는 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>어떠한</I
></SPAN
>
        이전 데이터베이스 상태로도 되돌아갈 수 있다.
   </P
><P
>    새로운 타임라인으로 운영될 때마다 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는
        <SPAN
CLASS="QUOTE"
>"타임라인 내역"</SPAN
> 파일을 만든다. 이 파일에는 언제, 어디서 분기되었는지에 대한
        정보를 담고 있다.
        이 내역 파일은 다중 타임라인이 있을 경우 사용자가 지정한 특정 타임라인을 
        사용할 때 어느 WAL 파일을 사용해야 하는지에 대한 정보를 담고 있어서 복원 작업에 
        사용된다. 즉, 이 파일 또한 새롭게 생성 되면 바로 WAL 세그먼트 파일 백업 처리할 때와 마찬가지로 archive_command 설정값에서 지정한 
        작업을 진행해서 따로 보관 된다. 이 내역 파일은 (큰 크기의 WAL 세그먼트 파일과 달리)
        단순한 텍스트 파일이다. 그래서 충분히 많은 파일들을 보관할 수 있다.
        또한 해당 내역 파일을 문서편집기로 열어서 그 복구 내역에 대한 구체적인 
        내용을 기록해 두면 나중에 여러모로 쓸모가 있을 것이다.
   </P
><P
>    복구 작업에서 기준이 되는 타임라인은 특별히 다른 타임라인을 지정하지 않으며, 
        베이스 백업 당시 사용되었던 타임라인을 사용한다. 
        다른 타임라인을 사용하려면, <TT
CLASS="FILENAME"
>recovery.conf</TT
> 파일에
        원하는 타임라인 ID를 지정해주면 된다. 물론 이 타임라인은 반드시 베이스 백업 뒤에
        사용한 하위 타임라인 가운데 하나여야 한다.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIPS"
>8.3.6. 팁과 예제</A
></H2
><P
>    아카이브 모드를 사용하는 환경설정과 관련된 몇 가지 팁과 예제를 여기서 소개한다.
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-STANDALONE"
>8.3.6.1. 독립된 핫백업</A
></H3
><P
>          <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 백업 방식으로 독립된 핫백업을 구현할 수 있다.
          이 방식으로 구현하면 특정시점 복구는 불가능하지만, 
          장애복구시 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 프로그램을 이용해서 만든 덤프 파일을 
          사용하는 복구보다 훨씬 빠른 시간안에 복구할 수 있다.
          (물론 <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>의 덤프 파일 크기가 데이터 클러스터 디렉토리
          사이즈에 비해 아주 적은 경우 오히려 더 늦을 수도 있다.)
          베이스 백업에서 언급했던 것처럼 독립된 핫백업 서버를 구축하는 
          가장 손쉬운 방법은 pg basebackup 툴을 이용해서 
          베이스 백업을 받는 것이다. pg basebackup을 호출할 때 <TT
CLASS="LITERAL"
>-X</TT
> 매개변수를 쓰면 사용되는 트랜잭션 로그 전체가 
          백업에 자동으로 쓰이고, 그 이상의 작업은 필요 없다. 
     </P
><P
>          백업 파일을 복사하는데 보다 유연한 방법이 필요한 경우, 
          보다 저수준의 작업으로 독립된 핫백업을 구현할 수 있다.
          독립된 핫백업을 구축하려면, <TT
CLASS="VARNAME"
>wal_level</TT
> 값은 
      <TT
CLASS="LITERAL"
>archive</TT
>, <TT
CLASS="VARNAME"
>archive_mode</TT
> 값은
      <TT
CLASS="LITERAL"
>on</TT
>, <TT
CLASS="VARNAME"
>archive_command</TT
> 값으로 
          <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>스위치 파일</I
></SPAN
>이 있는 경우에 한해서 그 파일을 다른 곳에도 보관할 수 있도록
          설정하면 된다. 다음은 이 설정의 예제다.
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'</PRE
><P>
      위 설정은 <TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
> 파일이 없으면
          그냥 건너뛰고, 이 파일이 있으면 복사하려는 WAL 세그먼트 파일이 없는 경우 다른 곳에 복사하는 작업을 한다. (이렇게 해서, 
          <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 서버가 더이상 쓸모가 없는 WAL 파일을 다시 사용할 수 있도록 한다.)
     </P
><P
>      WAL 세그먼트 파일들의 백업 설정을 위와 같이 해 두고, 아래와 같이 베이스 백업 스크립트를 만든다:
</P><PRE
CLASS="PROGRAMLISTING"
>touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/</PRE
><P>
      <TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
> 이름으로 
          스위치 파일을 먼저 만들어 베이스 백업을 준비하는 동안만
          WAL 파일을 다른 장소에 따로 보관하고,
          베이스 백업을 tar 파일로 만들고,
          백업 작업이 끝났다고 서버쪽에 알리고, 스위치 파일을 지우고,
          tar 작업을 하는 동안 생긴 생긴 WAL 파일들을 
          같은 tar 파일에 추가하고 작업을 끝낸다.
      이 때 이 스크립트의 오류를 확인해 예외처리를 해야할 필요도 있다.
     </P
><P
>          저장 공간이 넉넉치 않으면, <SPAN
CLASS="APPLICATION"
>pg_compresslog</SPAN
>
      <A
HREF="http://pglesslog.projects.postgresql.org"
TARGET="_top"
>http://pglesslog.projects.postgresql.org</A
> 프로그램을
          이용해서, 필요없는 full page writes 정보와 
          실제 작업할 내용이 없는 WAL 파일의 영역을 정리해서 보관할 수도 있다.
      그리고 <SPAN
CLASS="APPLICATION"
>pg_compresslog</SPAN
> 프로그램으로 정리된 내용을 
          <SPAN
CLASS="APPLICATION"
>gzip</SPAN
> 프로그램을 이용해서 더 압축할 수도 있다.
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'pg_compresslog %p - | gzip &gt; /var/lib/pgsql/archive/%f'</PRE
><P>
      복구 할 때는 <SPAN
CLASS="APPLICATION"
>gunzip</SPAN
> 프로그램과 <SPAN
CLASS="APPLICATION"
>pg_decompresslog</SPAN
> 프로그램을 다음과 같이 사용한다.
</P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'gunzip &lt; /mnt/server/archivedir/%f | pg_decompresslog - %p'</PRE
><P>
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-SCRIPTS"
>8.3.6.2. <TT
CLASS="VARNAME"
>archive_command</TT
> 스크립트</A
></H3
><P
>          많은 사람들이 <TT
CLASS="VARNAME"
>archive_command</TT
> 설정값으로
          <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일에 아래와 같이 스크립트를 
          사용해서 그 값을 단순화 한다.
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'local_backup_script.sh "%p" "%f"'</PRE
><P>
      아카이빙 작업을 단순한 시스템 명령들의 조합으로 설정하지 않고 하나의 스크립트로 지정해 놓으면 백업 관련 작업과 데이터베이스 관리 작업을
          분리할 수 있어 얻는 이득이 많다. 필요시 그 스크립트만
          수정하면 백업 정책을 언제든지 바꿀 수 있기 때문이다.
          이렇게 하면 자주 쓰는 <SPAN
CLASS="APPLICATION"
>bash</SPAN
> 또는
          <SPAN
CLASS="APPLICATION"
>perl</SPAN
> 스크립트로 작성할 수 있으며 보다 안전하고  
          꼼꼼한 작업을 할 수 있다.
          <DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
>            <TT
CLASS="VARNAME"
>archive_command</TT
> 에서 지정한 스크립트의 로그를 
                서버 로그로 저장하고 싶으면 logging collector 환경 설정값을 on으로 켜두면 된다.
                이렇게 하면 스크립트에서 <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
> 쪽으로 출력하는 모든 
                내용은 서버 로그로 저장된다. 이렇게 해서 보다 손 쉽게 오류를 검사 할 수 있다.
          </P
></BLOCKQUOTE
></DIV
>
          스크립트를 실행하면서 생기는 모든 <TT
CLASS="LITERAL"
>stderr</TT
> 출력은
          데이터베이스 서버 로그로 기록된다. 이렇게 해서, 백업 스크립트 오류를 쉽게 진단할 수 있다.
     </P
><P
>      이 스크립트를 만들 때는 다음 항목들에 대한 고려도 함께 하면 좋다.
      <P
></P
></P><UL
><LI
><P
>         파일이 복사 되면서 발생하는 파일 누출 문제 - 보안 문제
        </P
></LI
><LI
><P
>         WAL 파일 복사(전송, 다른 곳에 따로 보관하는 것)의 가장 안전하고 확실한 방법
         - 실패 했을 경우 재시도에 대한 정책, 복구를 빠르게 하기 위한 이중 백업 등
        </P
></LI
><LI
><P
>         다른 백업, 복구 소프트웨어를 사용할 때의 인터페이스 문제
        </P
></LI
><LI
><P
>         오류 모니터링 소프트웨어와의 인터페이스 문제
        </P
></LI
></UL
><P>
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONTINUOUS-ARCHIVING-CAVEATS"
>8.3.7. 위험부담</A
></H2
><P
>    여기서는 아카이브 모드 백업 기술의 여러가지 한계점을 소개하고 있다.
    이 한계들은 추후 배포판에서 수정될 예정이다.

  <P
></P
></P><UL
><LI
><P
>     해시 인덱스 작업에 대한 기록은 WAL 로그에 포함되지 않는다.
     그래서 이런 인덱스들에 대해서는 대기 서버(복원 서버)에서
     삽입, 갱신 작업을 하지 않는다. 다시 말하면, 이렇게 제대로 반영되지 않은
     인덱스 때문에 원하는 결과가 출력되지 않을 수 있다.
     만일 해시 인덱스를 사용하고 있으면 복원 작업이 끝난 뒤에 수동으로 
     REINDEX 작업을 해야한다.
    </P
></LI
><LI
><P
>     베이스 백업이 시작 된 다음 CREATE DATABASE 명령으로
     새 데이터베이스가 만들어지고, 그 데이터베이스를 만들 때 원본 템플릿 데이터베이스가 베이스 백업이 끝나기 전에 변경 되었으면 
     복원 작업을 할 때 원본과 같은 새 데이터베이스가 만들어지지 않을 가능성이 있다. 이 문제를 피하려면, 베이스 백업 중에는 
     템플릿 데이터베이스를 변경 하지 않는 것이 가장 좋은 방법이다.
    </P
></LI
><LI
><P
>     CREATE TABLESPACE 명령은 거기서 사용하는 실제 경로가
     그대로 반영 된다. 이 말은 복원 하는 시점에 미리 그 실제 경로의 
     디렉토리가 있어야함을 의미한다(물론 처음 테이블스페이스를 만들 때처럼
     그 디렉토리는 비어있고, 소유주와 접근권한이 데이터베이스가 사용할 수 있는 
     상태여야한다).
     이 점은 복원 작업에서 상당한 주의가 필요하다. 
     만일 같은 호스트에서 복원을 하는데 임시 복원 작업을 진행하면서 
     그 테이블스페이스에 있던 원본 파일을 손상 할 수도 있으며 
     다른 호스트에서 테이블스페이스의 실제 디렉토리가 없어서 
     원본 자료를 손실할 수도 있다.
     이 문제를 피해갈 수 있는 가장 좋은 방법은 일단 테이블스페이스를 만들거나 삭제할 경우에는 
     반드시 그 다음에 베이스 백업본을 만들어 두는 것이다.
    </P
></LI
></UL
><P>
   </P
><P
>    또 다른 단점은 기본 <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
> 포맷은 디스크 
    페이지 스냅샷을 많이 포함하고 있어 그 크기가 상당히 크다는 점이다.
    이 페이지 스냅샷 기법은 서버가 갑자기 중지될 경우와 해당 디스크 페이지가
    부분적으로 기록되었을 경우 그 페이지를 안전하게 복구 하기 위해서 도입되었다. 
    물론 사용하고 있는 하드웨어와 소프트웨어에 따라 이런 부분적인 디스크 페이지 
    기록으로 인한 오류가 미비하거나 무시할 정도인 경우도 있다. 
    이럴 경우, full page writes 환경변수 값을 off로 설정하면, 이 로그 전체 크기를 많이 줄일 수 있다.
    이 환경변수값을 off로 설정해도 PITR 기능을 사용할 수 있다.
    또한 <TT
CLASS="VARNAME"
>full_page_writes</TT
> 값이 on 이더라도 
    아카이브 로그를 만들 때 필요없는 페이지 복사본들은 버리고 
    복원에 필요한 것만 담아서 만드는 방식도 도입되어야할 것이다.
    (미래의 개발자들에게 이 일은 넘긴다.)
    운영시 관리자가 체크 포인트 간격을 늘려서 이 WAL 로그를 
    적게 만드는 방법도 한 방법이다.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup-file.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>파일 시스템 기반 백업</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>고가용성, 부하 분산, 복제</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>