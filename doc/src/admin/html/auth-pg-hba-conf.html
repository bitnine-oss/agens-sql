<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>The pg_hba.conf 파일</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="클라이언트 인증"
HREF="client-authentication.html"><LINK
REL="PREVIOUS"
TITLE="클라이언트 인증"
HREF="client-authentication.html"><LINK
REL="NEXT"
TITLE="사용자 이름 맵"
HREF="auth-username-maps.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-30T08:52:27"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="클라이언트 인증"
HREF="client-authentication.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 3. 클라이언트 인증</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="사용자 이름 맵"
HREF="auth-username-maps.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AUTH-PG-HBA-CONF"
>3.1. The <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일</A
></H1
><P
> 클라이언트 인증은 전통적으로 이름이 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>이고 데이터베이스 클러스터의 데이터 디렉토리에 저장되는 
 환경 설정 파일로 제어된다. (<ACRONYM
CLASS="ACRONYM"
>HBA</ACRONYM
>는 호스트 기반 인증(host-based authentication)의 약어이다.) 
 기본 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일은 데이터 디렉토리가 <TT
CLASS="COMMAND"
>initdb</TT
>로 초기화될 때 설치된다. 
 인증 환경 설정 파일을 다른 곳에 배치하는 것도 가능하다. hba_file 환경 설정 파일을 참조 바란다.</P
><P
> <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일의 일반 형식은 한 줄당 하나씩 있는 레코드의 집합이다. 
 빈 줄은 무시된다. <TT
CLASS="LITERAL"
>#</TT
> 주석 문자 뒤의 텍스트도 무시된다. 레코드는 줄을 바꿔서 이어질 수 없다. 
 레코드는 여러 개의 필드로 구성되며, 공백 및/또는 탭으로 구분된다. 
 필드 값에 큰 따옴표를 사용하면 필드에 공백을 포함할 수 있다. 
 데이터베이스 또는 사용자, 주소 필드의 키워드에 따옴표를 사용하면(예: <TT
CLASS="LITERAL"
>all</TT
> 또는 <TT
CLASS="LITERAL"
>replication</TT
>) 
 단어는 자체의 특수한 의미를 상실하고 해당 이름의 데이터베이스 또는 사용자, 호스트와 일치하게 된다.</P
><P
> 각 레코드는 이러한 매개 변수와 일치하는 연결에 사용되는 연결 유형 및 클라이언트 IP 주소 범위(연결 유형에 해당하는 경우), 
 데이터베이스 이름, 사용자 이름, 인증 방법을 지정한다. 
 연결 타입 및 클라이언트 주소, 요청된 데이터베이스, 사용자 이름이 일치하는 첫 번째 레코드는 인증을 수행할 때 사용된다. 
 <SPAN
CLASS="QUOTE"
>"제어 이동(fall-through)"</SPAN
> 또는 <SPAN
CLASS="QUOTE"
>"백업"</SPAN
>은 없다. 
 레코드 하나가 선택되고 인증이 실패한 경우 다음 레코드는 인증되지 않는다. 
 일치하는 레코드가 없으면 액세스가 거부된다.</P
><P
> 레코드는 다음 7가지 형식 중 하나이다.
</P><PRE
CLASS="SYNOPSIS"
>local<TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
host <TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
hostssl<TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
hostnossl<TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
host <TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-mask</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
hostssl<TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-mask</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]
hostnossl<TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-address</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>IP-mask</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
>[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></SPAN
>]</PRE
><P>
 필드의 의미는 다음과 같다.
 <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>local</TT
></DT
><DD
><P
> 이 레코드는 Unix 도메인 소켓을 사용한 연결 시도와 일치한다. 
 이러한 유형의 레코드 없이 Unix 도메인 소켓 연결은 불가능 하다.</P
></DD
><DT
><TT
CLASS="LITERAL"
>host</TT
></DT
><DD
><P
> 이 레코드는 TCP/IP를 사용한 연결 시도와 일치한다. 
 <TT
CLASS="LITERAL"
>host</TT
> 레코드는 <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> 연결 시도 혹은 비 <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> 연결 시도와 일치한다.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>참고: </B
> 기본 동작이 로컬 루프백 주소인 <TT
CLASS="LITERAL"
>localhost</TT
>에 대해서만 TCP/IP 연결을 listen하는 것이므로 
 서버가 적절한 listen_addresses 값으로 시작되지 않으면 원격 TCP/IP 연결이 불가능하다.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>hostssl</TT
></DT
><DD
><P
> 이 레코드는 TCP/IP를 사용한 연결 시도와 일치하지만, <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> 암호화를 사용한 연결에만 해당된다.</P
><P
> 이 옵션을 사용하려면 서버는 <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
> 지원이 내장되어 있어야 한다. 
 또한 <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>은 ssl 환경 설정 매개 변수를 설정함으로써 서버 시작 시에 활성화되어야 한다
 (자세한 내용은 <A
HREF="ssl-tcp.html"
>1.9절</A
> 참조).</P
></DD
><DT
><TT
CLASS="LITERAL"
>hostnossl</TT
></DT
><DD
><P
> 이 레코드 유형은 <TT
CLASS="LITERAL"
>hostssl</TT
>과는 반대로 동작한다. 
 <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>을 사용하지 않는 TCP/IP 상의 연결 시도에 대해서만 일치한다.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>database</I
></TT
></DT
><DD
><P
> 이 레코드가 일치하는 데이터베이스 이름을 지정한다. <TT
CLASS="LITERAL"
>all</TT
> 값은 모든 데이터베이스와 일치하도록 지정한다. 
 <TT
CLASS="LITERAL"
>sameuser</TT
> 값은 요청된 데이터베이스가 요청된 사용자와 이름이 동일한 경우에 레코드가 일치하도록 지정한다. 
 <TT
CLASS="LITERAL"
>samerole</TT
> 값은 요청된 사용자가 요청된 데이터베이스와 이름이 동일한 role의 멤버여야 하는지 지정한다. 
 (<TT
CLASS="LITERAL"
>samegroup</TT
>은 폐지되었지만 <TT
CLASS="LITERAL"
>samerole</TT
>은 계속 쓸 수 있다.) 
 수퍼유저는 직접 혹은 간접적으로 role의 명시적인 멤버가 아닐 경우, 단지 수퍼유저라는 이유로 <TT
CLASS="LITERAL"
>samerole</TT
>에 대한 role의 멤버로 간주되지 않는다. 
 <TT
CLASS="LITERAL"
>replication</TT
> 값은 복제 연결이 요청되는 경우 레코드가 일치하도록 지정한다(복제 연결은 특정 데이터베이스를 지정하지는 않는다). 
 이 경우가 아니라면 특정 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 데이터베이스의 이름으로 사용된다. 
 쉼표로 구분해서 데이터베이스 이름을 여러 개 쓸 수 있다. 데이터베이스 이름이 포함된 파일은 파일 이름 앞에 <TT
CLASS="LITERAL"
>@</TT
>를 붙여서 지정 가능하다.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
></DT
><DD
><P
> 이 레코드와 일치하는 데이터베이스 사용자 이름을 지정한다. <TT
CLASS="LITERAL"
>all</TT
> 값은 모든 사용자와 일치하도록 지정한다. 
 이 외에는, 특정한 데이터베이스 사용자의 이름이거나 앞에 <TT
CLASS="LITERAL"
>+</TT
>를 붙인 그룹 이름이다. 
 (<SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는 사용자와 그룹 이름 간에 실제로 차이는 없다. 
 <TT
CLASS="LITERAL"
>+</TT
> 마크는 실제로 <SPAN
CLASS="QUOTE"
>"이 role의 직접 또는 간접 멤버인 아무 role과 일치함"</SPAN
>을 의미하며, <TT
CLASS="LITERAL"
>+</TT
> 마크가 없는 이름은 유일하게 특정 role과 일치한다.) 
 이러한 이유로, 수퍼유저는 단지 수퍼유저라는 이유 때문이 아니라, 직접 혹은 간접적으로 role의 명시적 멤버인 경우에만 role 멤버로 간주된다. 
 쉼표로 구분해서 사용자 이름을 여러 개 쓸 수 있다. 사용자 이름이 포함된 파일은 파일 이름 앞에 <TT
CLASS="LITERAL"
>@</TT
>를 붙여서 지정 가능하다.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>address</I
></TT
></DT
><DD
><P
> 이 레코드와 일치하는 클라이언트 머신 주소를 지정한다. 
 이 필드는 호스트 이름, IP 주소 범위 또는 아래 설명된 특수 키워드 중 하나를 포함할 수 있다.</P
><P
> IP 주소는 <ACRONYM
CLASS="ACRONYM"
>CIDR</ACRONYM
> 마스크 길이의, 점으로 구분된 십진수(dotted decimal) 표준 표기법으로 지정된다. 
 마스크 길이는 일치해야 하는 클라이언트 IP 주소의 상위 비트 수를 나타낸다. 
 이것의 오른쪽에 있는 비트는 주어진 IP 주소에서 0이어야 한다. 
 IP 주소 및 <TT
CLASS="LITERAL"
>/</TT
>, CIDR 마스크 길이 사이에 공백이 있으면 안 된다.</P
><P
> 이러한 방법으로 지정된 IP 주소 범위의 전형적인 예시는 단일 호스트의 경우 <TT
CLASS="LITERAL"
>172.20.143.89/32</TT
>, 
 소규모 네트워크의 경우 <TT
CLASS="LITERAL"
>172.20.143.0/24</TT
>, 대규모 네트워크의 경우 <TT
CLASS="LITERAL"
>10.6.0.0/16</TT
>일 수 있다. 
 <TT
CLASS="LITERAL"
>0.0.0.0/0</TT
>은 모든 IPv4 주소를 나타내며 <TT
CLASS="LITERAL"
>::/0</TT
>은 모든 IPv6 주소를 나타낸다. 
 단일 호스트를 지정하려면 IPv4의 경우 CIDR 마스크 32를 사용하고 IPv6의 경우 128을 사용해야 한다. 네트워크 주소 끝의 0을 빠트리면 안 된다.</P
><P
> IPv4 형식의 IP 주소는 해당 주소의 IPv6 연결과 일치한다. 
 예를 들면, <TT
CLASS="LITERAL"
>127.0.0.1</TT
>은 IPv6 주소 <TT
CLASS="LITERAL"
>::ffff:127.0.0.1</TT
>과 일치하게 된다. 
 IPv6 형식의 항목은 표시된 주소가 IPv4-in-IPv6 범위 내이더라도 IPv6 연결만 일치하게 된다. 
 IPv6 형식의 항목은 시스템의 C 라이브러리가 IPv6 주소를 지원하지 않는 경우 거부된다.</P
><P
> 사용자는 아무 IP 주소나 일치하도록 <TT
CLASS="LITERAL"
>all</TT
>을 쓸 수도 있고, 
 서버의 자체 IP 주소 아무거나 일치하도록 <TT
CLASS="LITERAL"
>samehost</TT
>를 쓸 수도 있고, 
 서버가 직접 연결되는 서브넷의 아무 주소나 일치하도록 <TT
CLASS="LITERAL"
>samenet</TT
>을 쓸 수도 있다.</P
><P
> 호스트 이름이 지정된 경우(IP 주소가 아니거나 특수 키워드가 호스트 이름으로 처리되는 모든 것) 
 해당 이름은 클라이언트 IP 주소의 역방향 이름 분석 결과와 비교된다(예: DNS가 사용되는 경우 역방향 DNS 조회). 
 호스트 이름 비교는 대소문자를 구분하지 않는다. 
 일치하는 호스트 이름이 있는 경우, 호스트 이름을 순방향 이름 분석(예: 순방향 DNS 조회)해서 클라이언트의 IP 주소와 동일한지 검사한다. 
 양방향으로 일치할 경우 항목이 일치하는 것으로 간주된다. 
 (<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>에서 사용되는 호스트 이름은 클라이언트 IP 주소의 주소-이름 분석(address-to-name resolution)이 리턴한 것이어야 
 하며, 리턴된 값이 아니면 일치할 수 없다.)
 일부 호스트 이름 데이터베이스는 IP 주소를 호스트 이름 여러 개와 연결하는 것을 허용하지만, 
 IP 주소를 분석하도록 요청된 경우 운영 체제는 호스트 이름을 하나만 리턴한다.</P
><P
> 점(<TT
CLASS="LITERAL"
>.</TT
>)으로 시작되는 호스트 이름 규격은 실제 호스트 이름의 접미사와 일치한다. 
 따라서, <TT
CLASS="LITERAL"
>.example.com</TT
>은 <TT
CLASS="LITERAL"
>foo.example.com</TT
>과 일치하게 된다
 (<TT
CLASS="LITERAL"
>example.com</TT
>만으로는 일치하지 않음).</P
><P
> 호스트 이름이 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>에 지정된 경우 이름 분석 속도가 빠른지 확인해야 한다. 
 <TT
CLASS="COMMAND"
>nscd</TT
> 같은 로컬 이름 분석 캐시를 설정하는 것이 유리할 수 있다. 
 또한 사용자는 환경 설정 매개 변수 <TT
CLASS="VARNAME"
>log_hostname</TT
>을 활성화하여 로그의 IP 주소 대신 클라이언트의 호스트 이름을 볼 수 있다.</P
><P
> 이 필드는 <TT
CLASS="LITERAL"
>host</TT
> 및 <TT
CLASS="LITERAL"
>hostssl</TT
>, <TT
CLASS="LITERAL"
>hostnossl</TT
> 레코드에 적용된다.</P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><P
></P
><A
NAME="AEN5673"
></A
><P
>클라이언트 IP 주소의 역방향 조회를 비롯한 두 이름 분석 방법이 이렇게 복잡한 방식으로 호스트 이름을 처리하는 이유를 궁금해 하는 사용자도 있다. 
클라이언트의 역방향 DNS 항목이 설정되지 않았거나 올바르지 않은 호스트 이름을 넘겨주는 경우에 사용법이 복잡해진다. 
이것은 기본적으로 효율을 위한 것이다. 
이와 같은 연결 시도는 기껏해야 두 가지 리졸버(resolver) 조회(역방향 하나 및 순방향 하나)를 시도한다. 
일부 주소에 리졸버(resolver) 문제가 있는 경우 이것은 해당 클라이언트만의 문제이다. 
순방향 조회만 수행하면 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>에 나오는 모든 호스트 이름을 연결 시도할 때마다 분석해야 한다. 
이름이 많을 경우 속도가 매우 느려진다. 
그리고, 호스트 이름 중 하나라도 리졸버(resolver) 문제가 있는 경우 이것은 전체의 문제가 된다.
 </P
><P
>또한, 패턴 일치를 위해서는 실제 클라이언트 호스트 이름을 알고 있어야 하므로 역방향 조회는 접미사 일치 기능을 구현해야 한다.
 </P
><P
>이러한 동작은 Apache HTTP 서버 및 TCP 래퍼 같은 다른 유명한 호스트 이름 기반의 액세스 제어 구현과 같다.
 </P
><P
></P
></DIV
></TD
></TR
></TABLE
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>IP-address</I
></TT
><BR><TT
CLASS="REPLACEABLE"
><I
>IP-mask</I
></TT
></DT
><DD
><P
> 이 필드는 <TT
CLASS="REPLACEABLE"
><I
>CIDR-address</I
></TT
> 표기의 대안으로 사용될 수 있다. 
 마스크 길이를 지정하는 대신 실제 마스크가 쉼표로 구분하여 지정된다. 
 예를 들면, <TT
CLASS="LITERAL"
>255.0.0.0</TT
>은 IPv4 CIDR 마스크 길이 8을 나타내고, <TT
CLASS="LITERAL"
>255.255.255.255</TT
>는 CIDR 마스크 길이 32를 나타낸다.</P
><P
> 이 필드는 <TT
CLASS="LITERAL"
>host</TT
> 및 <TT
CLASS="LITERAL"
>hostssl</TT
>, <TT
CLASS="LITERAL"
>hostnossl</TT
> 레코드에 적용된다.</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
></DT
><DD
><P
> 연결이 이 레코드와 일치할 때 사용하는 인증 방법을 지정한다. 
 가능한 선택안이 여기에 요약되어 있다. 자세한 내용은 <A
HREF="auth-methods.html"
>3.3절</A
>을 참조 바란다.

 <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>trust</TT
></DT
><DD
><P
>무조건 연결을 허용한다. 이 방법은 패스워드나 다른 인증 없이 임의의 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 데이터베이스 사용자로 
로그인하여 누구나 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
> 데이터베이스 서버에 연결할 수 있다. 
자세한 내용은 <A
HREF="auth-methods.html#AUTH-TRUST"
>3.3.1절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>reject</TT
></DT
><DD
><P
>무조건 연결을 거부한다. 이것은 그룹에서 특정 호스트를 <SPAN
CLASS="QUOTE"
>"필터링"</SPAN
>할 때 유용하다. 
예를 들면, <TT
CLASS="LITERAL"
>reject</TT
> 줄은 특정 호스트의 연결을 차단하고, 그 이후의 줄은 특정 네트워크의 남은 호스트들과의 연결을 허용한다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>md5</TT
></DT
><DD
><P
>클라이언트가 인증을 위해 double-MD5-hashed 패스워드를 제공해야 한다. 
자세한 내용은 <A
HREF="auth-methods.html#AUTH-PASSWORD"
>3.3.2절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>password</TT
></DT
><DD
><P
>클라이언트가 인증을 위해 암호화되지 않은 패스워드를 제공해야 한다. 
패스워드는 네트워크 상에서 일반 텍스트로 전송되므로 신뢰하지 않는 네트워크에서 이것을 사용하면 안 된다. 
자세한 내용은 <A
HREF="auth-methods.html#AUTH-PASSWORD"
>3.3.2절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>gss</TT
></DT
><DD
><P
>GSSAPI를 사용하여 사용자를 인증한다. 이것은 TCP/IP 연결에서만 사용할 수 있다. 자세한 내용은 <A
HREF="auth-methods.html#GSSAPI-AUTH"
>3.3.3절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>sspi</TT
></DT
><DD
><P
>SSPI를 사용하여 사용자를 인증한다. 이것은 Windows에서만 사용할 수 있다. 자세한 내용은 <A
HREF="auth-methods.html#SSPI-AUTH"
>3.3.4절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ident</TT
></DT
><DD
><P
>클라이언트의 ident 서버에 접촉함으로써 클라이언트의 운영 체제 사용자 이름을 획득하고, 요청된 데이터베이스 사용자 이름과 일치하는지 확인한다. 
Ident 인증은 TCP/IP 연결에서만 사용할 수 있다. 
로컬 연결에 대해 지정하는 경우 피어(peer) 인증이 대신 사용된다. 자세한 내용은 <A
HREF="auth-methods.html#AUTH-IDENT"
>3.3.5절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>peer</TT
></DT
><DD
><P
>클라이언트의 운영 체제 사용자 이름을 운영 체제에서 획득하고, 요청된 데이터베이스 사용자 이름과 일치하는지 확인한다. 
이것은 로컬 연결에서만 사용할 수 있다. 자세한 내용은 <A
HREF="auth-methods.html#AUTH-PEER"
>3.3.6절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldap</TT
></DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>LDAP</ACRONYM
> 서버를 사용하여 인증한다. 자세한 내용은 <A
HREF="auth-methods.html#AUTH-LDAP"
>3.3.7절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>radius</TT
></DT
><DD
><P
>RADIUS 서버를 사용하여 인증한다. 자세한 내용은 <A
HREF="auth-methods.html#AUTH-RADIUS"
>3.3.8절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>cert</TT
></DT
><DD
><P
>SSL 클라이언트 인증을 사용하여 인증한다. 자세한 내용은 <A
HREF="auth-methods.html#AUTH-CERT"
>3.3.9절</A
>을 참조 바란다.
 </P
></DD
><DT
><TT
CLASS="LITERAL"
>pam</TT
></DT
><DD
><P
>운영 체제에서 제공하는 PAM(Pluggable Authentication Modules)을 사용하여 인증한다. 
자세한 내용은 <A
HREF="auth-methods.html#AUTH-PAM"
>3.3.10절</A
>을 참조 바란다.
 </P
></DD
></DL
></DIV
><P>&#13;</P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>auth-options</I
></TT
></DT
><DD
><P
> <TT
CLASS="REPLACEABLE"
><I
>auth-method</I
></TT
> 필드 이후에 인증 방법에 대한 옵션을 지정하는 
 <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
><TT
CLASS="LITERAL"
>=</TT
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> 형식의 필드가 있을 수 있다. 
 인증 방법에서 사용할 수 있는 옵션에 대한 자세한 내용은 아래에 나와 있다.</P
></DD
></DL
></DIV
><P></P
><P
> <TT
CLASS="LITERAL"
>@</TT
> 구문이 포함된 파일은, 공백 또는 쉼표로 구분된 이름 목록으로 읽는다. 
 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>처럼 <TT
CLASS="LITERAL"
>#</TT
>로 표시된 주석 및 중첩된 <TT
CLASS="LITERAL"
>@</TT
> 구문이 허용된다.
 파일 이름 뒤에 <TT
CLASS="LITERAL"
>@</TT
>가 나오는 것이 절대 경로가 아니면 참조 파일이 있는 디렉토리의 상대 경로로 취급된다.</P
><P
> <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 레코드는 각 연결 시도에 대해 순차적으로 검사되므로 레코드의 순서는 중요하다. 
 일반적으로 초기 레코드는 연결 일치 매개 변수는 치밀하고, 인증 방법은 느슨한 반면, 후기 레코드는 일치 매개 변수는 느슨하고 인증 방법은 강력하다. 
 예를 들면, 로컬 TCP/IP 연결에 대한 <TT
CLASS="LITERAL"
>trust</TT
> 인증을 사용하려고 하면서 원격 TCP/IP 연결을 할 수도 있다. 
 이런 경우 127.0.0.1로부터 연결을 위한 <TT
CLASS="LITERAL"
>trust</TT
> 인증을 지정한 레코드는 다양한 허용 클라이언트 IP 주소에 대해 
 패스워드 인증을 지원하는 레코드 이전에 나타난다.</P
><P
> <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 파일은 시작 시 및 메인 서버 프로세스가 
 <SPAN
CLASS="SYSTEMITEM"
>SIGHUP</SPAN
> 신호를 수신하면 읽혀지게 된다. 
 활성화 된 시스템에서 파일을 편집하는 경우 파일을 다시 읽어오려면 postmaster에 신호를 전송해야 한다
 (<TT
CLASS="LITERAL"
>pg_ctl reload</TT
> 또는 <TT
CLASS="LITERAL"
>kill -HUP</TT
> 사용).</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
>특수한 데이터베이스에 연결하려면 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 검사만 통과해서는 안 되며 데이터베이스에 대한 
<TT
CLASS="LITERAL"
>CONNECT</TT
> 권한이 사용자에게 있어야 한다. 
데이터베이스에 연결 가능한 사용자를 제한하고 싶으면 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 항목에 규칙을 입력하는 것보다 
<TT
CLASS="LITERAL"
>CONNECT</TT
> 권한을 부여/취소하는 것이 일반적으로 쉽다.
 </P
></BLOCKQUOTE
></DIV
><P
> <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 항목에 대한 몇 가지 예시가 <A
HREF="auth-pg-hba-conf.html#EXAMPLE-PG-HBA.CONF"
>예 3-1</A
>에 나와 있다. 
 서로 다른 인증 방법에 대한 자세한 내용은 다음 절을 참조 바란다.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="EXAMPLE-PG-HBA.CONF"
></A
><P
><B
>예 3-1. <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 항목 예시</B
></P
><PRE
CLASS="PROGRAMLISTING"
># Allow any user on the local system to connect to any database with
# any database user name using Unix-domain sockets (the default for local
# connections).
#
# TYPEDATABASEUSERADDRESS METHOD
local all all trust

# The same using local loopback TCP/IP connections.
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all 127.0.0.1/32trust

# The same as the previous line, but using a separate netmask column
#
# TYPEDATABASEUSERIP-ADDRESSIP-MASK METHOD
hostall all 127.0.0.1 255.255.255.255 trust

# The same over IPv6.
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all ::1/128 trust

# The same using a host name (would typically cover both IPv4 and IPv6).
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all localhost trust

# Allow any user from any host with IP address 192.168.93.x to connect
# to database "postgres" as the same user name that ident reports for
# the connection (typically the operating system user name).
#
# TYPEDATABASEUSERADDRESS METHOD
hostpostgresall 192.168.93.0/24 ident

# Allow any user from host 192.168.12.10 to connect to database
# "postgres" if the user's password is correctly supplied.
#
# TYPEDATABASEUSERADDRESS METHOD
hostpostgresall 192.168.12.10/32md5

# Allow any user from hosts in the example.com domain to connect to
# any database if the user's password is correctly supplied.
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all .example.commd5

# In the absence of preceding "host" lines, these two lines will
# reject all connections from 192.168.54.1 (since that entry will be
# matched first), but allow GSSAPI connections from anywhere else
# on the Internet.The zero mask causes no bits of the host IP
# address to be considered, so it matches any host.
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all 192.168.54.1/32 reject
hostall all 0.0.0.0/0 gss

# Allow users from 192.168.x.x hosts to connect to any database, if
# they pass the ident check.If, for example, ident says the user is
# "bryanh" and he requests to connect as Agens SQL user "guest1", the
# connection is allowed if there is an entry in pg_ident.conf for map
# "omicron" that says "bryanh" is allowed to connect as "guest1".
#
# TYPEDATABASEUSERADDRESS METHOD
hostall all 192.168.0.0/16ident map=omicron

# If these are the only three lines for local connections, they will
# allow local users to connect only to their own databases (databases
# with the same name as their database user name) except for administrators
# and members of role "support", who can connect to all databases.The file
# $PGDATA/admins contains a list of names of administrators.Passwords
# are required in all cases.
#
# TYPEDATABASEUSERADDRESS METHOD
local sameuserall md5
local all @admins md5
local all +supportmd5

# The last two lines above can be combined into a single line:
local all @admins,+supportmd5

# The database column can also use lists and file names:
local db1,db2,@demodbsall md5</PRE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="auth-username-maps.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>클라이언트 인증</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>사용자 이름 맵</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>