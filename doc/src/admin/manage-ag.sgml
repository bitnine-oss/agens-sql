<!-- doc/src/sgml/manage-ag.sgml -->

<chapter id="managing-databases">
 <title>데이터베이스 관리</title>

 <indexterm zone="managing-databases"><primary>데이터베이스</></>

 <para>
  실행 중인 <productname>Agens SQL</productname> 서버의 모든 인스턴스는 하나 이상의 데이터베이스를 관리한다. 
  그러므로 데이터베이스는 <acronym>SQL</acronym> 객체(<quote>데이터베이스 객체</quote>)를 구성하기 위한 최상위 계층이다. 
  이 장에서는 데이터베이스의 특성과 데이터베이스를 생성 및 관리, 소멸하는 방법에 대해 다룬다.
 </para>

 <sect1 id="manage-ag-overview">
  <title>개요</title>

  <indexterm zone="manage-ag-overview">
   <primary>스키마</primary>
  </indexterm>

  <para>
   데이터베이스는 명명된 <acronym>SQL</acronym> 객체 컬렉션이다(<quote>데이터베이스 객체</quote>). 
   일반적으로 모든 데이터베이스 객체(테이블, 함수 등)은 데이터베이스 한 곳에만 속한다. 
   (예를 들면, <literal>pg_database</>처럼 전체 클러스터에 속하고 클러스터 내의 각 데이터베이스에서 접근 가능한 시스템 카탈로그는 몇 개 있다.) 
   좀 더 정확하게 말하면 데이터베이스는 스키마의 컬렉션이며, 스키마에는 테이블, 함수 등이 포함된다. 
   따라서 전체 구조는 서버, 데이터베이스, 스키마, 테이블(또는 함수 같이 종류가 다른 일부 객체)로 구성된다.
  </para>

  <para>
   데이터베이스 서버에 연결하는 경우 클라이언트는 연결하려는 데이터베이스 이름을 연결을 요청할 때 지정해야 한다. 
   연결당 데이터베이스를 하나 이상 접근할 수도 있다. 
   단, 애플리케이션은 동일한 데이터베이스 또는 다른 데이터베이스에 대해 열리는 연결 수에 제한되지 않는다. 
   데이터베이스는 물리적으로 구분되며 접근 제어는 연결 수준에서 관리된다. 
   한 <productname>Agens SQL</> 서버 인스턴스가 서로 인식하지 못하는 프로젝트 또는 사용자를 수용하는 경우, 
   두 가지를 별도의 데이터베이스에 두는 것이 좋다. 
   프로젝트 또는 사용자가 서로 연관되어 있고 서로의 자원을 사용해야 하는 경우에는 두 가지를 동일한 데이터베이스에 두고 스키마는 분리해야 한다. 
   스키마는 순전히 논리적 구조이며 권한 시스템이 관리하는 대상에 접근할 수 있는 사용자이다. 
  </para>

  <para>
   데이터베이스는 <command>CREATE DATABASE</> 명령(<xref linkend="manage-ag-createdb"> 참조)으로 생성되고 
   DROP DATABASE 명령(<xref linkend="manage-ag-dropdb"> 참조)으로 소멸된다. 
   기존 데이터베이스를 판단하려면 <structname>pg_database</> 시스템 카탈로그를 검사해야 한다. 예를 들면,
<synopsis>
SELECT datname FROM pg_database;
</synopsis>
   psql 프로그램의 <literal>\l</> 메타 명령 및 <option>-l</> 커맨드라인 옵션도 기존 데이터베이스를 나열하는 데 유용하다.
  </para>

  <note>
   <para>
    <acronym>SQL</> 표준은 데이터베이스 <quote>카탈로그</>를 호출하지만 실제로는 차이가 없다.
   </para>
  </note>
 </sect1>

 <sect1 id="manage-ag-createdb">
  <title>데이터베이스 생성</title>

  <indexterm><primary>CREATE DATABASE</></>

  <para>
   데이터베이스를 생성하려면 <productname>Agens SQL</> 서버를 시작한 다음에 실행해야 한다(<xref
   linkend="server-start"> 참조).
  </para>

  <para>
   데이터베이스는 SQL 명령 CREATE DATABASE으로 생성된다.
<synopsis>
CREATE DATABASE <replaceable>name</>;
</synopsis>
   여기서, <replaceable>name</>은 <acronym>SQL</acronym> 식별자에 대한 일반 규칙을 따른다. 
   현재 role은 자동으로 새 데이터베이스의 소유자가 된다. 
   나중에 데이터베이스를 삭제하는 것은 데이터베이스 소유자의 권한이다(소유자가 달라도 데이터베이스의 모든 객체가 삭제됨).
  </para>

  <para>
   데이터베이스 생성은 제한적이다. 권한 부여 방법은 <xref
   linkend="role-attributes">을 참조 바란다.
  </para>

  <para>
   CREATE DATABASE<command>CREATE DATABASE</command> 명령을 실행하려면 데이터베이스 서버에 연결해야 하는데, 
   주어진 사이트에서 <emphasis>첫</> 번째 데이터베이스를 어떻게 만들 것인가가 문제가 된다. 
   첫 번째 데이터베이스는 데이터 저장소 영역을 초기화할 때 <command>initdb</> 명령으로 항상 생성된다. 
   (<xref linkend="creating-cluster"> 참조.) 이 데이터베이스를 <literal>postgres</><indexterm><primary>postgres</></>라고 한다. 
   따라서 첫 번째 <quote>일반</> 데이터베이스를 생성하기 위해 <literal>postgres</>에 연결할 수 있다.
  </para>

  <para>
   두 번째 데이터베이스 <literal>template1</literal><indexterm><primary>template1</></>도 데이터베이스 클러스터 초기화 중에 생성된다. 
   클러스터 내에서 새 데이터베이스를 생성할 때마다 <literal>template1</literal>이 복제된다. 
   이것은 <literal>template1</>에서 변경된 내용이 추후 생성된 데이터베이스로 전파된다는 것을 의미한다. 
   따라서 새로 생성된 모든 데이터베이스로 전파되는 것을 원하지 않으면 <literal>template1</>에서 객체 생성을 하지 말아야 한다. 
   자세한 내용은 <xref linkend="manage-ag-templatedbs">에 나와 있다.
  </para>

  <para>
   <command>createdb</><indexterm><primary>createdb</></>는 편의상 새 데이터베이스를 생성하기 위해 쉘에서 실행할 수 있는 프로그램이다.

<synopsis>
createdb <replaceable class="parameter">dbname</replaceable>
</synopsis>

   <command>createdb</>는 마법이 아니다. 
   이것은 <literal>postgres</> 데이터베이스에 연결하고 위에서 설명한 대로 정확하게 <command>CREATE DATABASE</> 명령을 실행한다. 
   인자가 없는 <command>createdb</>는 현재 사용자 이름으로 데이터베이스를 생성한다.
  </para>

  <note>
   <para>
    주어진 데이터베이스에 연결할 수 있는 사용자를 제한하는 방법에 대한 내용은 <xref linkend="client-authentication">에 나온다.
   </para>
  </note>

  <para>
   다른 사용자를 위한 데이터베이스를 생성하고, 그 사용자를 새 데이터베이스의 소유자로 만들면, 
   해당 사용자가 스스로 새 데이터베이스를 환경 설정 및 관리할 수 있다. 
   이렇게 하려면 SQL 환경에서 다음 명령 중 하나를 사용해야 한다.
<programlisting>
CREATE DATABASE <replaceable>dbname</> OWNER <replaceable>rolename</>;
</programlisting>
   또는 쉘에서 다음을 사용해야 한다.
<programlisting>
createdb -O <replaceable>rolename</> <replaceable>dbname</>
</programlisting>
   다른 사용자를 위한 데이터베이스는 수퍼유저만 생성할 수 있다(즉, 멤버가 아닌 role의 경우).
  </para>
 </sect1>

 <sect1 id="manage-ag-templatedbs">
  <title>템플릿 데이터베이스</title>

  <para>
   <command>CREATE DATABASE</>는 실제로 기존 데이터베이스를 복사한다. 
   기본적으로 <literal>template1</><indexterm><primary>template1</></>이라는 표준 시스템 데이터베이스를 복사한다. 
   따라서 해당 데이터베이스는 새 데이터베이스를 만드는 <quote>템플릿</>이다. 
   객체를 <literal>template1</>에 추가하면, 이 객체는 나중에 생성된 사용자 데이터베이스로 복사된다. 
   이 작업은 데이터베이스의 표준 객체 집합에 대한 사이트-로컬 수정을 가능하게 한다. 
   예를 들면, <literal>template1</>에서 프로시저 언어 <application>PL/Perl</>을 설치하는 경우 
   해당 데이터베이스를 생성할 때 추가적인 작업 없이 사용자 데이터베이스가 자동으로 사용 가능하게 된다.
  </para>

  <para>
   <literal>template0</><indexterm><primary>template0</></>이라는 2차 표준 시스템 데이터베이스가 있다. 
   이 데이터베이스에는 <literal>template1</>의 초기 내용과 동일한 데이터가 포함되어 있다. 
   즉, <productname>PostgreSQL</productname> 버전에 의해 사전 정의된 표준 객체만 포함되어 있다. 
   데이터베이스 클러스터를 초기화한 후에는 <literal>template0</>을 절대 변경하면 안 된다. 
   <literal>template1</> 대신 <literal>template0</>을 복사하도록 <command>CREATE DATABASE</>를 실행하면 
   <literal>template1</>에서 사이트-로컬 추가가 없는 <quote>처녀</quote> 사용자 데이터베이스를 생성할 수 있다. 
   이것은 <literal>pg_dump</> 덤프를 복원할 때 특히 유용하다. 
   나중에 <literal>template1</>에 추가되었을 수도 있는 객체와 충돌 없이 덤프된 데이터베이스를 올바르게 재생성 하도록 
   처녀 데이터베이스에서 덤프 스크립트를 복원해야 한다.
  </para>

  <para>
   <literal>template1</> 대신 <literal>template0</>을 복사하는 일반적인 다른 이유는 <literal>template1</>의 복사는 
   동일한 설정을 사용해야 하지만 <literal>template0</>을 복사하는 경우에는 새 인코딩 및 로케일(locale) 설정을 지정할 수 있기 때문이다. 
   <literal>template1</>은 인코딩 또는 로케일(locale)에 관한 데이터를 포함하지만 <literal>template0</>은 그렇지 않다.
  </para>

  <para>
   <literal>template0</literal>을 복사하여 데이터베이스를 생성하려면 
<programlisting>
CREATE DATABASE <replaceable>dbname</> TEMPLATE template0;
</programlisting>
   SQL 환경에서 다음을 사용해야 한다.
<programlisting>
createdb -T template0 <replaceable>dbname</>
</programlisting>
   또는 쉘에서 다음을 사용해야 한다.
  </para>

  <para>
   템플릿 데이터베이스를 추가적으로 생성하는 것이 가능하며, 
   <command>CREATE DATABASE</>의 경우 템플릿 이름을 지정하면 클러스터의 데이터베이스를 복사할 수도 있다. 
   그러나, 아직까지는 <quote><command>COPY DATABASE</command></quote>가 범용으로 사용되는 기능이 아니라는 점을 이해해야 한다. 
   이러한 제한은 복사 중인 소스 데이터베이스에 다른 세션을 연결할 수 없다는 것을 의미한다. 
   시작 시 다른 연결이 존재하면 <command>CREATE DATABASE</>가 실패하며, 복사 명령 중에 소스 데이터베이스에 대한 새롭게 연결되는 것을 방지한다.
  </para>

  <para>
   데이터베이스별로 <literal>pg_database</literal><indexterm><primary>pg_database</></>에는 <literal>datistemplate</literal> 칼럼 
   및 <literal>datallowconn</literal> 칼럼의 두 가지 유용한 플래그가 존재한다. 
   <literal>datistemplate</literal>를 설정하여 데이터베이스가 <command>CREATE DATABASE</>의 템플릿임을 나타낼 수 있다. 
   이 플래그가 설정되면 <literal>CREATEDB</> 권한이 있는 사용자가 데이터베이스를 복제할 수 있다. 
   설정되지 않으면 수퍼유저와 데이터베이스 소유자만 복제할 수 있다. 
   <literal>datallowconn</literal>이 false인 경우 해당 데이터베이스에 대한 새로운 연결이 허용되지 않는다
   (단, 플래그를 false로 설정해도 기존 세션은 중단되지 않는다). 
   <literal>template0</literal> 데이터베이스는 수정 방지를 위해 일반적으로 <literal>datallowconn = false</>로 표시된다. 
   양쪽 <literal>template0</literal> 및 <literal>template1</literal>은 <literal>datistemplate = true</>로 항상 표시되어야 한다.
  </para>

  <note>
   <para>
    <literal>template1</> 및 <literal>template0</>은 이름 <literal>template1</>이 <command>CREATE DATABASE</>의 
    기본 소스 데이터베이스 이름이라는 사실 외에는 특별한 상태를 나타내지 않는다. 
    예를 들면, <literal>template1</>를 삭제하고 부작용 없이 <literal>template0</>으로 재생성 가능하다. 
    이러한 작업 과정은 <literal>template1</>에 잘못 추가한 것이 많을 경우에 좋다.
    (<literal>template1</literal>을 삭제하려면 <literal>pg_database.datistemplate = false</>여야 한다.)
   </para>

   <para>
    데이터베이스 클러스터가 초기화될 때 <literal>postgres</> 데이터베이스도 생성된다. 
    이 데이터베이스는 연결하는 사용자 및 애플리케이션의 기본 데이터베이스임을 의미한다. 
    이것은 단순히 <literal>template1</>의 사본이며, 필요시 삭제 및 재생성이 가능하다.
   </para>
  </note>
 </sect1>

 <sect1 id="manage-ag-config">
  <title>데이터베이스 환경 설정</title>

  <para>
   <xref linkend="runtime-config">에서 설명한 대로 <productname>Agens SQL</> 서버는 여러 가지 런타임 설정 변수를 제공한다. 
   이러한 여러 가지 설정에 대해 데이터베이스별 기본값을 설정할 수 있다.
  </para>

  <para>
   예를 들면, 주어진 데이터베이스에 대해 <acronym>GEQO</acronym> 옵티마이저를 비활성화하려는 경우 
   대개는 모든 데이터베이스에 대해 비활성화해야 하거나 모든 연결 클라이언트가 신중하게 <literal>SET geqo TO off</literal>를 
   실행하는지 확인해야 한다. 
   특정 데이터베이스 내에서 이 설정을 기본값으로 설정하려면 다음 명령을 실행해야 한다.
<programlisting>
ALTER DATABASE mydb SET geqo TO off;
</programlisting>
   이것은 설정을 저장한다(그러나 즉시 설정되지는 않음). 
   <literal>SET geqo TO off;</literal>;가 세션 시작 직전에 실행되었더라도 이 데이터베이스를 추후 연결했을 때 이것이 적용된다. 
   세션 중에 사용자가 이 설정을 변경할 수 있으며, 이는 기본값에 불과하다. 
   설정을 실행 취소하려면 <literal>ALTER DATABASE <replaceable>dbname</> RESET<replaceable>varname</></literal>을 사용해야 한다.
  </para>
 </sect1>

 <sect1 id="manage-ag-dropdb">
  <title>데이터베이스 소멸</title>

  <para>
   데이터베이스는 DROP DATABASE<indexterm><primary>DROP DATABASE</></> 명령으로 소멸된다.
<synopsis>
DROP DATABASE <replaceable>name</>;
</synopsis>
   데이터베이스 소유자 또는 수퍼유저만 데이터베이스를 삭제할 수 있다. 
   데이터베이스를 삭제하면 데이터베이스에 포함된 모든 객체가 삭제된다. 
   데이터베이스 소멸은 실행 취소가 불가능하다.
  </para>

  <para>
   삭제 대상 데이터베이스에 연결된 상태에서는 <command>DROP DATABASE</command> 명령을 실행할 수 없다. 
   그러나 <literal>template1</> 데이터베이스를 비롯한 다른 데이터베이스에 연결하는 것은 가능하다. 
   주어진 클러스트의 마지막 사용자 데이터베이스를 삭제할 때 <literal>template1</>은 유일한 옵션이 된다.
  </para>

  <para>
   편의상 데이터베이스를 삭제할 수 있는 쉘 프로그램 dropdb<indexterm><primary>dropdb</></>도 있다.
<synopsis>
dropdb <replaceable class="parameter">dbname</replaceable>
</synopsis>
   (<command>createdb</>와 달리, 이것은 현재 사용자 이름으로 데이터베이스를 삭제하는 기본 동작은 아니다.)
  </para>
 </sect1>

 <sect1 id="manage-ag-tablespaces">
  <title>테이블스페이스</title>

  <indexterm zone="manage-ag-tablespaces">
   <primary>테이블스페이스</primary>
  </indexterm>

  <para>
   <productname>Agens SQL</>의 테이블스페이스는 데이터베이스 관리자가 데이터베이스 객체를 나타내는 파일을 저장할 수 있는 
   파일 시스템의 위치를 정의할 수 있게 한다. 
   생성된 경우 테이블스페이스는 데이터베이스 객체 생성 시 이름으로 참조가 가능하다.
  </para>

  <para>
   테이블스페이스를 사용함으로써 관리자는 <productname>Agens SQL</> 설치의 디스크 레이아웃을 제어할 수 있다. 
   이것은 최소 2가지 방법으로 활용할 수 있다. 
   첫째, 클러스터가 초기화된 파티션 또는 볼륨 공간이 소진되고 확장이 불가능한 경우, 
   다른 파티션에 테이블스페이스를 생성하고 시스템이 재인식될 때까지 사용할 수 있다.
  </para>

  <para>
   두 번째, 테이블스페이스는 관리자가 성능 최적화를 위해 데이터베이스 객체의 사용 패턴에 대한 지식을 사용할 수 있게 한다. 
   예를 들면, 사용이 빈번한 인덱스는 고가의 SSD 같은 고속, 고가용성 디스크에 배치할 수 있다. 
   또한, 거의 사용되지 않거나 성능이 중요하지 않은 아카이브 데이터가 저장된 테이블은 저속, 저가의 디스크 시스템에 저장할 수 있다.
  </para>

  <warning>
   <para>
     Agens SQL 주 데이터 디렉토리 외부에 배치했더라도 테이블스페이스는 데이터베이스 클러스터 내부에 속해 있기 때문에 
     데이터 파일 자동 수집으로 처리되어서는 <emphasis>안</emphasis> 된다. 
     테이블스페이스는 주 데이터 디렉토리에 포함된 메타데이터에 종속적이므로 서로 다른 데이터베이스 클러스터에 연결되거나 개별적으로 백업할 수 없다. 
     마찬가지로, 테이블스페이스를 잃어버린 경우(파일 삭제, 디스크 오류 등), 데이터베이스 클러스터를 읽지 못하게 되거나 시작하지 못하게 될 수 있다. 
     램디스크 같은 임시 파일 시스템에 테이블 스페이스를 배치하면 전체 클러스터의 신뢰도가 위험할 수 있다.
   </para>
  </warning>

  <para>
   테이블스페이스를 정의하려면 CREATE TABLESPACE<indexterm><primary>CREATE TABLESPACE</></> 명령을 사용해야 한다. 예를 들면,
<programlisting>
CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';
</programlisting>
   위치는 빈 디렉토리로 존재해야 하며, <productname>Agens SQL</> 운영 체제 사용자가 소유한 것이어야 한다. 
   이후에 테이블스페이스 내부에서 생성된 모든 객체는 이 디렉토리 아래의 파일에 저장된다. 
   테이블스페이스가 누락 또는 분실된 경우 클러스터 작동이 실패할 수 있으므로 위치가 이동식 또는 임시 저장소이면 안 된다.
  </para>

  <note>
   <para>
    논리적 파일 시스템 내에서 개별 파일의 위치를 사용자가 제어할 수 없기 때문에 논리적 파일 시스템당 테이블스페이스를 
    2개 이상 만들 수 있는 지점이 일반적으로 많지 않다. 
    그러나 <productname>Agens SQL</>은 강제로 제한하지 않으므로, 실제로는 시스템에서 파일 시스템 경계를 직접적으로 인식하지 못한다. 
    단지 사용자가 사용할 것으로 지정한 디렉토리에 파일을 저장하기만 한다.
   </para>
  </note>

  <para>
   테이블스페이스 자체는 데이터베이스 수퍼유저로 생성해야 하지만, 
   생성한 후에는 일반 데이터베이스 사용자가 이 데이터베이스를 사용하도록 할 수 있다. 
   이렇게 하려면 <literal>CREATE</> 권한을 부여해야 한다.
  </para>

  <para>
   테이블 및 인덱스, 전체 데이터베이스는 특정 테이블스페이스에 할당될 수 있다. 
   이를 위해, 주어진 테이블스페이스에 대한 <literal>CREATE</> 권한이 있는 사용자는 테이블스페이스 이름을 해당 명령에 대한 매개 변수로 전달해야 한다. 
   예를 들면, 다음은 테이블스페이스 <literal>space1</>에서 테이블을 생성한다.
<programlisting>
CREATE TABLE foo(i int) TABLESPACE space1;
</programlisting>
  </para>

  <para>
   또는 default_tablespace 매개 변수를 사용한다.
<programlisting>
SET default_tablespace = space1;
CREATE TABLE foo(i int);
</programlisting>
   <varname>default_tablespace</>가 비어 있는 string 이외의 것으로 설정되면 이것은 명시적이지 않은 
   <command>CREATE TABLE</> 및 <command>CREATE INDEX</> 명령에 대한 암시적 <literal>TABLESPACE</> 절을 제공한다.
  </para>

  <para>
   임시 테이블과 인덱스, 거대(large) 데이터 세트 정렬 같은 목적으로 사용되는 임시 파일의 배치를 결정하는 temp_tablespaces 매개 변수도 있다. 
   이것은 하나 이상의 테이블스페이스명 목록일 수 있으므로 임시 객체와 관련된 부하가 다수의 테이블스페이스로 퍼질 수 있다. 
   목록의 임의의 멤버는 임시 객체가 생성될 때마다 선택된다.
  </para>

  <para>
   데이터베이스와 관련된 테이블스페이스는 해당 데이터베이스의 시스템 카탈로그를 저장하는 데 사용된다. 
   또한 <literal>TABLESPACE</> 절이 없거나 <varname>default_tablespace</> 또는 <varname>temp_tablespaces</>에 의해 지정된 다른 선택이 없는 경우, 
   이것은 데이터베이스 내에서 생성된 테이블 및 인덱스, 임시 파일에 사용되는 기본 테이블스페이스이다. 
   테이블스페이스를 지정하지 않고 데이터베이스를 생성하면, 복사했던 템플릿 데이터베이스와 동일한 테이블스페이스를 사용한다.
  </para>

  <para>
   데이터베이스 클러스터가 초기화되면 테이블스페이스 2개가 자동으로 생성된다. 
   <literal>pg_global</> 테이블스페이스는 공유 시스템 카탈로그에 사용된다. 
   <literal>pg_default</> 테이블스페이스는 <literal>template1</> 및 <literal>template0</> 데이터베이스의 기본 테이블스페이스이다
   (따라서, <command>CREATE DATABASE</>의 <literal>TABLESPACE</> 절로 덮어쓰지 않으면 다른 데이터베이스의 기본 테이블스페이스가 된다).
  </para>

  <para>
   테이블스페이스가 생성되면 요청한 사용자에게 권한이 충분한 경우에는 모든 데이터베이스에서 사용할 수 있다. 
   이것은 테이블스페이스를 사용하는 모든 데이터베이스에서 모든 객체를 삭제하지 않으면 테이블스페이스를 삭제할 수 없다는 것을 의미한다.
  </para>

  <para>
   비어 있는 테이블스페이스를 삭제하려면 DROP TABLESPACE 명령을 사용해야 한다.
  </para>

  <para>
   기존 테이블스페이스를 확인하려면 <structname>pg_tablespace</structname> 시스템 카탈로그를 검사해야 한다. 예를 들면,
<synopsis>
SELECT spcname FROM pg_tablespace;
</synopsis>
   psql 프로그램의 <literal>\db</> 메타 명령도 기존 테이블스페이스를 나열할 때 유용하다.
  </para>

  <para>
   <productname>Agens SQL</>은 심볼릭 링크를 사용하여 테이블스페이스의 구현을 간략화한다. 
   이것은 심볼릭 링크가 지원되는 시스템에서<emphasis>만</> 테이블스페이스를 사용할 수 있다는 것을 의미한다.
  </para>

  <para>
   디렉토리 <filename>$PGDATA/pg_tblspc</>에는 클러스터에 저장된 비 내장 테이블스페이스 각각을 가리키는 심볼릭 링크가 포함되어 있다. 
   권장 사항은 아니지만, 이 링크를 재정의하여 테이블스페이스의 레이아웃을 조정할 수도 있다. 
   이 작업은 어떤 경우에서든 서버 실행 중에 해야 한다. <productname>PostgreSQL</productname> 9.1 이전 버전에서는 
   <structname>pg_tablespace</> 카탈로그를 새 위치로 업그레이드해야 한다. 
   (그렇게 하지 않으면 <literal>pg_dump</>가 계속해서 이전 테이블스페이스 위치를 출력한다.)
  </para>

 </sect1>
</chapter>
