<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Agens SQL 1.0 문서</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-29T00:18:30"></HEAD
><BODY
CLASS="BOOK"
><DIV
CLASS="BOOK"
><A
NAME="POSTGRES"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="POSTGRES"
>Agens SQL 1.0 문서</A
></H1
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>차례</B
></DT
><DT
>I. <A
HREF="#PACKAGE"
>Packages</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#PLPROXY"
>PL/Proxy</A
></DT
><DT
>2. <A
HREF="#PGBOUNCER"
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
></A
></DT
><DT
>3. <A
HREF="#SKYTOOLS"
>Skytools</A
></DT
><DT
>4. <A
HREF="#PGPOOLII"
>pgpool-II</A
></DT
><DT
>5. <A
HREF="#SLONYI"
>Slony-I</A
></DT
><DT
>6. <A
HREF="#POSTGIS"
>PostGIS</A
></DT
><DT
>7. <A
HREF="#PGHINTPLAN"
>pg_hint_plan</A
></DT
><DT
>8. <A
HREF="#POWA"
><SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
></A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="PART"
><A
NAME="PACKAGE"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
>I. Packages</H1
><DIV
CLASS="PARTINTRO"
><A
NAME="AEN8"
></A
><P
> Package를 소개하는 부분입니다. </P
></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>차례</B
></DT
><DT
>1. <A
HREF="#PLPROXY"
>PL/Proxy</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#PLPROXY-CONFIGURATION"
>설정</A
></DT
><DT
>1.2. <A
HREF="#PLPROXY-QUICKSTART"
>Quick Start</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#PGBOUNCER"
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
></A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#PGBOUNCER-CONFIGURATION"
>설정</A
></DT
><DT
>2.2. <A
HREF="#PGBOUNCER-QUICKSTART"
>Quick Start</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#SKYTOOLS"
>Skytools</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#SKYTOOLS-INFO"
><SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>란?</A
></DT
><DT
>3.2. <A
HREF="#SKYTOOLS-START"
>Quick Start</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#PGPOOLII"
>pgpool-II</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#PGPOOL-II-CONFIG"
>설정</A
></DT
><DT
>4.2. <A
HREF="#PGPOOL-II-QUICK"
>시작하기</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#SLONYI"
>Slony-I</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#SLONYI-DEF"
><SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 개념 정의</A
></DT
><DT
>5.2. <A
HREF="#SLONYI-EXAMPLE1"
><SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 구동 예제 (1)</A
></DT
><DT
>5.3. <A
HREF="#SLONYI-EXAMPLE2"
><SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 구동 예제 (2)</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#POSTGIS"
>PostGIS</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#POSTGIS-CONFIG"
>설정</A
></DT
><DT
>6.2. <A
HREF="#POSTGIS-QUICK"
>시작하기</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#PGHINTPLAN"
>pg_hint_plan</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#PG-HINT-PLAN-SETTING"
>설정</A
></DT
><DT
>7.2. <A
HREF="#PG-HINT-PLAN-QUICKSTART"
>Quick Start</A
></DT
><DT
>7.3. <A
HREF="#PG-HINT-PLAN-HINT-LIST"
>힌트 목록</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#POWA"
><SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
></A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#POWA-CONFIGURATION"
>설정</A
></DT
><DT
>8.2. <A
HREF="#POWA-QUICKSTART"
>Quick Start</A
></DT
></DL
></DD
></DL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PLPROXY"
></A
>장 1. PL/Proxy</H1
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>는 proxy function을 만들어 원격 DB에 대한 접근 및 이를 활용한 기타 다양한 작업들을 가능케 하여 주는 모듈이다. 본 장에서는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>를 사용함에 있어 필요한 초기 설정과 간단한 사용 예제를 살펴보도록 한다.
     <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>에 대한 자세한 정보 및 다양한 사용 방법은 <A
HREF="http://plproxy.projects.pgfoundry.org/doc"
TARGET="_top"
> http://plproxy.projects.pgfoundry.org/doc</A
>를 참고하기 바란다.
 </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PLPROXY-CONFIGURATION"
>1.1. 설정</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>를 사용하기 위해서는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>설치 디렉토리에서 <TT
CLASS="FILENAME"
>/pgsql/share/extension/</TT
> 혹은 <TT
CLASS="FILENAME"
>/pgsql/share/contrib/</TT
> 내의 plproxy.sql 파일을 구동시켜야 한다. 해당 파일은 <TT
CLASS="FILENAME"
>plproxy--버전명.sql</TT
>형식의 이름을 갖고 있다. 본 예에서는 파일명을 <TT
CLASS="FILENAME"
>plproxy.sql</TT
>이라 가정하고 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
> 사용하기 위한 환경 설정에 대해서 알아본다.
     </P
><P
></P
><OL
TYPE="1"
><LI
><P
>     <SPAN
CLASS="PRODUCTNAME"
>psql</SPAN
>을 통해 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>를 이용할 DB를 대상으로 <TT
CLASS="FILENAME"
>plproxy.sql</TT
> 파일을 superuser 권한으로 다음과 같이 수행한다.(예: agens라는 superuser로 proxy_database에서 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>를 사용 가능하도록 명령)
     </P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>[agens@localhost extension]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -U agens proxy_database -f plproxy.sql</KBD
>
CREATE FUNCTION
CREATE LANGUAGE
CREATE FUNCTION
CREATE FOREIGN DATA WRAPPER
<SAMP
CLASS="PROMPT"
>[agens@localhost extension]$</SAMP
></SAMP
></PRE
></LI
><LI
><P
>일반 유저가 특정언어를 이용한 함수를 작성하기 위해서는 해당 언어 사용에 대한 권한을 부여받아야 한다. 하지만 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 신뢰성을 부여받지 못한 언어에 대해서는 superuser만 사용할 수 있도록 권한을 부여하기 때문에 일반 유저가 특정 언어(여기에서는 plproxy)의 사용 권한을 부여받기 위해서는 해당언어에 신뢰성을 먼저 부여하여야 한다. 다음은 pg_language 카탈로그에서 plproxy 언어의 신뢰성을 부여하고 사용권한을 kim이라는 유저에게 부여하는 예제이다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost extension]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -U postgres proxy_database;</KBD
>
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>proxy_database=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from pg_language;</KBD
>
 lanname  | lanowner | lanispl | lanpltrusted | lanplcallfoid | laninline | lanvalidator | lanacl 
----------+----------+---------+--------------+---------------+-----------+--------------+--------
 internal |       10 | f       | f            |             0 |         0 |         2246 | 
 c        |       10 | f       | f            |             0 |         0 |         2247 | 
 sql      |       10 | f       | t            |             0 |         0 |         2248 | 
 plpgsql  |       10 | t       | t            |         12777 |     12778 |        12779 | 
 plproxy  |       10 | t       | f            |         16452 |         0 |            0 | 
(5 rows)

<SAMP
CLASS="PROMPT"
>proxy_database=#</SAMP
> <KBD
CLASS="USERINPUT"
>update pg_language set lanpltrusted = 't' where lanname = 'plproxy';     -- plproxy에 신뢰성 부여</KBD
>
UPDATE 1
<SAMP
CLASS="PROMPT"
>proxy_database=#</SAMP
> <KBD
CLASS="USERINPUT"
>grant usage on language plproxy to kim;       -- kim에게 plproxy 사용 권한 부여</KBD
>
GRANT
<SAMP
CLASS="PROMPT"
>proxy_database=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from pg_language;</KBD
>
 lanname  | lanowner | lanispl | lanpltrusted | lanplcallfoid | laninline | lanvalidator |                      lanacl                      
----------+----------+---------+--------------+---------------+-----------+--------------+--------------------------------------------------
 internal |       10 | f       | f            |             0 |         0 |         2246 | 
 c        |       10 | f       | f            |             0 |         0 |         2247 | 
 sql      |       10 | f       | t            |             0 |         0 |         2248 | 
 plpgsql  |       10 | t       | t            |         12777 |     12778 |        12779 | 
 plproxy  |       10 | t       | t            |         16452 |         0 |            0 | {=U/postgres,postgres=U/postgres,kim=U/postgres}
(5 rows)

<SAMP
CLASS="PROMPT"
>proxy_database=#</SAMP
></PRE
></LI
><LI
><P
>이제 kim이라는 유저는 proxy_database에서 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>를 이용한 함수를 작성할 수 있다.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PLPROXY-QUICKSTART"
>1.2. Quick Start</A
></H2
><P
>간단한 <SPAN
CLASS="PRODUCTNAME"
>PL/Proxy</SPAN
>의 사용예를 살펴보도록 하겠다.
 본 예제는 proxy_database라는 이름의 데이터가 없고 원격 DB에 접근할 수 있는 proxy function(function명 get_user_email)만을 지닌 DB에서 part00이라는 실제 데이터(name, email 칼럼을 지닌 users라는 테이블)를 지닌 DB에 접근하여 데이터(email)를 가져오는 시나리오이다. 이때 part00 DB의 users 테이블의 소유자는 kim이고 proxy_database의 get_user_email 함수의 소유자 역시 kim이다. 만약 proxy database의 함수생성 유저와 원격 DB의 테이블 유저가 다를 경우 접근 권한 오류가 생긴다.</P
><P
><IMG
SRC="images/plproxy_example.png"></P
><P
></P
><OL
TYPE="1"
><LI
><P
>먼저 proxy_database와 part00 DB의 테이블 및 데이터 정보를 확인한다. proxy_database에는 아무런 테이블도 존재하지 않고 part00에는 kim이 소유자인 users 테이블이 존재한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>[agens@localhost extension]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -U kim proxy_database;</KBD
>
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>\dt       -- proxy_database에 존재하는 table 확인</KBD
>
No relations found.
<SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>\c part00       -- part00 DB에 연결</KBD
>
You are now connected to database "part00" as user "kim".
<SAMP
CLASS="PROMPT"
>part00=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>select * from users;        -- users 테이블의 데이터 확인</KBD
>
 name |        email         
------+----------------------
 kim  | khkim@bitnine.co.kr
 jang | ksjang@bitnine.co.kr
 jeon | hcjeon@bitnine.co.kr
(3 rows)

<SAMP
CLASS="PROMPT"
>part00=&#62;</SAMP
></SAMP
></PRE
></LI
><LI
><P
>proxy_database에 접속하여 이름을 입력하면 part00의 users 테이블에서 입력된 이름에 맞는 이메일 주소를 가져오는 함수 get_user_email을 plproxy를 사용하여 만든다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>part00=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>\c proxy_database</KBD
>
You are now connected to database "proxy_database" as user "kim".
<SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>CREATE FUNCTION get_user_email(i_username text)
proxy_database-&#62; RETURNS SETOF text AS $$
proxy_database$&#62;     CONNECT 'dbname=part00';
proxy_database$&#62;     SELECT email FROM users WHERE name = $1;
proxy_database$&#62; $$ LANGUAGE plproxy;</KBD
>
CREATE FUNCTION
<SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
></SAMP
></PRE
></LI
><LI
><P
>get_user_email을 통해 'kim'의 이메일을 part00의 users테이블에서 불러온다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
> <KBD
CLASS="USERINPUT"
>select * from get_user_email('kim');</KBD
>
   get_user_email    
---------------------
 khkim@bitnine.co.kr
(1 row)

<SAMP
CLASS="PROMPT"
>proxy_database=&#62;</SAMP
></SAMP
></PRE
></LI
></OL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PGBOUNCER"
></A
>장 2. <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
></H1
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>는 Connection Pooling 기능을 제공하기 위한 모듈로써, 다수의 트랜잭션 및 클라이언트의 DB 연결 작업이 필요한 OLTP 환경에서 최적의 리소스 활용 효율을 제공하여 준다.
     <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>에 대한 자세한 정보는 <A
HREF="https://pgbouncer.github.io"
TARGET="_top"
> https://pgbouncer.github.io</A
>에서 확인하기 바란다. 다음 그림은 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>에 대한 개괄적인 아키텍쳐 그림이다. 해당 그림은 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
> 내에 다수의 pool과 각각의 안에 client user명/연결 DB명의 순서쌍으로 명명된 connection들을 지님을 보여 주고 있다. 
 </P
><P
><IMG
SRC="images/pgbouncer_architecture.png"></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PGBOUNCER-CONFIGURATION"
>2.1. 설정</A
></H2
><P
>         <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>을 통해 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 설치한 후, 실제 사용을 하기 위해서는 <TT
CLASS="FILENAME"
>.ini</TT
>환경파일의 설정이 필요하다. 본 장에서는 개괄적인 <TT
CLASS="FILENAME"
>.ini</TT
>환경파일 설정에 대하여 알아보도록 한다. 편의상 <TT
CLASS="FILENAME"
>pgbouncer.ini</TT
>라는 이름으로 환경파일을 설정하겠다. 파일명은 확장자가 <TT
CLASS="FILENAME"
>.ini</TT
>라는 것을 전제하에 얼마든지 변경가능하다.
     </P
><P
></P
><UL
><LI
><P
><TT
CLASS="FILENAME"
>pgbouncer.ini</TT
>파일은 [databases] 설정과 [pgbouncer] 설정, 이렇게 두 가지 파트로 이루어진다.
             </P
><P
>                     <TT
CLASS="COMMAND"
>$ vi pgbouncer.ini</TT
>
                     </P><PRE
CLASS="PROGRAMLISTING"
>[databases]
db = ...
[pgbouncer]
...
                     </PRE
><P>
                 </P
><P
>[databases] 파트의 db는 DB 연결명이다. <SPAN
CLASS="PRODUCTNAME"
>psql</SPAN
>과 같은 클라이언트 유틸리티를 통해 연결 대상 DB 명을 지정한 값과 대응된다. 해당 값은 경우에 따라 실제 존재하는 DB 명일수도, 단순한 alias 이름일 수도 있다.</P
><P
></P
><UL
><LI
><P
>[databases] 파트</P
><P
>[databases] 파트는 클라이언트가 접속할 DB의 Connection Pooling 관련 속성을 담는다. 클라이언트는 최초 DB 연결시 본 파트의 속성에 따라 연결을 성립시키게 된다. 다음은 해당 속성의 대표적인 예와 그에 대한 설명이다.
                     </P
><P
></P
><UL
><LI
><P
>dbname</P
><P
>dbname은 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 통해 연결되는 DB의 이름이다.
                             </P
><P
></P
><OL
TYPE="a"
><LI
><P
>                                         dbname을 명시하지 않을 경우
                                     </P
><P
>                                         DB 연결명과 동일한 DB로 연결이 된다. 만약 DB 연결명에 명시된 것과 동일한 DB가 존재하지 않는다면 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>는 연결을 거부한다.
                                     </P
></LI
><LI
><P
>                                         dbname을 명시할 경우
                                     </P
><P
>                                         해당 연결은 DB 연결명이 어떠한 이름이든 간에(실제 DB명이거나 연결에 대한 alias명이거나) dbname에 명시된 DB로 연결이 된다. 이러한 점은 fallback DB를 이용하는 환경에서 역시 유용하게 쓰일 수 있다.
                                     </P
></LI
></OL
></LI
><LI
><P
>host</P
><P
>host에는 접속하려는 DB가 있는 곳의 ip 주소가 들어가게 된다.</P
></LI
><LI
><P
>port</P
><P
>port는 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>가 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에 연결할 때에 사용될 port 번호이다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 허용하고 있는 port번호를 명시하면 된다.</P
></LI
><LI
><P
>user</P
><P
>user는 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 통해 DB에 연결시 사용될 유저의 이름을 명시한다. 해당 값이 명시될 경우 클라이언트 측에서 어떠한 DB유저명으로 접속을 하려 하든 user에 명시된 유저로 접속하게 된다.</P
></LI
></UL
></LI
><LI
><P
>[pgbouncer] 파트</P
><P
>[pgbouncer] 파트는 클라이언트가 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>에 연결할 시에 적용받게 되는 속성들을 명시한다. 다음은 해당 속성의 대표적인 예와 그에 대한 설명이다.</P
><P
></P
><UL
><LI
><P
>logfile, pidfile</P
><P
></P
><UL
><LI
><P
>logfile</P
><P
>logfile에 나타난 파일명에 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 log정보를 남기게 된다.</P
></LI
><LI
><P
>pidfile</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 시스템의 background에서 daemon화 시켜 수행하기 위해서는 pidfile에 파일명을 명시하여야 한다.</P
></LI
></UL
></LI
><LI
><P
>listen_port</P
><P
>listen_port는 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>으로의 접속 port를 명시한다. 클라이언트 측에서는 해당 port를 통하여 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에 접속하여야만 PgBouncer의 Connection Pooling 기능을 사용할 수 있다.</P
></LI
><LI
><P
>auth_file, auth_type</P
><P
></P
><UL
><LI
><P
>auth_file</P
><P
>                                         auth_file 속성은 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>에 접속할 계정 정보(유저명, 비밀번호)를 담고 있는 파일을 명시한다.
                                     </P
></LI
><LI
><P
>auth_type</P
><P
>                                         auth_type은 유효한 유저에 대한 판별은 어떻게 입증할 것 인지에 대한 속성이다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>이 단순한 비밀번호 방식으로 유저 유효성을 검사할 경우에는 plain을 명시하고, md5 방식으로 유저 유효성을 검사할 경우 md5를 명시하면 된다. 이때 md5를 이용한 검증을 하기 위해서는 auth_file내에 md5화된 암호를 기술하여야 한다. 이에 대한 자세한 설명은 공식 문서 <A
HREF="https://pgbouncer.github.io/config.html#authentication-file-format"
TARGET="_top"
>https://pgbouncer.github.io/config.html#authentication-file-format</A
>을 참고하기 바란다.
                                     </P
></LI
></UL
></LI
><LI
><P
>pool_mode</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>는 세가지 방식의 pooling 모드를 제공한다. session pooling, transaction pooling, statement pooling이 바로 그것이다. pool_mode 속성은 이에 대한 바를 명시한다.</P
></LI
><LI
><P
>max_client_conn</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 통해 Agens SQL에 접속할 수 있는 클라이언트의 개수를 설정한다. 클라이언트는 해당 속성에 명시된 값 이상으로 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 통한 DB 연결을 성립시킬 수가 없다.</P
></LI
><LI
><P
>admin_users</P
><P
>admin_users에 DB 유저이름을 넣음으로써 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
> 가상 DB를 통해 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 상태 정보를 실시간으로 모니터링 할 수 있다.</P
></LI
></UL
></LI
></UL
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PGBOUNCER-QUICKSTART"
>2.2. Quick Start</A
></H2
><P
>         <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>는 세가지의 pooling 방식을 지원한다(session, transaction, statement). 본 장에서는 간단한 예제를 통하여 이 세 가지의 pooling 방식을 살펴본다.
     </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 구동과 모니터링</P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
> 구동</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>가 설치된 디렉토리 내에서 환경설정 <TT
CLASS="FILENAME"
>.ini</TT
>파일을 인자로 넘겨주어 다음과 같이 실행한다.</P
><P
><TT
CLASS="COMMAND"
>$ pgbouncer pgbouncer.ini</TT
></P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 데몬화 시켜서 백그라운드에서 실행되게 하기 위해서는 상기 커맨드에 -d 옵션을 추가하여 수행한다. 이때 <TT
CLASS="FILENAME"
>.ini</TT
>에 pidfile 속성이 명시되어 있어야 한다.</P
><P
><TT
CLASS="COMMAND"
>$ pgbouncer -d pgbouncer.ini</TT
></P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
> 모니터링</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 백그라운드에서 실행하게 하면 손쉬운 모니터링이 가능하다. 모니터링을 위해서는 <TT
CLASS="FILENAME"
>.ini</TT
>파일의 admin_user에 명시되어 있는 유저를 이용하여 pgbouncer DB에 접속한다.</P
><P
>                     </P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost ~]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U postgres pgbouncer</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>Password for user postgres:<KBD
CLASS="USERINPUT"
></KBD
>
psql (9.4.2, server 1.5.5/bouncer)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
></PRE
><P>
                     </P
><P
>pgbouncer DB에 연결된 상태에서 help 명령을 누르면 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>가 지원하는 명령어가 나오며 이 명령어들을 활용하여 실시간 모니터링 및 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
> 제어가 가능하다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show help;</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>NOTICE:  Console usage
DETAIL:  
    SHOW HELP|CONFIG|DATABASES|POOLS|CLIENTS|SERVERS|VERSION
    SHOW STATS|FDS|SOCKETS|ACTIVE_SOCKETS|LISTS|MEM
    SHOW DNS_HOSTS|DNS_ZONES
    SET key = arg
    RELOAD
    PAUSE [&lt;db&gt;]
    RESUME [&lt;db&gt;]
    KILL &lt;db&gt;
    SUSPEND
    SHUTDOWN
SHOW</SAMP
>
<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></PRE
></LI
></UL
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 Connection State</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>에서 구분짓는 Connection의 대표적인 State에 대해서 간략히 알아보겠다.(하기 명시된 State명은 이해를 돕기위해 show pools 명령에 의해 나오는 정보를 기준으로 작성된 것이며 정식 명칭은 아니다.)</P
><P
></P
><UL
><LI
><P
>sv_active</P
><P
>서버 연결이 열려 있으며 현재 특정 클라이언트가 사용 중인 상태이다.</P
></LI
><LI
><P
>sv_idle</P
><P
>서버 연결이 열려 있으며 클라이언트와는 연결이 안되어 있는 상태이다. 새로운 클라이언트와의 연결이 언제라도 가능한 상태이며 내부적으로는 server_reset_query(session feature 초기화)가 불려졌으며 server_check_delay로 지정된 시간보다 적은 시간을 머문 상태이다.</P
></LI
><LI
><P
>sv_used</P
><P
>서버 연결이 열려있으며 sv_idle상태에서 server_check_delay로 지정된 시간을 초과하여 옮겨진 상태이다. 새로운 클라이언트와의 연결을 통해 reuse를 하기 위해서는 server_check_query가 호출되어야 한다.</P
></LI
><LI
><P
>sv_tested</P
><P
>server_reset_query 혹은 server_check_query에 의해 test가 진행 중인 상태이다. 테스트가 완료 되면 sv_idle 상태로 옮겨진다.</P
></LI
><LI
><P
>sv_login</P
><P
>서버 연결이 열려있으며 현재 DB에 login한 상태이다.</P
></LI
></UL
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 세 가지 pooling 방식</P
><P
>세 가지 각각의 pooling방식을 간단한 예제를 통해 살펴보도록 하겠다. 이에 앞서 기본적인 <TT
CLASS="FILENAME"
>.ini</TT
>파일의 설정은 다음과 같으며 session pooling, transaction pooling은 auto commit 모드를 끈 상태로 진행된다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost bin]$</SAMP
><KBD
CLASS="USERINPUT"
>vi pgbouncer.ini</KBD
>

<SAMP
CLASS="COMPUTEROUTPUT"
>[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = session
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</SAMP
></PRE
><P
>또한 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>를 백그라운드에서 실행한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>[agens@localhost bin]$</SAMP
> <KBD
CLASS="USERINPUT"
>pgbouncer -d pgbouncer.ini </KBD
>
2015-06-08 00:49:20.702 6351 LOG File descriptor limit: 1024 (H:4096), max_client_conn: 3, max fds possible: 33</SAMP
></PRE
><P
></P
><OL
TYPE="a"
><LI
><P
>session pooling</P
><P
>클라이언트 측에서 연결을 해제할 시에 서버연결은 pool로 반환된다. 다음은 session pooling을 위한 예제이다.</P
><P
>먼저 초기상태의 pool상태를 확인한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost bin]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U postgres pgbouncer</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>Password for user postgres:<KBD
CLASS="USERINPUT"
></KBD
> 
psql (9.4.2, server 1.5.5/bouncer)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
><P
>이제 클라이언트의 접속을 시도하고 다시 pool정보를 살펴본다. cl_active가 1로 변하여 클라이언트의 접속이 이루어졌다는 것을 살펴볼 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost ~]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U kim test1</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>Password for user kim: <KBD
CLASS="USERINPUT"
></KBD
>
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
></SAMP
>
                     </PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
><P
>다음 클라이언트측에서 간단한 질의를 입력하고 commit을 입력한 후 다시 pool의 정보를 살펴본다. sv_active가 1이 되어 현재 1개의 클라이언트가 서버에 연결되어 사용 중이라는 것을 알 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from table1;</KBD
>
 a | b 
---+---
(0 rows)</SAMP
>

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>commit;</KBD
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
><P
>이제 클라이언트에서 연결을 끊고 pool을 살펴본다. cl_active가 0으로 되어 클라이언트의 연결이 끊어졌고 방금 사용한 연결은 sv_idle상태로 옮겨졌음을 볼 수 있다. 그리고 일정시간(<TT
CLASS="FILENAME"
>.ini</TT
>파일의 server_check_delay에 명시된 시간)이 지난 후 다시 pool의 상태정보를 보면 sv_used 상태로 다시 옮겨졌음을 볼 수 있다. </P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>\q</KBD
></SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       1 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
><P
>이 상태에서 다시 클라이언트가 다시 연결을 시도하여 질의를 수행하면 sv_used 상태에 있었던 연결이 sv_active로 옮겨져 재사용 되었음을 알 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost ~]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U kim test1</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>Password for user kim: <KBD
CLASS="USERINPUT"
></KBD
>
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from table1;</KBD
></SAMP
>
                     </PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
></LI
><LI
><P
>transaction pooling</P
><P
>트랜잭션이 완료되면 서버연결은 pool로 반환된다. 다음은 transaction pooling을 위한 예제이다.</P
><P
>먼저 <TT
CLASS="FILENAME"
>.ini</TT
>파일의 pool_mode = transaction으로 고친다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost bin]$</SAMP
><KBD
CLASS="USERINPUT"
>vi pgbouncer.ini</KBD
>

<SAMP
CLASS="COMPUTEROUTPUT"
>[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = transaction
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</SAMP
></PRE
><P
>다음 RELOAD 명령을 통하여 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 새로운 환경설정을 다시 로드한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>RELOAD;</KBD
>
RELOAD
<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)</SAMP
></PRE
><P
>이제 클라이언트에서 새롭게 접속을 하고 질의를 수행한 후 pool의 상태정보를 확인한다. cl_active와 sv_active가 1이 되어 현재 클라이언트 1명이 작업중임을 알 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>[agens@localhost ~]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U kim test1</KBD
>
Password for user kim:<KBD
CLASS="USERINPUT"
></KBD
> 
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from table1;</KBD
>
 a | b 
---+---
(0 rows)

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
></SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)</SAMP
></PRE
><P
>이제 클라이언트 측에서 commit을 수행하여 pool의 정보를 확인한다. session 모드에서와는 다르게 sv_active가 0이 되고 sv_idle이 1이 되어 있음을 확인할 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>commit;</KBD
>
COMMIT
<SAMP
CLASS="PROMPT"
>test1=#</SAMP
></SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)</SAMP
>
                     </PRE
><P
>이제 다시 질의를 수행하여 pool을 살펴본다. sv_idle에 있던 1이 sv_active로 옮겨갔음을 확인할 수 있다. 만약 질의 수행을 server_check_delay에 명시된 시간보다 늦게 하였다면 sv_idle에서 sv_used로 옮겨간게 다시 sv_active로 옮겨가 연결을 재사용하였음을 확인할 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from table1;</KBD
>
 a | b 
---+---
(0 rows)</SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)</SAMP
></PRE
><P
>이제 commit을 하여 sv_idle상태로 전이된 연결을 확인한다. 이와 같이 transaction pooling 모드에서는 transaction의 시작과 완료 기점을 중심으로 클라이언트와의 연결을 성립 및 해제한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>commit;</KBD
>
COMMIT
<SAMP
CLASS="PROMPT"
>test1=#</SAMP
></SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)</SAMP
>
                     </PRE
></LI
><LI
><P
>statement pooling</P
><P
>개별의 Query가 끝날시에 서버연결은 pool로 반환된다. Autocommit모드가 활성화된다. 앞선 예제와 마찬가지로 <TT
CLASS="FILENAME"
>.ini</TT
>파일의 pool_mode를 statement로 변경한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost bin]$</SAMP
><KBD
CLASS="USERINPUT"
>vi pgbouncer.ini</KBD
>

<SAMP
CLASS="COMPUTEROUTPUT"
>[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = statement
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</SAMP
></PRE
><P
>다음 RELOAD 명령을 통하여 <SPAN
CLASS="PRODUCTNAME"
>PgBouncer</SPAN
>의 새로운 환경설정을 다시 로드한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>RELOAD;</KBD
>
RELOAD
<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)</SAMP
></PRE
><P
>새로운 클라이언트로 접속 후 질의를 수행하여 pool의 상태를 확인한다. statement가 수행된 이후 이전의 예에서와는 달리 sv_active에 머무르지 않고 바로 sv_idle상태로 옮겨진 것을 볼 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>[agens@localhost ~]$</SAMP
> <KBD
CLASS="USERINPUT"
>psql -p 6432 -U kim test1</KBD
>
Password for user kim: <KBD
CLASS="USERINPUT"
></KBD
>
psql (9.4.2)
Type "help" for help.

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
> <KBD
CLASS="USERINPUT"
>select * from table1;</KBD
>
 a | b 
---+---
(0 rows)

<SAMP
CLASS="PROMPT"
>test1=#</SAMP
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
><SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
> <KBD
CLASS="USERINPUT"
>show pools;</KBD
>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)

<SAMP
CLASS="PROMPT"
>pgbouncer=#</SAMP
></SAMP
>
                     </PRE
></LI
></OL
></LI
></UL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SKYTOOLS"
></A
>장 3. Skytools</H1
><P
>        <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 제공하는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>에서 제공하는 여러 모듈 중 하나의 모듈이다. <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>는 Skype에서 사용하는 replication과 failover를 위해 사용하는 패키지이다. <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>라고 불리는 큐 매커니즘과 파이썬 스크립트 유틸리티 라이브러리뿐만 아니라, 설정 및 WAL 기반의 Standby 서버를 관리하기 위한 스크립트가 포함되어 있다.
    </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>에서 제공하는 모듈 중에서 배치작업을 관리하고 수행하기 위해 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 모듈을 사용한다. 또한 다른 활용 방안인 BASE (Basically Available, soft State, Eventually consistent)시스템을 위해 사용이 가능하다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>뿐만 아니라 사용자들의 필요에 따라 다른 모듈들의 사용을 위해 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>에서 제공하는 모든 모듈을 담고있다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 제공하는 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>는 3.2 버전을 제공하고 있다. 이 매뉴얼 에서는 간단한 설명과 초기 시작 방법에 대해서 다룬다. 자세한 내용은 <A
HREF="http://skytools.projects.pgfoundry.org/skytools-3.0/README.html"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
> 공식 문서</A
>을 참고하기 바란다.

        <DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>중요: </B
>                <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
> 패키지를 사용하기 위해서는 Python <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 데이터베이스 어댑터가 필요하다. CentOS 7 기준으로 다음 명령으로 설치할 수 있다.

                </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>sudo yum install python-psycopg2.x86_64</TT
></KBD
></PRE
><P>
            </P
></BLOCKQUOTE
></DIV
>
    </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SKYTOOLS-INFO"
>3.1. <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>란?</A
></H2
><P
>            이번 절에서는 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
> 패키지에서 제공하고 있는 모듈들과 용어들을 설명한다. 용어들에 대해 간단히 설명하는 이유는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>를 사용함에 있어서 기능들에 대해 쉽게 이해할 수 있도록하기 위해서이다.
        </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SKYTOOLS-TERM"
>3.1.1. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 용어</A
></H3
><P
>                <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>과 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>에서 사용하는 용어는 다음과 같다.
            </P
><P
>                <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>Event</TT
></DT
><DD
><P
>                                Producer가 생성하는 데이터의 단위이다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>에서 event는 큐에서 제공하는 테이블들 안의 하나의 레코드이다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 각 event가 적어도 한번 확인 하는 것을 보장하고, 한번 이상 확인하는 것은 consumer에게 달려 있다.
                            </P
></DD
><DT
><TT
CLASS="VARNAME"
>Producer</TT
></DT
><DD
><P
>                                Producer는 큐에 event를 넣을 수 있는 응용프로그램들이다. Producer는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 저장 함수를 동작 가능한 어떠한 언어들로든 쓸 수 있다.
                            </P
></DD
><DT
><TT
CLASS="VARNAME"
>Consumer</TT
></DT
><DD
><P
>                                Consumer는 큐로 부터 event를 읽을 수 있는 응용프로그램이다.
                            </P
></DD
><DT
><TT
CLASS="VARNAME"
>Ticker</TT
></DT
><DD
><P
>                                Ticker는 이벤트의 배치로 큐를 분리하고 시스템의 유지 보수를 처리하는 데몬이다.
                            </P
></DD
></DL
></DIV
><P>
            </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SKYTOOLS-ELEMENT"
>3.1.2. <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
> 구성 요소</A
></H3
><P
>                <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
>의 구성 요소는 다음과 같다. 각 구성요소는 사용 목적에 따라 독립적으로 사용할 수도 있고, 연동할 수도 있다.
            </P
><P
>                <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="PRODUCTNAME"
><TT
CLASS="VARNAME"
>PGQ</TT
></SPAN
></DT
><DD
><P
>                                <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 PL/pgSQL, Python 그리고 C 코드로 되어 있는 큐 시스템이다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>의 snapshot-based의 이벤트 핸들링 아이디어에 기초를 두고 있다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 효율적, transactional, 다중 노드를 지원하는 큐 시스템이다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 작업 공유와 분배, failover와 교체(switchover), 큐와 consumer들을 포함한다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 BASE (Basically Available, soft State, Eventually consistent)시스템을 위해 사용이 가능하다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 Producers, Ticker 그리고 Consumers의 3 계층으로 나뉜다. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>의 역할은 다음과 같다.
                            </P
><P
></P
><UL
><LI
><P
>                                    데이터베이스에 여러 큐가 있을 수 있다.
                                    </P
></LI
><LI
><P
>                                        모든 큐에 삽입 할 수있는 것보다 여러 producer가 있을 수 있다. 모든 큐에 삽입 할 수있는 여러 producer가 있을 수 있다. Producer들은 어느 큐에든지 삽입이 가능하다.
                                    </P
></LI
><LI
><P
>                                    하나의 큐에 여러 consumer가 있을 수 있다.
                                    </P
></LI
><LI
><P
>                                    consumer에 여러 subconsumer가 있을 수 있다.
                                    </P
></LI
></UL
></DD
><DT
><SPAN
CLASS="PRODUCTNAME"
><TT
CLASS="VARNAME"
>Londiste</TT
></SPAN
></DT
><DD
><P
>                                <SPAN
CLASS="PRODUCTNAME"
>Londiste</SPAN
>는 replication tool로, 이벤트 운송 수단으로 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>를 사용한다. <SPAN
CLASS="PRODUCTNAME"
>Londiste</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>의 Consumer로 사용된다. <SPAN
CLASS="PRODUCTNAME"
>Londiste</SPAN
>의 특징은 다음과 같다.
                            </P
><P
></P
><UL
><LI
><P
>                                    테이블 하나씩 replication set으로 추가가 가능하다.
                                    </P
></LI
><LI
><P
>                                    테이블의 초기 사본은 다른 테이블의 이벤트의 재생을 차단하지 않는다.
                                    </P
></LI
><LI
><P
>                                    양 테이블간에 비교가 가능하다.
                                    </P
></LI
></UL
></DD
><DT
><SPAN
CLASS="PRODUCTNAME"
><TT
CLASS="VARNAME"
>walmgr</TT
></SPAN
></DT
><DD
><P
>                                <SPAN
CLASS="PRODUCTNAME"
>walmgr</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 WAL-based replication을 위한 관리 툴이다. <SPAN
CLASS="PRODUCTNAME"
>walmgr</SPAN
>는 스크립트로 WAL 아카이빙, 초기 백업, 동작중 WAL 아카이브와 복구가 가능하다.
                            </P
></DD
></DL
></DIV
><P>
            </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SKYTOOLS-START"
>3.2. Quick Start</A
></H2
><P
>            이번 절에서는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>의 Ticker 데몬을 구동하는 방법과 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>를 생성하는 방법에 대해서 다룬다.
        </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SKYTOOLS-TICKER"
>3.2.1. Ticker 데몬 구동</A
></H3
><P
>                    Consumer가 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>에 담긴 event를 사용하기 위해서는 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>의 Ticker 데몬이 동작하고 있어야 한다. Ticker는 <SPAN
CLASS="PRODUCTNAME"
>Skytools</SPAN
> 3.x 버전으로 업그레이드 되면서 <TT
CLASS="FILENAME"
>pgqd</TT
>으로 바뀌었다. Ticker 데몬을 동작하는 방법은 간단하다. 하지만 시스템 설정을 바꿔줄 필요가 있다. 
                </P
><P
>                    Ticker 데몬의 명령어는 다음 명령어를 실행한 결과로 쉽게 확인 할 수 있다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>pgqd --help</TT
></KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>usage: pgq-ticker [switches] config.file
Switches:
  -v        Increase verbosity
  -q        No output to console
  -d        Daemonize
  -h        Show help
  -V        Show version
 --ini      Show sample config file
  -s        Stop - send SIGINT to running process
  -k        Kill - send SIGTERM to running process
  -r        Reload - send SIGHUP to running process</SAMP
></PRE
><P>
                </P
><P
>                    데몬의 설정 파일 예시 또한 제공 되고 있다. 다음은 Ticker 데몬의 설정파일이다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
>[pgqd]
job_name = pgqd_ticker
db = dbname=postgres

# where to log
logfile = /home/postgres/9.4/pgsql/data/pg_log/pgqd_ticker.log

# pidfile
pidfile = /home/postgres/9.4/pgsql/data/pg_log/pgqd_ticker.pid

## optional parameters ##

# libpq connect string without dbname=
#base_connstr =

# startup db to query other databases
#initial_database = template1

# limit ticker to specific databases
#database_list =

# log into syslog
#syslog = 1
#syslog_ident = pgqd

## optional timeouts ##

# how often to check for new databases
#check_period = 60

# how often to flush retry queue
#retry_period = 30

# how often to do maintentance
#maint_period = 120

# how often to run ticker
#ticker_period = 1</PRE
><P>
                </P
><P
>                    <TT
CLASS="FILENAME"
>pgqd.ini</TT
>라는 설정 파일을 만들어서 Ticker 데몬을 실행 한 후 다음과 같은 명령어로 동작 되고 있는 것을 확인할 수 있다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>ps -ef | grep pgqd</TT
></KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>postgres 25249     1  0 07:17 ?        00:00:00 pgqd -d ./pgqd.ini</SAMP
></PRE
><P>
                </P
><P
>                    Ticker 데몬이 정상동작 한다면 <TT
CLASS="FILENAME"
>pgqd_ticker.log</TT
>에는 다음과 같이 표기 될 것이다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
>2015-06-24 08:34:55.710 25249 LOG postgres: pgq version ok: 3.2.6
2015-06-24 08:35:24.185 25249 LOG {ticks: 30, maint: 1, retry: 0}
2015-06-24 08:35:54.186 25249 LOG {ticks: 30, maint: 0, retry: 0}
2015-06-24 08:36:24.187 25249 LOG {ticks: 30, maint: 0, retry: 0}
2015-06-24 08:36:54.188 25249 LOG {ticks: 30, maint: 0, retry: 0}
2015-06-24 08:37:24.188 25249 LOG {ticks: 30, maint: 1, retry: 0}
2015-06-24 08:37:54.189 25249 LOG {ticks: 30, maint: 0, retry: 0}
2015-06-24 08:38:24.189 25249 LOG {ticks: 30, maint: 0, retry: 0}</PRE
><P>
                </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SKYTOOLS-MAKE-QUEUE"
>3.2.2. <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 생성</A
></H3
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>는 extension 모듈이기 때문에 <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> 명령을 통해 object을 로드 해주어야 한다. 다음의 간단한 과정을 통해 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> object를 로드하고 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>를 생성할 수 있다.
                </P
><P
></P
><OL
TYPE="1"
><LI
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> extension 모듈 로드.
                        </P
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>은 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 확장 모듈이기 때문에 <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> 명령을 사용하여 <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 스키마를 로드해야한다. 실행 예제는 아래와 같다.
                        </P
><P
>                            </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>postgres</SAMP
>=# <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>CREATE EXTENSION pgq;</TT
></KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>CREATE EXTENSION</SAMP
></PRE
><P>
                        </P
></LI
><LI
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 큐 생성.
                        </P
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 큐를 생성하기 위해서는 <TT
CLASS="COMMAND"
>SELECT</TT
> 명령어를 사용해야 한다. 실행 예제는 아래와 같다.
                        </P
><P
>                            </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>postgres</SAMP
>=# <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>SELECT * FROM pgq.create_queue('my_first_queue');</TT
></KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
> create_queue 
--------------
            1
(1 row)</SAMP
></PRE
><P>
                        </P
></LI
><LI
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
> 큐 생성확인.
                        </P
><P
>                            <SPAN
CLASS="PRODUCTNAME"
>PGQ</SPAN
>은 테이블을 생성하기 때문에 다음의 명령어로 확인이 가능하다.
                        </P
><P
>                            </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>postgres</SAMP
>=# <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>\dt+ pgq.*;</TT
></KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>                           List of relations
 Schema |      Name      | Type  |  Owner   |    Size    | Description 
--------+----------------+-------+----------+------------+-------------
 pgq    | consumer       | table | postgres | 8192 bytes | 
 pgq    | event_1        | table | postgres | 8192 bytes | 
 pgq    | event_1_0      | table | postgres | 8192 bytes | 
 pgq    | event_1_1      | table | postgres | 8192 bytes | 
 pgq    | event_1_2      | table | postgres | 8192 bytes | 
 pgq    | event_template | table | postgres | 8192 bytes | 
 pgq    | queue          | table | postgres | 16 kB      | 
 pgq    | retry_queue    | table | postgres | 8192 bytes | 
 pgq    | subscription   | table | postgres | 0 bytes    | 
 pgq    | tick           | table | postgres | 48 kB      | 
(10 rows)</SAMP
></PRE
><P>
                        </P
></LI
></OL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PGPOOLII"
></A
>장 4. pgpool-II</H1
><P
>pgpool-II는 PostgreSQL 서버와 PostgreSQL 클라이언트의 사이에서 작동하는 미들웨어이다. </P
><P
>pgpool-II가 제공하는 기능은 다음과 같다:
    <P
></P
></P><UL
><LI
><P
>            Connection pooling
        </P
><P
></P
><UL
><LI
><P
>pgpool-II는 PostgreSQL 서버와의 connection을 저장하고 새로운 같은 properties를 가진 connection 들어올때마다 사용
                </P
></LI
><LI
><P
>connection overhead 감소, 시스템의 전체 처리량을 향상
                </P
></LI
></UL
></LI
><LI
><P
>            Replication
        </P
><P
></P
><UL
><LI
><P
>                    pgpool-II는 여러개의 PostgreSQL 서버의 관리를 가능하게 함
                </P
></LI
><LI
><P
>                    Replication 기능을 사용하면 2대 이상의 물리적 디스크에 실시간 백업 생성이 가능
                </P
></LI
><LI
><P
>                    disk failure가 발생해도 서버가 지속적인 서비스를 제공하게 함
                </P
></LI
></UL
></LI
><LI
><P
>Load Balancing</P
><P
></P
><UL
><LI
><P
>Replication이 구성된 서버들 사이에 SELECT 질의들을 분산 처리 함
                </P
></LI
><LI
><P
>시스템 전체의 처리량을 향상</P
></LI
><LI
><P
>PostgreSQL 서버의 수에 비례해서 성능 향상</P
></LI
></UL
></LI
><LI
><P
>Limiting Exceeding Connections</P
><P
></P
><UL
><LI
><P
>postgreSQL는 최대 동시 접속 제한을 채운 이후의 연결에 대해서는 전부 reject한다.</P
></LI
><LI
><P
>pgpool-II도 최대 동시 접속 수에 제한이 있지만 connection에 대해 에러를 반환하는 대신 큐에 넣어 관리한다.</P
></LI
></UL
></LI
><LI
><P
>Parallel Query(사용되지 않음, 사라질 예정)</P
></LI
></UL
><P>
    pgpool-II에 대한 자세한 정보는 <A
HREF="http://www.pgpool.net/docs/latest/pgpool-en.html"
TARGET="_top"
> http://www.pgpool.net/docs/latest/pgpool-en.html</A
>에서 확인할 수 있다. </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PGPOOL-II-CONFIG"
>4.1. 설정</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN678"
>4.1.1. pgpool.conf 설정</A
></H3
><P
></P
><UL
><LI
><P
>pgpool.conf 생성</P
><P
>pgpool-II는 Agens SQL 인스톨러를 통해 설치가 되며 pgpool-II를 실행하기 위해서는 설정값이 기록되어 있는 pgpool.conf파일이 필요하다. pgpool-II를 설치하면 pgpool.conf.sample이 자동적으로 생성되어 있고 이를 복제하여 사용할 것을 권장한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>cp /path/to/pgpool-II/etc/pgpool.conf.sample /path/to/pgpool-II/etc/pgpool.conf</KBD
></PRE
><P
>pgpool.conf파일은 파라미터를 "name = value"쌍의 형태로 저장한다. </P
></LI
><LI
><P
>listen_addresses 및 port 설정</P
><P
>pgpool-II는 기본적으로 localhost에서 포트 번호 9999로 접속이 가능하게 설정되어 있다. 하지만 pgpool.conf파일의 listen_address의 값을 '*'로 바꾸면 모든 호스트에서 접속할 수 있고 특정 ip주소를 사용하여 설정할 수도 있다. 또한 포트 번호도 수정 할 수 있다.
</P><PRE
CLASS="SCREEN"
>    ...
    listen_addresses = 'localhost'
    port = 9999
    ...</PRE
><P></P
></LI
><LI
><P
>backend 설정</P
><P
>pgpool.conf에는 pgpool-II가 연결할 PostgreSQL backend를 설정해야 한다. pgpool-II는 하나 이상의 PostgreSQL backend를 설정할 수 있고, 'backend_' 접두어로 시작하며 파라미터이름 끝에 0부터 시작하는 번호가 붙는다.
</P><PRE
CLASS="SCREEN"
>    ...
    # - Backend Connection Settings -

    backend_hostname0 = 'localhost'
    backend_port0 = 5432
    backend_weight0 = 1
    backend_data_directory0 = '/path/to/Agens_SQL/pgsql/data'
    backend_flag0 = 'ALLOW_TO_FAILOVER'
    ...</PRE
><P></P
></LI
><LI
><P
>FILE LOCATIONS 설정</P
><P
>pgpool.conf파일에 FILE LOCATIONS 영역은 실제 pid파일과 log파일이 기록될 경로를 작성해야하며, pgpool-II가 해당 영역에 접근할 권한이 없거나 해당 디렉토리가 존재하지 않을 때 실행되지 않는다. </P
><P
>다음의 파라미터가 생성될 수 있는 디렉터리를 생성하거나 이미 존재하는 디렉터리로 경로를 변경해야 한다.</P
><PRE
CLASS="PROGRAMLISTING"
>#------------------------------------------------------------------------------
# FILE LOCATIONS
#------------------------------------------------------------------------------
    ...
    pid_file_name = '/path/to/pgpool/pgpool.pid'
    logdir = '/path/to/pgpool'
    ...</PRE
></LI
><LI
><P
>실행 모드 설정</P
><P
>pgpool-II는 설정에 따라서 몇가지 실행모드를 가지고 있는데, 그 기능을 사용하기 위해서는 pgpool.conf 파일의 해당 파라미터를 on으로 변경한다. </P
><P
>pgpool.conf에서 주요기능을 선택하는 파라미터는 다음과 같다.</P
><P
></P
><UL
><LI
><P
>connection_cache </P
></LI
></UL
><P
></P
><UL
><LI
><P
>replication_mode</P
></LI
></UL
><P
></P
><UL
><LI
><P
>load_balance_mode</P
></LI
></UL
><P
></P
><UL
><LI
><P
>master_slave_mode</P
></LI
><LI
><P
>master_slave_sub_mode = 'slony' 또는 'stream' </P
></LI
></UL
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PGPOOL-II-QUICK"
>4.2. 시작하기</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="PGPOOL-II-QUICK-EXAMPLE"
>4.2.1. replication_mode</A
></H3
><P
>pgpool은 어떠한 실행모드로 작동시키는가에 따라서 pgpool.conf와 같은 파일을 적절하게 작성해야 하며, 이 절에서는 단일 서버에 3개의 데이터베이스를 구성하여 replication_mode를 수행하는 예제를 소개한다.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN724"
>4.2.1.1. backend 데이터베이스 설정</A
></H4
><P
></P
><OL
TYPE="1"
><LI
><P
>3개의 PostgreSQL backend를 생성한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>initdb -U agens -D /path/to/Agens/pgsql/data1</KBD
>
<SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>initdb -U agens -D /path/to/Agens/pgsql/data2</KBD
></PRE
><P
>/data 디렉토리에 생성되는 데이터베이스는 인스톨시에 생성되어 있으므로 생략한다.</P
></LI
><LI
><P
>각각의 postgresql.conf에 port번호를 5456, 5457, 5458로 수정한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>vi /path/to/Agens/pgsql/data/postgresql.conf</KBD
></PRE
><PRE
CLASS="PROGRAMLISTING"
>...
port = 5456
...</PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>vi /path/to/Agens/pgsql/data1/postgresql.conf</KBD
></PRE
><PRE
CLASS="PROGRAMLISTING"
>...
port = 5457
...</PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>vi /path/to/Agens/pgsql/data2/postgresql.conf</KBD
></PRE
><PRE
CLASS="PROGRAMLISTING"
>...
port = 5458
...</PRE
></LI
><LI
><P
>데이터베이스 서버를 실행시킨다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pg_ctl -D /path/to/Agens/pgsql/data start</KBD
>
<SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pg_ctl -D /path/to/Agens/pgsql/data1 start</KBD
>
<SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pg_ctl -D /path/to/Agens/pgsql/data2 start</KBD
></PRE
></LI
></OL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN758"
>4.2.1.2. pgpool 설정</A
></H4
><P
></P
><OL
TYPE="1"
><LI
><P
>pgpool.conf 파일 생성</P
><P
>Agens SQL 인스톨러로 pgpool을 설치하면 /path/to/Agens_SQL/pgpool/etc 디렉터리에 pgpool.conf.sample과 같은 샘플 파일들이 있다. 이를 사용하면 손쉽게 pgpool.conf를 작성할 수 있다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>cp /path/to/Agens/pgpool/etc/pgpool.conf.sample vi /path/to/Agens/pgpool/etc/pgpool.conf</KBD
></PRE
></LI
><LI
><P
>pgpool.conf 파일 수정</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>vi /path/to/Agens/pgpool/etc/pgpool.conf</KBD
></PRE
><P
>backend 설정</P
><PRE
CLASS="PROGRAMLISTING"
>backend_hostname0 = 'localhost'
backend_port0 = 5456
backend_weight0 = 1
backend_data_directory0 = '/path/to/Agens_SQL/pgsql/data'
backend_flag0 = 'ALLOW_TO_FAILOVER'

backend_hostname1 = 'localhost'
backend_port1 = 5457
backend_weight1 = 1
backend_data_directory1 = '/path/to/Agens_SQL/pgsql/data1'

backend_hostname2 = 'localhost'
backend_port2 = 5458
backend_weight2 = 1
backend_data_directory2 = '/path/to/Agens_SQL/pgsql/data2'</PRE
><P
>실행 모드를 설정하는 부분의 파라미터 값에 on을 넣는다.</P
><PRE
CLASS="PROGRAMLISTING"
>...
connection_cache = on
...
replication_mode = on
...
load_balance_mode = on
...
master_slave_mode = off
...</PRE
></LI
><LI
><P
>pgpool을 실행시킨다.</P
><P
>다음의 명령어까지 수행하면 pgpool서버에 3개의 데이터베이스 노드가 replication된 상태가 된다.</P
><PRE
CLASS="SCREEN"
>    <SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pgpool -n -d -f /path/to/Agens/pgpool/etc/pgpool.conf &#62; /path/to/Agens/pgpool/pgpool.log 2&#62;&#38;1 &#38;</KBD
></PRE
><P
>만약 pgpool을 종료하고 싶으면 다음의 명령어를 입력한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pgpool -f /path/to/Agens/pgpool/etc/pgpool.conf stop</KBD
></PRE
></LI
></OL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN786"
>4.2.1.3. replication 확인</A
></H4
><P
>pgpool에 bgbench를 이용하여 데이터를 생성하여 replication_mode가 정상적으로 작동하는지 확인 할 수 있다.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>복제할 데이터베이스를 작성한다. pgpool을 통해 bench_replication라는 이름의 데이터베이스가 모든 데이터베이스에 복제된다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>createdb -U agens -p 9999 bench_replication</KBD
></PRE
></LI
><LI
><P
>pgbench에 -i 옵션을 주어 실행한다. -i 옵션을 사전에 정의된 테이블과 데이터로 데이터베이스를 초기화 시킨다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>pgbench -U agens -i -p 9999 bench_replication</KBD
></PRE
></LI
><LI
><P
>다음은 모든 데이터베이스 노드의 정보를 보여주는 쉘스크립트이다. 이 스크립트는 pgbench가 생성한 branches, tellers, accounts, history 테이블이 보유한 행의 수를 출력한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>for port in 5456 5457 5458; do
    echo $port
    for table_name in branches tellers accounts history; do
        echo $table_name
        ./bin/psql -U agens -c "SELECT count(*) FROM pgbench_$table_name" -p $port bench_replication
    done
done</KBD
></PRE
></LI
></OL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SLONYI"
></A
>장 5. Slony-I</H1
><P
>        <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 지속적이고, 장애 극복을 지원하기 위한 master와 다중 slave replication 시스템이다. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.0 부터 지원하는 streaming replication 방식이 더 간단할 수 있지만 WAL-based replication 구성이 불가능한 경우나 데이터베이스 전체가 아닌 부분 replication이 필요한 경우에는 효과적이다. 
    </P
><P
>        <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>의 특징은 다음과 같다.
        <P
></P
></P><UL
><LI
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 다른 주요 버전간에 데이터 replication가 가능하다.
                </P
></LI
><LI
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 다른 물리장치와 OS간에 데이터 replication가 가능하다.
                </P
></LI
><LI
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 slave로 테이블 단위의 replication만을 허락한다.
                </P
></LI
><LI
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 하나 이상의 slave에 테이블 단위의 replication를 허락한다.
                </P
></LI
><LI
><P
>                    <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 다른 데이터베이스 서버가 다른 테이블의 마스터가 될 수 있다.
                </P
></LI
></UL
><P>
    </P
><P
>        <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서 제공하는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>의 버전은 2.2.4 버전을 사용한다. 이 메뉴얼에서는 간단한 설명과 초기 시작 방법에 대해서 다룬다. 자세한 내용은 <A
HREF="http://slony.info/documentation/2.2/index.html"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 공식 문서</A
>를 참고하기 바란다.
    </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SLONYI-DEF"
>5.1. <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 개념 정의</A
></H2
><P
>            이번 절에서는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>를 이해하기 위한 용어를 설명한다.
        </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SLONYI-CLUSTER"
>5.1.1. Cluster</A
></H3
><P
>                Cluster는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 데이터베이스 인스턴스들 묶어 주는 이름을 말한다. Replication은 동일한 cluster명으로 묶인 데이터베이스들 간에 동작한다. Cluster명은 <TT
CLASS="COMMAND"
>Slonik</TT
> 스크립트에 다음과 같이 직접적으로 명시한다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
                cluster name = something;
...</PRE
><P>
            </P
><P
>                Cluster명을 <TT
CLASS="COMMAND"
>something</TT
>으로 한다면, <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 각각의 데이터베이스는 _something으 cluster명으로 묶인다.
            </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SLONYI-NODE"
>5.1.2. Node</A
></H3
><P
>                Slony-I 노드는 replication에 참여하는 PostgreSQL의 데이터베이스 이름이다. Node는 Slonik 스크립트에 직접적으로 작성하여 사용하고, 작성방법은 다음과 같다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
...
                NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
                NODE 2 ADMIN CONNINFO = 'dbname=testdbslave host=server1slave user=slony';
...</PRE
><P>
            </P
><P
>                ADMIN CONNINFO는 데이터베이스 접속 정보를 나타낸다. 이 정보는 libpq 함수의 PQconnectdb()로 넘겨진다.
            </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SLONYI-REPLICATION"
>5.1.3. Replication Set</A
></H3
><P
>                Replication Set은 Slony-I 클러스터의 노드들 간에 복제되는 테이블들과 시쿼스의 집합으로 정의 된다.
                Replication Set은 여러가지 세트를 가질수 있고, replication의 "flow"는 동일할 필요가 없다.
            </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SLONYI-DEF-MORE"
>5.1.4. Origin, Providers 그리고 Subscribers</A
></H3
><P
>                Replication Set은 테이블의 데이터를 수정하고 복제될 데이터를 가지고 있는 origin 노드를 가지고 있다. 이 origin 는 origin 또는 master provider라고 한다. Slonik 스크립트에서 작성은 다음과 같다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
...
        create set (id=1, origin=1, comment='All pgbench tables');
        set add table (set id=1, origin=1, id=1, fully qualified name = 'public.pgbench_accounts', comment='accounts table');
        set add table (set id=1, origin=1, id=2, fully qualified name = 'public.pgbench_branches', comment='branches table');
        set add table (set id=1, origin=1, id=3, fully qualified name = 'public.pgbench_tellers', comment='tellers table');
        set add table (set id=1, origin=1, id=4, fully qualified name = 'public.pgbench_history', comment='history table');
...</PRE
><P>
            </P
><P
>               Subscribers는 slave 노드를 뜻한다. origin 또는 master provider의 변경이 있으면 slave 노드의 테이블의 값을 변경 한다. 
            </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SLONYI-EXAMPLE1"
>5.2. <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 구동 예제 (1)</A
></H2
><FONT
COLOR="RED"
>간단한 replication</FONT
><P
>            이번절에서는 로컬 데이터베이스로 master-slave를 구성하여 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>를 구동하는 예제를 보인다. 
        </P
><P
>            
        </P
><P
></P
><OL
TYPE="1"
><LI
><P
>환경변수 설정</P
><P
>                자주 사용해야 하는 변수는 다음과 같이 환경 변수로 등록후에 사용하면 편리하다. 다음은 환경변수를 임시로 설정하는 방법이다. 다른 방법은 <TT
CLASS="FILENAME"
>.bashrc</TT
> 파일 또는 <TT
CLASS="FILENAME"
>.bash_profile</TT
> 파일에 등록 후에 사용하면 편하게 설정 할 수 있다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>export CLUSTERNAME=slony_example
export MASTERDBNAME=pgbench
export SLAVEDBNAME=pgbenchslave
export MASTERHOST=localhost
export SLAVEHOST=localhost
export REPLICATIONUSER=postgres
export PGBENCHUSER=pgbench</PRE
><P>
            </P
></LI
><LI
><P
>데이터베이스 사용자 생성</P
><P
>                다음 명령어는 데이터베이스 사용자를 생성하는 명령어이다. 사용자의 이름은 <TT
CLASS="COMMAND"
>pgbench</TT
>로 만들고 생성 옵션 <TT
CLASS="COMMAND"
>-SRD</TT
>를 줌으로써  superuser가 아니고 role을 생성하지 않고 데이터베이스를 생성하지 않는 사용자를 만드는 명령어이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
><KBD
CLASS="USERINPUT"
>createuser -SRD $PGBENCHUSER</KBD
></PRE
><P>
            </P
></LI
><LI
><P
>데이터베이스 생성</P
><P
>                다음 명령어는 master 노드와 slave 노드를 구성하는 두 개의 데이터베이스를 생성한 후에 마스터 노드에 <TT
CLASS="COMMAND"
>pgbench</TT
>를 실행하여 데이터를 생성하는 명령어 이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>createdb -O $PGBENCHUSER -h $MASTERHOST $MASTERDBNAME
createdb -O $PGBENCHUSER -h $SLAVEHOST $SLAVEDBNAME
pgbench -i -s 1 -U $PGBENCHUSER -h $MASTERHOST $MASTERDBNAME</PRE
><P>
            </P
><P
>                <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 replication을 실행하려고 하는 테이블에 primary key가 존재 해야한다. 다음 명령어는 pgbench_history 테이블에 primary key를 생성하는 명령어이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>psql -U $PGBENCHUSER -h $MASTERHOST -d $MASTERDBNAME -c "begin;
alter table pgbench_history add column id serial;
update pgbench_history set id = nextval('pgbench_history_id_seq');
alter table pgbench_history add primary key(id);
commit;"</PRE
><P>
            </P
><P
>                <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>는 자동적으로 DDL 명령을 실행 하지 못한다. 따라서 다음 명령어로 master 노드의 테이블 스키마를 slave 노드에 생성 시켜주어야 한다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>pg_dump -s -U $REPLICATIONUSER -h $MASTERHOST $MASTERDBNAME | psql -U $REPLICATIONUSER -h $SLAVEHOST $SLAVEDBNAME</PRE
><P>
            </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>를 사용한 replication 시작</P
><P
>                다음 스크립트는 <TT
CLASS="COMMAND"
>slonik</TT
> 설정 프로세서를 실행하여 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>의 설정을 하는 스크립트이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
    #--
    # define the namespace the replication system uses in our example it is
    # slony_example
    #--
    cluster name = $CLUSTERNAME;

    #--
    # admin conninfo's are used by slonik to connect to the nodes one for each
    # node on each side of the cluster, the syntax is that of PQconnectdb in
    # the C-API
    # --
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    #--
    # init the first node.  This creates the schema
    # _$CLUSTERNAME containing all replication system specific database
    # objects.

    #--
    init cluster ( id=1, comment = 'Master Node');
 
    #--
    # Slony-I organizes tables into sets.  The smallest unit a node can
    # subscribe is a set.  The following commands create one set containing
    # all 4 pgbench tables.  The master or origin of the set is node 1.
    #--
    create set (id=1, origin=1, comment='All pgbench tables');
    set add table (set id=1, origin=1, id=1, fully qualified name = 'public.pgbench_accounts', comment='accounts table');
    set add table (set id=1, origin=1, id=2, fully qualified name = 'public.pgbench_branches', comment='branches table');
    set add table (set id=1, origin=1, id=3, fully qualified name = 'public.pgbench_tellers', comment='tellers table');
    set add table (set id=1, origin=1, id=4, fully qualified name = 'public.pgbench_history', comment='history table');

    #--
    # Create the second node (the slave) tell the 2 nodes how to connect to
    # each other and how they should listen for events.
    #--

    store node (id=2, comment = 'Slave node', event node=1);
    store path (server = 1, client = 2, conninfo='dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER');
    store path (server = 2, client = 1, conninfo='dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER');
_EOF_</PRE
><P>
            </P
><P
>                스크립트의 이름은 상관이 없지만 이 예제에서는 <TT
CLASS="FILENAME"
>slony-conf.sh</TT
>로 생성한다. 다음은 해당 스크립트에 실행 권한을 준 후에 실행하는 명령어이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>[sudo]chmod a+x ./<TT
CLASS="FILENAME"
>slony-conf.sh</TT
></TT
></KBD
>
<SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>./<TT
CLASS="FILENAME"
>slony-conf.sh</TT
></TT
></KBD
></PRE
><P>
            </P
><P
>                다음에는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> replication 데몬을 실행시켜준다. 첫 줄은 master 노드의 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 데몬을 실행 하는 명령어이다. 다음 줄은 slave 노드의 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 데몬을 실행 하는 명령어이다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>slon $CLUSTERNAME "dbname=$MASTERDBNAME user=$REPLICATIONUSER host=$MASTERHOST"</TT
></KBD
>
<SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>slon $CLUSTERNAME "dbname=$SLAVEDBNAME user=$REPLICATIONUSER host=$SLAVEHOST"</TT
></KBD
></PRE
><P>
            </P
><P
>                Replication을 시작 하기 위해 다음 스크립트 파일을 생성 후 시작 한다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
    # ----
    # This defines which namespace the replication system uses
    # ----
    cluster name = $CLUSTERNAME;

    # ----
    # Admin conninfo's are used by the slonik program to connect
    # to the node databases.  So these are the PQconnectdb arguments
    # that connect from the administrators workstation (where
    # slonik is executed).
    # ----
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    # ----
    # Node 2 subscribes set 1
    # ----
    subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);
_EOF_</PRE
><P>
            </P
><P
>                위의 스크립트를 <TT
CLASS="FILENAME"
>sloni-start.sh</TT
>로 만든 후 실행 시켜주면 성공적으로 replication이 동작된 것을 확인 할 수 있다.
            </P
><P
>                </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>[sudo]chmod a+x ./<TT
CLASS="FILENAME"
>sloni-start.sh</TT
></TT
></KBD
>
<SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>./<TT
CLASS="FILENAME"
>sloni-start.sh</TT
></TT
></KBD
></PRE
><P>
            </P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SLONYI-EXAMPLE2"
>5.3. <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 구동 예제 (2)</A
></H2
><FONT
COLOR="RED"
>테이블 스키마 변경</FONT
><P
>            이번 절에서는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
>가 동작하고 있는 상태에서 master 노드와 slave 노드의 테이블 스키마를 변경하는 방법에 대해 예제를 통해 살펴본다. 이번 절의 예제는 <SPAN
CLASS="PRODUCTNAME"
>Slony-I</SPAN
> 구동 예제 (1)가 동작하고 있는 상태를 전제로 한다.
        </P
><P
></P
><OL
TYPE="1"
><LI
><P
>해당 스크립트에 실행 권한을 주고 실행 시킨다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

slonik &#60;&#60;_EOF_
    # ----
    # This defines which namespace the replication system uses
    # ----
    cluster name = $CLUSTERNAME;

    # ----
    # Admin conninfo's are used by the slonik program to connect
    # to the node databases.  So these are the PQconnectdb arguments
    # that connect from the administrators workstation (where
    # slonik is executed).
    # ----
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    # ----
    # Node 2 subscribes set 1
    # ----
    subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);
_EOF_</PRE
><P>
                </P
></LI
><LI
><P
>slonik 설정 프로세서를 동작 시키기 위해 다음 스크립트를 작성 한다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>[sudo]chmod a+x ./<TT
CLASS="FILENAME"
>table_schema_change.sh</TT
></TT
></KBD
>
<SAMP
CLASS="PROMPT"
>localhost</SAMP
> $ <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>./<TT
CLASS="FILENAME"
>table_schema_change.sh</TT
></TT
></KBD
></PRE
><P>
                </P
></LI
><LI
><P
>테이블 변경이 제대로 되었는지 확인 하기 위해 SQL 명령을 확인 해 본다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>pgbench</SAMP
>=# <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>select * from pgbench_tellers;</TT
></KBD
>
 tid | bid | tbalance | filler | date 
-----+-----+----------+--------+------
   1 |   1 |        0 |        | 
   2 |   1 |        0 |        | 
   3 |   1 |        0 |        | 
   4 |   1 |        0 |        | 
   5 |   1 |        0 |        | 
   6 |   1 |        0 |        | 
   7 |   1 |        0 |        | 
   8 |   1 |        0 |        | 
   9 |   1 |        0 |        | 
  10 |   1 |        0 |        | 
(10 rows)</PRE
><P>
                </P
><P
>                    위와 같이 Master 노드의 테이블이 변경된 것을 확인 할 수 있다. Slave 노드에서도 동일한 SQL 명령을 확인해 보면 다음과 같이 변경된 것을 확인 할 수 있다.
                </P
><P
>                    </P><PRE
CLASS="PROGRAMLISTING"
><SAMP
CLASS="PROMPT"
>pgbenchslave</SAMP
>=# <KBD
CLASS="USERINPUT"
><TT
CLASS="COMMAND"
>select * from pgbench_tellers;</TT
></KBD
>
 tid | bid | tbalance | filler | date 
-----+-----+----------+--------+------
   1 |   1 |        0 |        | 
   2 |   1 |        0 |        | 
   3 |   1 |        0 |        | 
   4 |   1 |        0 |        | 
   5 |   1 |        0 |        | 
   6 |   1 |        0 |        | 
   7 |   1 |        0 |        | 
   8 |   1 |        0 |        | 
   9 |   1 |        0 |        | 
  10 |   1 |        0 |        | 
(10 rows)</PRE
><P>
                </P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="POSTGIS"
></A
>장 6. PostGIS</H1
><P
> PostGIS는 PostgreSQL에 지리적 객체기능을 더하여 공간정보 처리기능을 효율적으로 수행할 수 있도록 한다. 이를 이용하여 지리적 객체를 이용한 SQL query문을 작성할 수 있다. </P
><P
>PostGIS에 대한 자세한 정보는 <A
HREF="http://postgis.net/"
TARGET="_top"
> http://postgis.net/</A
>에서 확인할 수 있다.
 </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="POSTGIS-CONFIG"
>6.1. 설정</A
></H2
><P
>PostGIS 생성과 사용을 위해서는 다음의 사양들이 요구된다.</P
><P
></P
><UL
><LI
><P
>Proj4 투영 및 좌표변환 라이브러리 4.6.0 또는 그 이상 버전. Proj4 라이브러리는 PostGIS 내에서 투영 및 좌표변환을 제공하기 위해서 사용된다. proj4 는 http://trac.osgeo.org/proj/에서 다운로드 가능하다.</P
></LI
><LI
><P
>GEOS 기하학 라이브러리(geometry library)는 3.2.2. 또는 그 이상 버전이 가능하고, GEOS 3.3.2+ 이상 버전을 권장한다. GEOS 3.3 이 없으면 위상 예외 처리, ST_ValidDetail 및 ST_MakeValid 와 같은 기하 검보정 향상 등과 같은 주요한 기능이 누락될 수 있다. GEOS 3.3.2 는 토폴로지 지원(Topology support)을 위해서도 필요하다. GEOS 는 http://trac.osgeo.org/geos/로부터 다운로드 가능하며 3.3 또는 그 이상 버전은 구 버전들과 호환된다.</P
></LI
><LI
><P
>LibXML2, version 2.5.x 또는 그 이상 버전. LibXML 은 몇 가지 imports 기능 (ST_GeomFromGML 및 ST_GeomFromKML)에 사용된다. LibXML2 는 http://xmlsoft.org/downloads.html 에서 다운로드 가능하다.</P
></LI
><LI
><P
>JSON-C, version 0.9 버전 또는 그 이상 버전. JSON-C 는 ST_GeomFromGeoJson 을 통해 GeoJSON 을 불러오기 위해 사용되고 있다. JSON-C 는 http://oss.metaparadigm.com/json-c/에서 다운로드 가능하다.</P
></LI
><LI
><P
>GDAL, version 1.6 또는 그 이상 버전(1.9 또는 그 이상 버전을 권장함. 그 보다 낮은 버전에서는 작동되지 않는 것들이 있다.) 이것은 래스터 지원은 물론 CREATE EXTENSION postgis 설치를 가능하게 하기 때문에 래스터가 필요하지 않더라도 설치되어야 한다. http://trac.osgeo.org/gdal/wiki/DownloadSource</P
></LI
></UL
><P
>Agens SQL은 gdal, geos, proj 라이브러리를 지원하여 Agens_SQL/pgsql/lib가 LD_LIBRARY_PATH 설정되어 있으면 해당 라이브러리들이 적용된다.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="POSTGIS-QUICK"
>6.2. 시작하기</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="POSTGIS-QUICK-START"
>6.2.1. 공간데이터베이스 생성</A
></H3
><P
>공간 데이터베이스를 생성하기 위하여 다음의 순서대로 실행한다.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>공간데이터베이스를 사용할 데이터베이스를 생성한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>createdb -U agens -p 5456 my_gis_db</KBD
></PRE
></LI
><LI
><P
>psql로 데이터베이스에 접속하여 postgis extension을 설치한다.</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>psql -U agens -d my_gis_db -c "CREATE EXTENSION postgis;"</KBD
></PRE
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="90%"
><TR
><TD
ALIGN="CENTER"
><B
>주의</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>ERROR:  could not load library "/home/mesh/Agens_SQL/pgsql/lib/postgis-2.1.so": libgeos_c.so.1: 동적 오브젝트 파일을 열 수 없습니다: 그런 파일이나 디렉터리가 없습니다</P
></TD
></TR
></TABLE
></DIV
><P
>이러한 에러메시지가 발생하면 PostGIS를 생성하는데 필요한 gdal, geos, proj 라이브러리가 읽어지지 않은 것이므로 LD_LIBRARY_PATH에 /path/to/Agens_SQL/pgsql/lib를 추가한 후 서버를 재시작 해주어야 한다.</P
></LI
><LI
><P
>토폴로지는 별도의 extension으로 패키지화 되어 있고, 아래의 명령어로 설치 가능하다</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>psql -d my_gis_db -c "CREATE EXTENSION postgis_topology;"</KBD
></PRE
></LI
><LI
><P
>psql에 접속하여 다음 명령어를 통해 현재 postgis 설치여부를 확인할 수 있다.</P
><P
></P
><UL
><LI
><P
>psql로 생성한 my_gis_db에 접속</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>psql -U agens -d my_gis_db</KBD
></PRE
></LI
><LI
><P
>설치여부 확인</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>SELECT name, default_version,installed_version
                    FROM pg_available_extensions WHERE name LIKE 'postgis%' ;</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>          name                  | default_version | installed_version
-----------------------------+------------------+-------------------
 postgis                         | 2.1.7               | 2.1.7
 postgis_topology          | 2.1.7               | 2.1.7
 postgis_tiger_geocoder | 2.1.7               |
(3 rows)</SAMP
></PRE
></LI
></UL
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="POSTGIS-QUICK-EXAMPLE"
>6.2.2. geography 예제</A
></H3
><P
>다음은 geography 타입을 이용하여 PostGIS를 운용하는 예제이다.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>공간데이터 생성</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>-- create data
                     CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINT,4326) );
                     CREATE TABLE global_points (
                         id SERIAL PRIMARY KEY,
                         name VARCHAR(64),
                         location GEOGRAPHY(POINT,4326)
                     );
                     INSERT INTO global_points (name, location)
                         VALUES ('Town', ST_GeographyFromText('SRID=4326;POINT(-110 30)') );
                     INSERT INTO global_points (name, location)
                         VALUES ('Forest', ST_GeographyFromText('SRID=4326;POINT(-109 29)') );
                     INSERT INTO global_points (name, location)
                         VALUES ('London', ST_GeographyFromText('SRID=4326;POINT(0 49)') );</KBD
></PRE
></LI
><LI
><P
>인덱스 생성</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>-- Index the test table with a spherical index
                     CREATE INDEX global_points_gix ON global_points USING GIST ( location );</KBD
></PRE
></LI
><LI
><P
>예제 질의 수행</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>-- Show a distance query and note, London is outside the 1000km tolerance
                     SELECT name FROM global_points
                         WHERE ST_DWithin(location, ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);</KBD
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>-- Distance calculation using GEOGRAPHY (122.2km)
                      SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography,
                     'POINT(-21.96 64.15)':: geography);</KBD
></PRE
><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>my_gis_db=# </SAMP
><KBD
CLASS="USERINPUT"
>-- Distance calculation using GEOMETRY (13.3 "degrees")
                      SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry,
                     'POINT(-21.96 64.15)':: geometry);</KBD
></PRE
></LI
></OL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PGHINTPLAN"
></A
>장 7. pg_hint_plan</H1
><P
>        <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>은 질의문에 힌트 구문으로 실행 계획을 조작한다. <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>은 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> Version 9.1이상이 필요하다.
    </P
><P
>        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>은 비용 기반 최적기(Cost-based Optimizer:CBO)를 사용한다. 실행기(Planner)는 SQL문의 가능한 실행 계획을 세우고 그중에서 가장 적은 비용의 실행 계획을 실행 한다. 하지만 선택된 실행 계획이 최적이라는 보장이 없다. 그렇기 때문에 <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>은 실행기(Planner)에게 SQL문을 실행하기 위한 'hint'를 명시하여 사용자가 원하는 실행 계획을 하도록 할 수 있다. <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>의 현재 버전은 1.1.3으로 1.1.3버전은 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.4.x 버전에서 사용할 수 있다.
    </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PG-HINT-PLAN-SETTING"
>7.1. 설정</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="PG-HINT-PLAN-GUC"
>7.1.1. GUC 설정 방법</A
></H3
><P
>                <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>은 GUC 매개 변수를 변경 하는 방법은 크게 2가지가 있다. 하나는 <TT
CLASS="FILENAME"
>postgres.conf</TT
> 파일을 직접 변경하는 방법과 다른하나는 <TT
CLASS="COMMAND"
>psql</TT
> 내부에서 해당 쿼리에 대해서만 일시적으로 변경하는 방법이다. 전체 설정은 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일의 <TT
CLASS="COMMAND"
>shared_preload_libraries</TT
>를 작성함으로써 가능하다.
            </P
><P
></P
><UL
><LI
><P
>                        <TT
CLASS="FILENAME"
>postgres.conf</TT
> 파일 변경
                    </P
><P
>                        GUC 설정을 변경 하기 위해서는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일의 <TT
CLASS="COMMAND"
>shared_preload_libraries</TT
>을 이용하여 라이브러리를 설정 해주어야 한다. <TT
CLASS="COMMAND"
>'/path/to/pgsql/data/'</TT
> 하위의 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일의 <TT
CLASS="COMMAND"
>shared_preload_libraries</TT
>에 <TT
CLASS="COMMAND"
>pg_hint_plan</TT
>을 추가하여 다음과 같이 변경한다.
                    </P
><P
>                        </P><PRE
CLASS="SCREEN"
>shared_preload_libraries = 'pg_hint_plan'               # (change requires restart)</PRE
><P>
                    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="90%"
><TR
><TD
ALIGN="CENTER"
><B
>주의</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>                            <TT
CLASS="FILENAME"
>postgresql.conf</TT
>파일의 <TT
CLASS="COMMAND"
>shared_preload_libraries</TT
>에 <TT
CLASS="COMMAND"
>pg_hint_plan</TT
>을 추가 할때 ' (작은따옴표)로 감싸 주어야한다. 또한 여러 종류의 인자를 넣을 때는 , (쉼표)로 구분해 주어야한다.
                        </P
></TD
></TR
></TABLE
></DIV
></LI
><LI
><P
>                        GUC 매개 변수 임시 변경
                    </P
><P
>                        <TT
CLASS="COMMAND"
>Set</TT
> 힌트는 계획동안 GUC 매개변수를 변경한다. Query Planning에 보여주는 GUC 매개변수는 planner 방법 구성 매개 변수의 다른 힌트와 충돌하지 않는 한 기대 효과를 가질 수 있다. 같은 GUC 매개 변수상에서 마지막 하나만 효과가 있다. <TT
CLASS="COMMAND"
>Set</TT
> 명령어를 이용한 GUC 매개 변수 임시 변경의 예는 다음 절에서 설명한다.
                    </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1112"
>7.1.2. <TT
CLASS="COMMAND"
>LOAD</TT
> 명령을 사용한 설정</A
></H3
><P
>                <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>은 <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> 명령을 필요로 하지 않는다. 아래의 명령어와 같이 LOAD 명령으로 간단하게 사용이 가능하다.  
                <TT
CLASS="COMMAND"
>CREATE EXTENSION</TT
> 명령어를 사용할 경우 <TT
CLASS="COMMAND"
>pg_hint_plan.enable_hint_tables</TT
>를 계획할 힌트 테이블을 설정 해야 한다.
            </P
><P
>                </P><PRE
CLASS="SYNOPSIS"
>agens=# LOAD 'pg_hint_plan';</PRE
><P>
                위의 SQL 명령어는 "LOAD" 명령어를 실행한 결과와 동일하다.
            </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1122"
>7.1.3. GUC 설정 매개 변수</A
></H3
><P
>                GUC 매개변수들은 <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>의 동작에 영향을 미친다. 매개변수는 <A
HREF="#PG-HINT-PLAN-GUC-PARAMETER"
>표 7-1</A
>에 정의 되어 있다. 자세한 설정 방법은 <A
HREF="http://www.postgresql.org/docs/9.4/static/runtime-config-custom.html#GUC-CUSTOM-VARIABLE-CLASSES"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 메뉴얼</A
>을 참조하기 바란다.
            </P
><DIV
CLASS="TABLE"
><A
NAME="PG-HINT-PLAN-GUC-PARAMETER"
></A
><P
><B
>표 7-1. GUC 매개변수</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>매개 변수 이름</TH
><TH
>설명</TH
><TH
>Default</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="COMMAND"
>pg_hint_plan.enable_hint</TT
></TD
><TD
>pg_hint_plan의 기능을 Enables 또는 disables 할 수 있다.</TD
><TD
>on</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>pg_hint_plan.debug_print</TT
></TD
><TD
>pg_hint_plan의 디버그 출력을 활성화 하고 선택한다. 사용가능 옵션은 off, on, detailed, verbose 이다.</TD
><TD
>off</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>pg_hint_plan.message_level</TT
></TD
><TD
>디버그 인쇄의 메시지 레벨을 지정한다. error, warning, notice, info, log, debug 옵션을 사용가능하다. fatal과 panic은 금지된다.</TD
><TD
>info</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PG-HINT-PLAN-QUICKSTART"
>7.2. Quick Start</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="PG-HINT-PLAN-START"
>7.2.1. pg_hint_plan 기본 사용법</A
></H3
><P
>                <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
>을 성공적으로 설치 &#38; 설정 되었다면 <A
HREF="#PG-HINT-PLAN-ACTIVITY-RESULT"
>예 7-1</A
>과 같이 테스트를 하였을 때 질의문에 작성된 힌트로 실행 계획이 동작되는 것을 확인 할 수 있다. 만약 정상적으로 설치 되어 있지 않다면 <A
HREF="#PG-HINT-PLAN-NONACTIVITY-RESULT"
>예 7-2</A
>와 같이 CBO로 동작하는 것을 볼 수 있다.
            </P
><DIV
CLASS="EXAMPLE"
><A
NAME="PG-HINT-PLAN-ACTIVITY-RESULT"
></A
><P
><B
>예 7-1. 정상적으로 활성화 되었을 때의 결과</B
></P
><PRE
CLASS="PROGRAMLISTING"
>agens=# /*+ hashjoin(a b) seqscan(a) */ explain select * from pgbench_branches b join pgbench_accounts a on b.bid = a.bid order by a.aid;
                    <SAMP
CLASS="COMPUTEROUTPUT"
>&#13;                                         QUERY PLAN                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=33173.84..33423.84 rows=100000 width=461)
   Sort Key: a.aid
   -&#62;  Hash Join  (cost=1.02..4016.02 rows=100000 width=461)
         Hash Cond: (a.bid = b.bid)
         -&#62;  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
         -&#62;  Hash  (cost=1.01..1.01 rows=1 width=364)
               -&#62;  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=364)
(7 rows)
                    </SAMP
>
                </PRE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="PG-HINT-PLAN-NONACTIVITY-RESULT"
></A
><P
><B
>예 7-2. 정상적으로 활성화 되지 않았을 때의 결과</B
></P
><PRE
CLASS="PROGRAMLISTING"
>agens=# /*+ hashjoin(a b) seqscan(a) */ explain select * from pgbench_branches b join pgbench_accounts a on b.bid = a.bid order by a.aid;
                    <SAMP
CLASS="COMPUTEROUTPUT"
>&#13;                                         QUERY PLAN                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.29..5748.31 rows=100000 width=461)
   Join Filter: (b.bid = a.bid)
   -&#62;  Index Scan using pgbench_accounts_pkey on pgbench_accounts a  (cost=0.29..4247.29 rows=100000 width=97)
   -&#62;  Materialize  (cost=0.00..1.01 rows=1 width=364)
         -&#62;  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=364)
(5 rows)
                    </SAMP
>
                </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PG-HINT-PLAN-HINT-LIST"
>7.3. 힌트 목록</A
></H2
><P
>            <SPAN
CLASS="PRODUCTNAME"
>pg_hint_plan</SPAN
> 패키지로 사용할 수 있는 힌트의 목록은 다음과 같다.
        </P
><DIV
CLASS="TABLE"
><A
NAME="PG-HINT-PLAN-LISTED-TABLE"
></A
><P
><B
>표 7-2. 힌트 목록</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Group</TH
><TH
>Format</TH
><TH
>설명</TH
></TR
></THEAD
><TBODY
><TR
><TD
ROWSPAN="10"
VALIGN="MIDDLE"
>Scan method</TD
><TD
><TT
CLASS="COMMAND"
>SeqScan(table)</TT
></TD
><TD
>테이블에 순차 검색 하도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>TidScan(table)</TT
></TD
><TD
>테이블에 TID로 검색하도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>IndexScan(table[ index...])</TT
></TD
><TD
>테이블에 인덱스 검색하도록 강제한다. 만약 인덱스가 있다면, 명시된 인덱스로 제한한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>IndexOnlyScan(table[ index...])</TT
></TD
><TD
>* 테이블에 인덱스 만을 검색 하도록 강제한다.  만약 인덱스가 있다면, 명시된 인덱스로 제한한다. Index-only scan은<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.2이상 버전에서 가능하다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>BitmapScan(table[ index...])</TT
></TD
><TD
>테이블에 비트맵 검색을 강제한다. 만약 명시된 인덱스가 있다면, 명시된 인덱스로 제한한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoSeqScan(table)</TT
></TD
><TD
>테이블에 순차 검색을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoTidScan(table)</TT
></TD
><TD
>테이블에 TID 검색을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoIndexScan(table)</TT
></TD
><TD
>* 테이블에 인덱스 검색과 인덱스 자체 검색하지 않도록 강제한다. 인덱스 자체 검색은 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.2 이상에서 가능하다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoIndexOnlyScan(table)</TT
></TD
><TD
>* 테이블에 인덱스 자체 검색을 하지 않도록 강제한다. <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.2 이상에서 가능하다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoBitmapScan(table)</TT
></TD
><TD
>테이블에 비트맵 검색을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
ROWSPAN="6"
VALIGN="MIDDLE"
>Join method</TD
><TD
><TT
CLASS="COMMAND"
>NestLoop(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 중첩 반복 조인을 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>HashJoin(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 해시 조인을 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>MergeJoin(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 합병 조인을 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoNestLoop(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 중첩 반복 조인을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoHashJoin(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 해시 조인을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>NoMergeJoin(table table[ table...])</TT
></TD
><TD
>명시된 테이블들로 이루어진 조인에 합병 조인을 하지 않도록 강제한다.</TD
></TR
><TR
><TD
ROWSPAN="2"
VALIGN="MIDDLE"
>Join order</TD
><TD
><TT
CLASS="COMMAND"
>Leading(table table[ table...])</TT
></TD
><TD
>명시된 대로 조인 순서를 강제한다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>Leading(&#60;join pair&#62;)</TT
></TD
><TD
>명시된 대로 조인 순서와 방향을 강제한다. join pair는 중첩 된 구조를 만들 수 있는 괄호로 둘러싸인 테이블 쌍 이거나 또는 다른 조인 쌍이다.</TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>Row number correction</TT
></TD
><TD
><TT
CLASS="COMMAND"
>Rows(table table[ table...] correction)</TT
></TD
><TD
>* 명시된 테이블들로 이루어진 조인 결과의 열 번호를 정정한다. 가능한 방법에는  absolute (#&#60;n&#62;), addition (+&#60;n&#62;), subtract (-&#60;n&#62;) 그리고 multiplication (*&#60;n&#62;). &#60;n&#62; 은 strtod()가 읽기 가능한 문자열이다.</TD
></TR
><TR
><TD
>GUC</TD
><TD
><TT
CLASS="COMMAND"
>Set(GUC-param value)</TT
></TD
><TD
>planner가 동작하는 동안 GUC 매개 변수 값을 설정한다.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="POWA"
></A
>장 8. <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
></H1
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 성능 통계 정보를 모아 실시간으로 차트와 그래프 형태를 이용하여 보여준다. 이로써 DB 관리자는 <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>를 이용한 효율적인 모니터링과 손쉬운 튜닝을 할 수 있다. 
     <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>에 대한 자세한 정보는 <A
HREF="http://powa.readthedocs.org/en/latest"
TARGET="_top"
> http://powa.readthedocs.org/en/latest/</A
>에서 확인하기 바란다.
 </P
><P
>기본적으로 <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>가 제공해주는 정보는 DB들에 대한 상세정보(평균구동시간, 블록 정보, I/O 시간),  DB시스템 전체의 질의 처리 수행시간, 각 DB에서 수행된 질의들과 해당 질의에 대한 성능 통계 정보 및 인덱스 추천 정보 등이 있다. 
이와 같은 DB 통계 정보들은 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>의 stats collector 역할을 하는 모듈들이 모은 정보를 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
>가 선별하여 종합하고 이를 <SPAN
CLASS="PRODUCTNAME"
>PoWA-Web</SPAN
>을 통해 사용자에게 보여 지게 된다. 아래는 이러한 사항을 반영한 PoWA의 개괄적인 아키텍쳐이다.</P
><P
><IMG
SRC="images/powa_architecture.png"></P
><P
>PoWA는 브라우져를 통한 GUI 환경을 제공해주기 때문에 브라우져를 구동시킬 수 있는 모든 기기에서 DB 모니터링을 가능케 한다. 다음은 PoWA를 구동시킨 모습이다.    
 </P
><P
><IMG
SRC="images/powa_screenshot.png"></P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="POWA-CONFIGURATION"
>8.1. 설정</A
></H2
><P
>         <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
>와 <SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>의 두 가지 요소로 이루어져 있다. 이중에 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>pg_stat_statement</SPAN
>와 <SPAN
CLASS="PRODUCTNAME"
>pg_qualstats</SPAN
>, <SPAN
CLASS="PRODUCTNAME"
>pg_stat_kcache</SPAN
> 모듈들의 집합으로 이루어져 있다. 이 중 <SPAN
CLASS="PRODUCTNAME"
>pg_stat_statement</SPAN
>는 가장 기본적인 통계정보를 제공해주는 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 내장 모듈로써 <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
> 구동시 자동으로 load 되지만 <SPAN
CLASS="PRODUCTNAME"
>pg_qualstats</SPAN
>와 <SPAN
CLASS="PRODUCTNAME"
>pg_stat_kcache</SPAN
>는 <SPAN
CLASS="PRODUCTNAME"
>PoWA</SPAN
>에 선택적으로 설치 및 적용이 가능하다. <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>에서는 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
> 인스톨시 <SPAN
CLASS="PRODUCTNAME"
>pg_stat_statement</SPAN
>, <SPAN
CLASS="PRODUCTNAME"
>pg_qualstats</SPAN
>, <SPAN
CLASS="PRODUCTNAME"
>pg_stat_kcache</SPAN
> 모두 설치 및 적용하여 줌으로 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
>에 대한 별도의 설정 작업은 필요없다. 본 장에서는 PoWA-web을 별도로 설치할 시에 대한 설정에 대하여 알아본다.
     </P
><P
></P
><UL
><LI
><P
>                 <SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>
             </P
><P
></P
><OL
TYPE="1"
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>pip</SPAN
>설치하기</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>은 <SPAN
CLASS="PRODUCTNAME"
>PoWA-archivist</SPAN
>가 모은 통계정보를 web browser 환경으로 시각화하여 보여준다. <SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>의 설정에 앞서 파이썬 관련 패키지 설치 프로그램인 <SPAN
CLASS="PRODUCTNAME"
>pip</SPAN
>를 먼저 설치하기 바란다. (<SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>을 이용한 UI는 <SPAN
CLASS="PRODUCTNAME"
>Perl</SPAN
> 기반, <SPAN
CLASS="PRODUCTNAME"
>Apache</SPAN
>를 이용한 CGI기반, <SPAN
CLASS="PRODUCTNAME"
>Nginx</SPAN
>기반 등 다양한 형태로 제공될 수 있다.)</P
><P
>                        <TT
CLASS="COMMAND"
>$ yum install python-pip python-psycopg2                # RHEL, centos 기준</TT
>
                    </P
></LI
><LI
><P
>                        <SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>설치하기
                    </P
><P
>                        pip가 설치되면 이를 이용하여서 PoWA-web을 설치한다.
                    </P
><P
>                        <TT
CLASS="COMMAND"
>$ pip install powa-web</TT
>
                    </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
> 기본 환경 설정하기</P
><P
>                        <SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>이 설치되면 <TT
CLASS="FILENAME"
>powa-web.conf</TT
> 파일을 생성한다. (<TT
CLASS="FILENAME"
>/etc/powa-web.conf</TT
>, <TT
CLASS="FILENAME"
>~/.config/powa-web.conf</TT
>, <TT
CLASS="FILENAME"
>~/.powa-web.conf</TT
>, <TT
CLASS="FILENAME"
>./powa-web.conf</TT
> 중 하나에 생성하면 된다.)
                        <TT
CLASS="FILENAME"
>powa-web.conf</TT
> 파일 내부에 실무 환경에 맞는 환경 설정을 하여 설치를 마무리 한다. 환경 설정은 <TT
CLASS="FILENAME"
>JSON</TT
> 문법에 맞게 작성하면 된다. 다음은 그 예를 나타낸다.
                    </P
><P
>                        <TT
CLASS="COMMAND"
>$ vi powa-web.conf</TT
>
                        </P><PRE
CLASS="PROGRAMLISTING"
>servers={
    ‘main’ : {
    ‘host’ : ‘localhost’,
    ‘port’ : ‘5432’,
    ‘database’ : ‘powa’
    }
}
cookie_secret=“SUPERSECRET_THAT_YOU_SHOUD_CHANGE"
                        </PRE
><P>
                    </P
><P
>                    이 때 <TT
CLASS="COMMAND"
>cookie_secret</TT
>의 값은 클라이언트 브라우저에서 사용하는 쿠키정보를 암호화하여 서버와 통신하기 위한 키로 사용된다. 안전한 DB운영 환경을 위해 알맞은 값을 반드시 설정하기 바란다.
                    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="90%"
><TR
><TD
ALIGN="CENTER"
><B
>주의</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>                    <TT
CLASS="FILENAME"
>powa-web.conf</TT
> 설정시 <TT
CLASS="FILENAME"
>pg_hba.conf</TT
>의 내용에 맞는 설정이 필요하다. <TT
CLASS="FILENAME"
>pg_hba.conf</TT
> 설정에 대해서는 공식 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 문서를 참고하기 바란다.
                    </P
></TD
></TR
></TABLE
></DIV
></LI
></OL
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="POWA-QUICKSTART"
>8.2. Quick Start</A
></H2
><P
></P
><OL
TYPE="1"
><LI
><P
>PoWA-web 프로세스 구동하기</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PoWA-web</SPAN
>을 이용하여 브라우져의 GUI 환경에서 DB를 관리하기 위해선 우선 서버측의 PoWA-web 프로세스를 구동하여야 한다.</P
><P
>                 <TT
CLASS="COMMAND"
>$ powa-web</TT
>
             </P
></LI
><LI
><P
>브라우져를 통한 연결</P
><P
>클라이언트측의 브라우저에서 powa-web.conf에서 설정한 정보를 이용하여 PoWA에 접속한다. 이 때 PoWA-web의 기본 포트는 8888 이다.</P
><P
>접속 URL 포트를 변경하고 싶다면 python의 site-packages의 powa 폴더에서 options.py를 수정한다. 예를 들어, 포트번호를 7777로 변경하고자 한다면 아래와 같이 수정한다.</P
><P
>                 <TT
CLASS="COMMAND"
>$ vi options.py</TT
>
                 </P><PRE
CLASS="PROGRAMLISTING"
>...
    define(“port”, type=int, default=7777, metavar=“port”, help=“Listen on &lt;port&gt;”)
...
                 </PRE
><P>
             </P
></LI
></OL
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>