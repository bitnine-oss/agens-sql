<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
 <title>데이터베이스 성능 모니터링</title>

 <indexterm zone="monitoring">
  <primary>모니터링</primary>
  <secondary>데이터베이스 서버</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>

 <para>
  데이터베이스 관리자가 하는 일 가운데 하나는 
  <quote>이 데이터베이스 서버가 정상적으로 운영 되고 있는지</quote>
  를 지켜 보는 일이다.
  여기서는 이 일에 대한 부분을 다룬다.
 </para>

  <para>
   데이터베이스 운영 상태를 지켜 보거나, 성능을 분석하는 도구들은 
   여러가지가 있다. 
   이 장에서 다루는 대부분의 내용은 <productname>PostgreSQL</productname>
   통계수집기에 대한 것이지만, 
   <command>ps</>, <command>top</>, <command>iostat</>, <command>vmstat</>
   같은 유닉스에서 일반적으로 사용하는 모니터링 프로그램에 대한 
   설명도 함께 한다. 또한 EXPLAIN
   명령어로 살펴보아야 하는 최적화 되지 못한 쿼리들에 대한 해결 방법도 
   잠깐 다룬다. 
  </para>

 <sect1 id="monitoring-ps">
  <title>표준 유닉스 도구들</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>프로세스 살펴 보기</secondary>
  </indexterm>

  <para>
   대부분의 유닉스 환경에서는 <productname>PostgreSQL</productname>
   서버의 동작 상태를 <command>ps</> 쉘 명령어만으로도 대략적으로
   살펴 볼 수 있다. 왜냐하면 서버는 자신 하고 있는 각각의 
   하위 프로세스들의 명령어 이름들을 동적으로 바꾸어서 운영체제가 
   그것을 볼 수 있도록 하기 때문이다. 그래서 다음과 같은 간단한 
   명령어로 서버 상태를 살펴 볼 수 있다:

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (이 명령은 여러 유닉스 제각각이다. 윗 예제는 요즘 사용하는 리눅스 
   시스템에서 사용하는 명령어다. <command>ps</> 명령의 옵션에 대한
   자세한 설명은 사용하고 있는 유닉스 운영체제 설명서를 
   설펴보는 것이 좋다.)
   윗 예제 출력 결과의 첫번째 줄은 데이터베이스 서버의 
   최상위 프로세스이며, 서버를 실행 할 때 사용했던 옵션들도 
   함께 보인다. (PostgreSQL 서버는 쓰레드 방식이 아니라, 
   다중 프로세스 방식으로 운영된다.  다중 프로세스 방식이란, 
   서버 관리자가 서버 실행 명령어를 OS 쉘에서 실행하면, 
   서버 최상위 프로세스 실행되고, 그 프로세스를 필요한 
   여러 프로세스를 실행하는 방식이다.  - 옮긴이)
   다음 다섯 줄은 이 최상위 프로세스가 실행한 서버 운영에 필요한 
   하위 프로세스들이다.  이것을 서버 백그라운드 프로세스라고 한다.
   이 프로세스들은 윗 예제와 꼭 같지는 않다. 
   <quote>autovacuum launcher</> 프로세스는 autovacuum 기능을 
   사용하지 않으면 보이지 않을 것이며, 
   서버 로그를 stderr 쪽으로 보내지 않고 따로 보관하는 
   기능을 사용한다면,  <quote>postgres: logger process</>
   같은 프로세스도 보일 것이다.
   나머지는 클라이언트가 접속해서 서버측에서 만든 
   세션 프로세스들이다.  이 세션 프로세스들은 
   다음과 같은 양식으로 보여준다:

<screen>
postgres: <replaceable>사용자</> <replaceable>데이터베이스</> <replaceable>호스트</> <replaceable>현재작업상태</>
</screen>

  사용자, 데이터베이스, (클라이언트) 호스트 정보는 
  그 프로세스가 종료 될 때까지 항상 같지만, 
  현재작업상태 정보는 그 세션의 작업 상태에 따라 
  바뀐다. 
  현재작업상태에 <literal>idle</>은 
  이 세션이 클라이언트의 명령을 대기하고 있음을 뜻한다.
  <literal>idle in transaction</>으로 표시되는 것은 
  그 세션이 현재, <command>BEGIN</> 명령을 사용해서, 
  트랜잭션 영역 안에 있지만, 클라이언트 측에서 
  아무 작업도 안하고 있는 상태이다.
  <literal>SELECT</>과 같이 명령어 종류를 보여 주는 경우도 있고, 
  그 뒤에, <literal>waiting</>이 붙어 있는 경우도 있다. 
  이 경우는 다른 프로세스가 어떤 작업을 하고 있어, 
  이 세션이 해당 작업을 대기하고 있는 상태를 나타낸다.
  윗 예제를 보면, 15610 프로세스 때문에, 
  15606 프로세스가 작업을 대기하고 있음을 알 수 있다. 
  (윗 예제 화면에서는 다른 세션들이 없기 때문에, 
  15610 프로세스가 잠금 문제를 일으킨 프로세스로 
  파악 할 수 있다.  어떤 잠금을 사용하고 있기에, 
  다른 프로세스가 기다리고 있는지에 대한 자세한 정보는
  <structname>pg_locks</structname>
  뷰를 통해서 알 수 있다.)
  </para>

  <para>
   update-process-title 환경 설정값을 
   off로 지정했다면, 프로세스 현재작업상태 자리에는
   그 프로세스의 첫 작업에 대한 이름으로 지정되면, 
   그 프로세스가 종료될 때까지 그대로 유지된다.
   몇몇 OS에서는 이 프로세스 이름을 바꾸는 작업이 부하를 유발한다고
   사용하지 않는 경우도 있고, 또 몇몇 OS에서는 
   이 작업에 대해서 전혀 신경 쓰지 않는 경우도 있다.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname>에서는 
  이 부분 처리가 독특하다. 
  먼저 <command>/bin/ps</command> 명령 대신에, 
  <command>/usr/ucb/ps</command> 사용하고, 
  <option>w</option> 옵션을 두 개 지정하고, 
  서버 시작 최상위 프로세스의 이름이 
  각 세션 프로세스의 이름보다 짧게 지정한다면, 
  세션 프로세스들의 이름이 동적으로 바뀌는 것을 살펴볼 수 있다.
  하지만, 이 세가지 조건 중 하나라도 만족하지 않는다면, 
  모든 프로세스 이름은 서버 최상위 프로세스의 이름과 같게 보인다.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>통계 수집기</title>

  <indexterm zone="monitoring-stats">
   <primary>통계</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> <firstterm>통계 수집기
   statistics collector</>는 서버 운영 상태에 대한 정보를 수집하거나
   보고하기 위한 작업을 하는 백그라운드 시스템이다.  현재, 이 수집기는
   테이블이나 인덱스의 디스크 블록 단위 또는 개별 로우 단위의 접근
   회수를 수집할 수 있다.  또한 각 테이블에 저장 되어있는 총 로우 수를
   수집하며, 각 테이블에 대한 vacuum 작업과, analyze 작업에 관한 정보들도
   수집한다. 또한 사용자 정의 함수들의 호출 회수와, 그것들의 각각
   총 수행 시간들도 수집한다.
  </para>

  <para>
   또한 <productname>PostgreSQL</productname>에서는 각각 다른 서버 프로세스들이 자기가 무슨 작업을 하고 있는지에 대한 현재 상태를 살펴볼 수 있다. 이 기능은 수집기 프로세스와 별개로 제공하고 있는 기능이다.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>통계 수집기 환경설정</title>

  <para>
   통계 자료를 수집한다는 것은 궁극적으로는 그 만큼의 추가 비용을 서버가
   사용한다는 것을 의미한다. 그래서, 그 추가 비용을 얼마만큼 쓸 것인지에
   대한 결정을 서버 환경변수로 제어할 수 있다. 다음은 
   <filename>postgresql.conf</> 환경설정 파일에서 사용할 수 있는
   환경변수들이다. (이들에 대한 보다 자세한 부분은
   <xref linkend="runtime-config">을 참고하라.)
  </para>

  <para>
   track-activities 설정값을 활성화하면 각각의
   서버 프로세스들은 현재 자신이 하고 있는 작업을 프로세스 이름으로 보여준다.
  </para>

  <para>
   track-counts 설정값을 활성화하면 테이블과 인덱스의
   사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   track-functions 설정값을 활성화하면 사용자 정의
   함수들의 사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   track-io-timing 설정값을 활성화면 블록 읽기
   쓰기 회수를 통계 수집기가 수집한다.
  </para>

  <para>
   일반적으로 이 환경설정 변수들은 <filename>postgresql.conf</>에서
   그 값을 지정하면, 이것은 모든 서버의 프로세스들을 대상으로 작동하게 된다.
   하지만,  SET 명령을 이용해서, 개별 세션 단위로
   이 설정값을 변경할 수도 있다. (이 작업은 일반 사용자가 악의적으로
   사용될 가능성이 있기 때문에, 슈퍼유저만 사용할 수 있다.)
  </para>

  <para>
   통계 수집기가 만든 정보는 stats-temp-directory 설정값으로
   지정한 디렉토리 (초기값은 <filename>pg_stat_tmp</filename>) 안에 있는
   임시파일로 저장되고, 그것을 여러 다른 PostgreSQL 프로세스들이 이용한다.
   보다 나은 성능을 위해서는 이 파일의 I/O 성능을 높이기 위해 이 디렉토리를
   메모리 기반 파일시스템에 두는 것도 좋은 방법이다. 이 통계 정보는 서버가
   중지 될 때 <filename>pg_stat</filename> 디렉토리 쪽으로 복사하는
   작업을 하기 때문에, 서버 중지, 재시작에도 자료를 그대로 유지할 수 있다.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>수집된 통계 정보 보기</title>

  <para>
   수집된 통계 정보는 아래 <xref
   linkend="monitoring-stats-views-table">에서 나열한 여러 뷰를
   통해서 살펴 볼 수 있다. 다른 방법으로는 <xref linkend="monitoring-stats-functions">에서 제공하는
   여러 통계 정보 보기 함수들을 이용해서 필요한 뷰를 직접 만들어서
   살펴 볼 수도 있을 것이다.
  </para>

  <para>
   여기서 중요한 점은 살펴 보고 있는 통계 정보는 현재 데이터베이스의
   정확한 현재 상태가 아니라는 점이다. 각 개별 프로세스들이 수집한 통계
   정보는 그 프로세스가 아무런 작업을 하고 있지 않을 때, 수집기에게 전달한다.
   즉 한 쿼리가 실행 되고 있다거나 트랜잭션 내에 있다면, 그 과정에
   생긴 통계 정보들은 반영되지 않고 있다는 것이다. 또한 통계 수집기의
   작업은 <varname>PGSTAT_STAT_INTERVAL</varname> (기본값은 500ms 이다)
   시간 간격으로 진행된다. 즉 이 만큼의 통계 정보 오차가 발생한다.
   하지만, <varname>track_activities</varname> 관련 정보는 항상 즉시 반영 된다.
  </para>

  <para>
   또 다른 중요한 점은 한 통계 정보는 해당 뷰나, 함수로 출력할 때,
   한 트랜잭션 내에서는 항상 같은 값을 출력한다. 즉, 트랜젹션이 끝날 때까지
   그 값을 유지한다. 이와 비슷하게 모든 세션들의 현재 쿼리에 대한 정보도
   하나의 트랜잭션 내에서는 같은 정보를 출력한다. 이것은 버그가 아니라
   특성이다. 이것은 한 트랜잭션 내에서 그 통계 정보가 일정하게 유지
   되도록해서 여러 다른 쿼리들에서 그 값을 일관성 있게 한다.  하지만 이것을
   원치 않는다면 각 쿼리들을 트랜잭션 단위로 분리해서 작업하면 된다.  다른
   방법으로 <function>pg_stat_clear_snapshot</function>() 함수를 사용해서,
   현재 스냅숏으로 지정된 통계 정보를 버리고 새 통계 정보를 사용할 수도 있다.
  </para>

  <para>
   하나의 트랜잭션 내에서 그 자신의 통계 정보 (아직까지 수집기 쪽으로 보내지
   않은 현재 작업 내역에 대한 정보)들은 다음과 같은 뷰에서 제공한다:
   <structname>pg_stat_xact_all_tables</>,
   <structname>pg_stat_xact_sys_tables</>,
   <structname>pg_stat_xact_user_tables</>, 
   <structname>pg_stat_xact_user_functions</>.
   이들의 통계 정보는 현재 트랜잭션 내에서도 자신의 세션 작업에 대한 통계치를
   반영 해서 다른 세션에서 수집된 정보와 자신의 세션에서 수집된 정보와 차이가 생길 수도 있다.
  </para>

  <table id="monitoring-stats-views-table">
   <title>표준 통계 정보 뷰</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>뷰 이름</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       세션 프로세스들의 정보를 각각 하나의 로우로 보여준다.
       이 프로세스들은 현재 서버를 사용하고는 있는 - 클라이언트가
       서버로 접속 해서 만들어진 하위 서버 프로세스들이며, 이들의
       현재 상태, 실행 중인 쿼리들을 살펴 볼 수 있다.
       자세한 내용은 pg-stat-activity-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_archiver</><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>WAL 아카이버 프로세스 작동에 대한 
       통계 정보를 하나의 로우로 보여준다.
       자세한 사항은
       pg-stat-archiver-view 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>
       백그라운드 라이터 프로세스의 작업 통계 정보.
       자세한 내용은 pg-stat-bgwriter-view 참조. 
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>한 로우에 하나씩 각 데이터베이스 전역 통계 정보를 보여
       준다. 자세한 내용은 pg-stat-database-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 pg-stat-all-tables-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 같은데, 시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 같은데, 시스템 테이블을 제외한
      현재 사용자 접근 할 수 있는 테이블에 대한 정보만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다.
      (즉 <structname>pg_stat_all_tables</> 쪽으로 반영 되지
      <emphasis>않은</> 트랜잭션 내의 정보다).
      이 뷰에는 사용하는 실 로우 수, 사용하지 않는 로우(dead row) 수,
      vacuum과 analyze 작업에 관계된 정보는 제공하지 않는다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 pg-stat-all-indexes-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 pg-statio-all-tables-view 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는
      테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 pg-statio-all-indexes-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       현재 접속한 데이터베이스에 속한 모든 시퀀스에 대해서
       한 로우씩 그 시퀀스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 pg-statio-all-sequences-view 참조.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</> 내용과 같은데,
      시스템 시퀀스에 대해서만 보여준다.
      (현재 사용하고 있는 시스템 시퀀스가 없음으로 이 뷰는
      항상 그 내용이 비어있을 것이다.)
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</> 내용과 같은데,
      시스템 시퀀스를 제외한 현재 사용자가 접근 할 수 있는
      시퀀스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       현재 데이터베이스에 만들어진 사용자 정의 함수들의
       실행에 대한 통계 정보를 보여준다.
       자세한 내용은 pg-stat-user-functions-view 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry><structname>pg_stat_user_functions</> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다,
      (즉 <structname>pg_stat_user_functions</> 쪽으로 반영 되지
      <emphasis>않은</> 트랜잭션 내의 정보다).
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>
       하나의 WAL 송신 프로세스에 대해서 하나의 로우로,
       대기 서버 쪽으로 보내는 리플리케이션 작업에 대한 통계 정보를
       보여준다. 자세한 내용은 pg-stat-replication-view 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       하나의 데이터베이스에서 그 전역에 걸쳐 발생한 대기 서버
       복제 작업 충돌에 의한 쿼리 실행 실패 통계 정보를 각각 하나의
       로우로 보여준다. 자세한 내용은 pg-stat-database-conflicts-view 참조. 
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   인덱스 별 통계 정보는 어느 인덱스가 많이 사용되며,
   어떻게 영향을 미치는 지를 조사하는데 특히 유용하게 쓰인다.
  </para>

  <para>
   <structname>pg_statio_</> 뷰들은 공유 버퍼의
   사용 빈도를 파악하는데 가장 기본이 되는 것들이다.
   이상적인 서버 운영 모습은 
   디스크 읽기 빈도 보다 공유 버퍼를 사용하는(buffer hit)
   빈도가 훨씬 높아서, 
   대부분의 작업이 커널 호출 작업 없이 이루워 지도록 
   하는 것이다.  한편, <productname>PostgreSQL</>
   에서는 단지 이 서버 기준으로 디스크를 읽은 것과
   서버의 공유 버퍼를 사용한 것에 대한 정보만 제공 할 
   뿐이다.  즉, 커널의 I/O 캐시 사용 빈도에 대해서는 
   제공하지 않는다.  다시 말하면, 
   정말 디스크를 읽은 것인지, OS의 I/O 캐시를 사용한 
   것인지는 이 뷰를 통해서는 알 수 없다.
   이런 세세한 부분까지 살펴 보려면, 
   OS 관련 도구들을 이용해야 할 것이다.
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title><structname>pg_stat_activity</structname> View</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>이 백엔드가 연결된 데이터베이스의 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>이 백엔드가 연결된 데이터베이스의 이름</entry>
    </row>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>이 백엔드의 프로세스 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>이 백엔드에 로그인 한 사용자의 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>이 백엔드에 로그인 한 사용자의 이름</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>이 백엔드에 연결된 애플리케이션의 이름</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>이 백엔드에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 
     서버 머신의 UNIX 소켓으로 연결이 되어 있다는 뜻이거나 autovacuum같은 내부 프로세스라는 뜻임
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry><structfield>client_addr</>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 이 필드는 IP 연결했을 때와 log-hostname이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>이 백엔드와 교류하는 데 클라이언트가 쓰는 TCP 포트 넘버. <literal>-1</>은 UNIX 소켓이 사용됐을 때
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>이 프로세스가 시작된 시간. 예를 들어 클라이언트가 서버에 연결되었을 때
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>이 프로세스의 현재 트랜잭션이 시작된 시간이거나 어떤 트랜잭션도 수행되고 있지 않을 때 null로 표시함 
      현재 쿼리가 트랜잭션의 첫 번째 쿼리이면 이 컬럼은 <structfield>query_start</> 컬럼과 같다.
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>현재 수행 중인 쿼리가 시작된 시간이거나 
      <structfield>state</>가 <literal>active</>가 아닐 때에는 마지막 쿼리가 시작된 시간을 뜻함
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry><structfield>state</>가 마지막으로 변경된 시간</entry>
    </row>
    <row>
     <entry><structfield>waiting</></entry>
     <entry><type>boolean</></entry>
     <entry>이 백엔드가 잠금을 기다리고 있으면 true</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>현재 이 백엔드의 전체 상태. 가능한 값들은 아래와 같다.
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</>: 백엔드가 쿼리를 수행하고 있다는 뜻
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</>: 백엔드가 새로운 클라이언트 명령어를 기다리고 있음을 나타냄
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</>: 백엔드가 트랜잭션을 수행하고 있지만 쿼리를 수행하고 있지는 않은 상태
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</>: <literal>idle in transaction</>과 비슷하지만 트랜잭션의 구문들 중 하나가 에러를 발생시켰을 때
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</>: 백엔드가 fast-path함수를 수행할 때
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</>: track-activities가 이 백엔드에서 비활성화됐을 때 
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>query</></entry>
     <entry><type>text</></entry>
     <entry>이 백엔드의 가장 최근 쿼리 내 텍스트. <structfield>state</>가 <literal>active</>이면 이 필드는 현재 수행 중인 쿼리를 보여 줌. 다른 state들에서는 마지막으로 수행된 쿼리를 보여 줌
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</structname> 뷰는 서버 프로세스당 한 개의 로우를 가지며 이는 해당 프로세스의 현재 활동 관련 정보를 보여준다.
  </para>

  <note>
   <para>
    <structfield>waiting</>과 <structfield>state</>컬럼은 독립적이다. 
    백엔드가 <literal>active</> 상태이면,
    <literal>waiting</>일 수도 있고 아닐 수도 있다. 상태가
    <literal>active</>이고 <structfield>waiting</>이 true면, 쿼리가 수행 중임을 뜻하지만 시스템 어딘가에서 잠금으로 블록 됐음을 뜻한다.
   </para>
  </note>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title><structname>pg_stat_archiver</structname> View</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>컬럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>성공적으로 아카이브 된 WAL 파일의 개수</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</></entry>
      <entry><type>text</type></entry>
      <entry>최근 성공적으로 아카이브 된 WAL 파일의 이름</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>최근 성공적으로 아카이브 작업을 한 시간</entry>
     </row>
     <row>
      <entry><structfield>failed_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>WAL 파일 아카이빙 시도에 실패한 횟수</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</></entry>
      <entry><type>text</type></entry>
      <entry>마지막으로 아카이빙 작업에 실패한 WAL 파일의 이름</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>마지막으로 아카이빙 작업에 실패한 시간</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>이 통계치가 마지막으로 리셋된 시간</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_archiver</structname> 뷰는 클러스터의 아카이버 프로세스에 관한 데이터가 있는 하나의 로우만 갖고 있다.
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title><structname>pg_stat_bgwriter</structname> 뷰</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpoint_timeout 환경 설정값에 따른 체크 포인트 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</></entry>
      <entry><type>bigint</type></entry>
      <entry>체크포인트 명령이 수행되어 진행한 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생한 디스크 쓰기 작업의 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생할 디스크 쓰기에
        대한 디스크 동기화 작업(fsync)에 소요된 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpointer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록해야 할 버퍼수가
       bgwriter_lru_maxpages 환경 설정값보다 많아서 작업이 중지된 회수
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 <function>fsync</> 작업을
       한 회수 (일반적으로 백엔드(세션) 프로세스가 공유 버퍼를 디스크로
       내려 쓰더라도, 이 동기화 작업은 writer 프로세스가 담당한다.
       즉 writer 프로세스의 fsync 작업 부하량을 파악하는데 도움이 됨 - 옮긴이)
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers allocated</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>이 통계값들이 초기화 된 시각</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   <structname>pg_stat_bgwriter</structname> 뷰는 항상 한 개의 로우만
   보여준다. 이 자료는 데이터클러스터 전역 정보다.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title><structname>pg_stat_database</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>데이터베이스의 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>해당 데이터베이스의 이름</entry>
    </row>
    <row>
     <entry><structfield>numbackends</></entry>
     <entry><type>integer</></entry>
     <entry>현재 연결된 백엔드의 수. 현재 상태를 가리키는 값을 리턴 하는 유일한 컬럼. 
     다른 컬럼들은 마지막 리셋 시점 이후로 축적된 값들을 리턴함.
     </entry>
    </row>
    <row>
     <entry><structfield>xact_commit</></entry>
     <entry><type>bigint</></entry>
     <entry>커밋된 트랜잭션의 수</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</></entry>
     <entry><type>bigint</></entry>
     <entry>롤백한 트랜잭션의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>버퍼 캐쉬에 이미 존재하는 디스크 블록을 감지하여 읽기가 불필요함을 알려줌. (PostgreSQL 버퍼 캐쉬 내 히트 수만 계산하고, 운영체제 파일 시스템 캐쉬는 확인하지 않음)
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리가 리턴한 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리가 fetch한 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리로 삽입된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리로 업데이트된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리로 삭제된 로우의 개수</entry>
    </row>
    <row>
     <entry><structfield>conflicts</></entry>
     <entry><type>bigint</></entry>
     <entry>복구 충돌로 인해 취소된 쿼리의 개수 (대기 서버에서만 발생하는 충돌을 말함. 
      pg-stat-database-conflicts-view 참조)
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리로 생성된 임시 파일의 개수. 모든 임시 파일은 임시 파일이 생성된 이유와 
      log-temp-files 설정을 불문하고 카운트 됨
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</></entry>
     <entry><type>bigint</></entry>
     <entry>쿼리로 임시 파일에 쓰여진 데이터의 총합. 
     모든 임시 파일은 임시 파일이 생성된 이유와 log-temp-files 설정을 불문하고 카운트 됨
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</></entry>
     <entry><type>bigint</></entry>
     <entry>감지된 교착상태의 개수</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</></entry>
     <entry><type>double precision</></entry>
     <entry>백엔드가 데이터 파일 블록을 읽는 데 소요된 시간으로 밀리세컨드 단위를 사용</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</></entry>
     <entry><type>double precision</></entry>
     <entry>백엔드가 데이터 파일 블록을 쓰는데 소요된 시간으로 밀리세컨드 단위를 사용</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>통계치가 마지막으로 리셋된 시간</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database</structname> 뷰는 클러스터 내 데이터베이스 당 한 개의 로우를 가지며 
   전체 데이터베이스 통계치를 보여준다.
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title><structname>pg_stat_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>테이블을 포함하는 스키마 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>테이블명</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>풀스캔을 시도한 횟수</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>풀스캔으로 가져온 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>인덱스 스캔을 시도한 횟수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>인덱스 스캔으로 가져온 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</></entry>
     <entry><type>bigint</></entry>
     <entry>삽입된 로우 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>업데이트된 로우 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</></entry>
     <entry><type>bigint</></entry>
     <entry>삭제된 로우 개수</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>HOT 업데이트 된 로우 개수 (예를 들어 따로 인덱스 업데이트 필요가 없는)</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>추정되는 live row 개수</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>추정되는 dead row 개수</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>테이블이 수동적으로 vacuum된 마지막 시간 
      (<command>VACUUM FULL</>은 해당되지 않음)</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>autovacuum 데몬으로 테이블이 vacuum된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>테이블이 수동적으로 분석된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>autovacuum 데몬으로 테이블이 분석된 마지막 시간</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>수동적으로 vacuum된 횟수 
      (<command>VACUUM FULL</>은 제외)</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>autovacuum 데몬으로 vacuum된 횟수</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>수동적으로 분석된 횟수</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>autovacuum 데몬으로 분석된 횟수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_tables</structname> 뷰는 현재 데이터베이스의 테이블(TOAST 테이블 포함)당 한 개의 로우를 가지며, 
   이는 해당 테이블 접근에 대한 통계치를 보여준다. <structname>pg_stat_user_tables</structname>와
   <structname>pg_stat_sys_tables</structname>뷰는 같은 정보를 가지나 사용자와 시스템 테이블 각각을 보여주는 데만 쓰인다.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title><structname>pg_stat_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>이 인덱스를 갖는 테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>이 인덱스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>이 인덱스가 있는 스키마의 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>이 인덱스를 갖는 테이블명</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>인덱스명</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>이 인덱스로 스캔한 횟수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>이 인덱스로 스캔해서 리턴된 인덱스 엔트리의 개수</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>이 인덱스로 인덱스 스캔해서 가져온 live 테이블 로우의 개수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_all_indexes</structname> 뷰는 현재 데이터베이스에서 인덱스 당 한 개의 로우를 가지며 
   해당 인덱스 접근에 대한 통계치를 보여준다. 
   <structname>pg_stat_user_indexes</structname>와 
   <structname>pg_stat_sys_indexes</structname> 뷰는 같은 정보를 갖지만 각각 사용자와 시스템 인덱스만 보여준다. 
  </para>

  <para>
   인덱스는 일반 인덱스 스캔 혹은 <quote>bitmap</>
   인덱스 스캔을 사용할 수 있다. 비트맵 스캔에서 일부 인덱스 결과는 AND나 OR 규칙으로 통합될 수 있어서, 
   비트맵 스캔이 사용되면 각각의 heap 로우들을 특정 인덱스에 매칭하기 어렵다. 비트맵 스캔은 사용된 인덱스의 
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_read</>
  를 증가시키고, 테이블의 
   <structname>pg_stat_all_tables</>.<structfield>idx_tup_fetch</>
   를 증가시키지만 
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_fetch</>에는 영향을 미치지 않는다.
  </para>

  <note>
   <para>
    <structfield>idx_tup_read</>와 <structfield>idx_tup_fetch</>의 값은 비트맵 스캔을 하지 않아도 다를 수 있다. <structfield>idx_tup_read</>는 인덱스에서 회수된 인덱스 엔트리 개수를 세지만, <structfield>idx_tup_fetch</>
    는 테이블에서 가져온 live row를 세기 때문이다. 후자는 죽었거나 아직 커밋되지 않은 로우가 fetch되어 인덱스를 사용할 경우나 index-only 스캔으로 heap fetch들을 감지하지 못한 경우 감소한다.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title><structname>pg_statio_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>이 테이블이 속한 스키마 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>이 테이블의 이름</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>이 테이블에서 읽힌 디스크 블록의 수 </entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>이 테이블 내 버퍼 히트 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>테이블의 전체 인덱스에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>테이블 내 모든 인덱스에 대한 버퍼 히트의 수</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>TOAST 테이블(있으면)에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>TOAST 테이블(있으면) 내 버퍼 히트 수 </entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>TOAST 테이블 인덱스(있으면)에서 읽힌 디스크 블록 수</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>TOAST 테이블 인덱스(있으면) 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_tables</structname> 뷰는 현재 데이터베이스에서 각 테이블당(TOAST 테이블을 포함해서) 
   한 개의 로우를 갖는데, 해당 테이블의 I/O에 대한 통계치를 보여준다. 
   <structname>pg_statio_user_tables</structname>와 
   <structname>pg_statio_sys_tables</structname> 뷰도 같은 정보를 갖지만 각기 사용자와 시스템 테이블만 보여준다.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title><structname>pg_statio_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>인덱스가 포함된 테이블의 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>인덱스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>인덱스가 포함된 스키마의 이름</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>인덱스가 포함된 테이블의 이름</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>인덱스명</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>인덱스로 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>인덱스 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_indexes</structname>뷰는 현재 데이터베이스의 각 인덱스당 하나의 로우를 갖는데, 
   해당 인덱스의 I/O에 대한 통계치를 보여준다. 
   <structname>pg_statio_user_indexes</structname>와 
   <structname>pg_statio_sys_indexes</structname> 뷰도 같은 정보를 갖지만 사용자와 시스템 인덱스만 각각 보여준다.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title><structname>pg_statio_all_sequences</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>시퀀스의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>시퀀스가 포함된 스키마명</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>시퀀스명</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>시퀀스에서 읽힌 디스크 블록의 수</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>시퀀스 내 버퍼 히트 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_statio_all_sequences</structname> 뷰는 현재 데이터베이스의 각 시퀀스당 한 개의 로우를 갖고, 
   해당 시퀀스의 I/O에 대한 통계치를 보여준다.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title><structname>pg_stat_user_functions</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</></entry>
     <entry><type>oid</></entry>
     <entry>함수의 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>함수가 포함된 스키마명</entry>
    </row>
    <row>
     <entry><structfield>funcname</></entry>
     <entry><type>name</></entry>
     <entry>함수명</entry>
    </row>
    <row>
     <entry><structfield>calls</></entry>
     <entry><type>bigint</></entry>
     <entry>함수가 호출된 횟수</entry>
    </row>
    <row>
     <entry><structfield>total_time</></entry>
     <entry><type>double precision</></entry>
     <entry>함수와 호출된 함수들에 소요된 밀리세컨드 총 시간</entry>
    </row>
    <row>
     <entry><structfield>self_time</></entry>
     <entry><type>double precision</></entry>
     <entry>호출된 함수들을 제외하고 이 함수에 소요된 밀리세컨드 총 시간</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_user_functions</structname> 뷰는 추적된 각 함수당 한 개의 로우를 가지며, 
   함수 수행에 대한 통계치를 보여 준다. track-functions는 정확히 어떤 함수가 추적되어야 하는지 정한다.
  </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title><structname>pg_stat_replication</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>WAL 송신 프로세스의 프로세스 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>WAL 송신 프로세스에 로그인 된 사용자의 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>WAL 송신 프로세스에 로그인 된 사용자의 이름</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>WAL 송신 프로세스에 연결된 애플리케이션명</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>WAL 송신자에 연결된 클라이언트의 IP 주소. 이 필드가 null이면 클라이언트가 
     서버 머신의 UNIX 소켓으로 연결되었음을 의미함
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry><structfield>client_addr</>의 DNS를 역조회해서 찾은 클라이언트의 호스트명. 
     이 필드는 IP로 연결했을 때와 log-hostname이 활성화됐을 때만 null이 아닌 값으로 저장됨
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>클라이언트가 WAL 송신자와 커뮤니케이션 하기 위해 쓰는 TCP 포트 넘버. <literal>-1</> 이면 유닉스 소켓이 사용됐을 때
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>이 프로세스가 시작된 시간. 예를 들어 WAL 송신자와 클라이언트가 연결된 시간
     </entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>현재 WAL 송신자 상태</entry>
    </row>
    <row>
     <entry><structfield>sent_location</></entry>
     <entry><type>text</></entry>
     <entry>이 연결에 전송된 마지막 트랜잭션 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>write_location</></entry>
     <entry><type>text</></entry>
     <entry>대기 서버가 디스크에 쓴 마지막 트랜잭션 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>flush_location</></entry>
     <entry><type>text</></entry>
     <entry>대기 서버가 디스크로 내린 마지막 트랜잭션 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>replay_location</></entry>
     <entry><type>text</></entry>
     <entry>대기 서버에 있는 데이터베이스로 리플레이 된 마지막 트랜잭션 로그 위치</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</></entry>
     <entry><type>integer</></entry>
     <entry>동기적인 대기 서버로 선택된 대기 서버의 우선순위</entry>
    </row>
    <row>
     <entry><structfield>sync_state</></entry>
     <entry><type>text</></entry>
     <entry>대기 서버의 동기적 상태</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_replication</structname>뷰는 WAL 송신자 프로세스당 하나의 로우를 가지며, 
   송신자가 연결된 대기 서버의 리플리케이션에 관한 통계치를 보여준다. 직접 연결된 대기 서버만 보여진다. 
   다운스트림 대기 서버에 관한 정보는 없다.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <title><structname>pg_stat_database_conflicts</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>데이터베이스의 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>데이터베이스명</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</></entry>
     <entry><type>bigint</></entry>
     <entry>드롭된 테이블스페이스로 인해 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</></entry>
     <entry><type>bigint</></entry>
     <entry>잠금 시간초과로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</></entry>
     <entry><type>bigint</></entry>
     <entry>이전 스냅샷으로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</></entry>
     <entry><type>bigint</></entry>
     <entry>고정된 버퍼로 취소된 쿼리의 수</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</></entry>
     <entry><type>bigint</></entry>
     <entry>교착상태로 취소된 쿼리의 수</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_database_conflicts</structname> 뷰는 데이터베이스당 하나의 로우를 가지며, 
   대기 서버의 복구 충돌로 인해 발생한 쿼리 취소에 대해 전체 데이터베이스 통계치를 보여준다. 
   마스터 서버에서 충돌이 발생하지 않으므로 이 뷰는 대기 서버의 정보만 갖고 있다. 
  </para>

 </sect2>

 <sect2 id="monitoring-stats-functions">
  <title>통계 함수들</title>

  <para>
   위에서 소개한 뷰를 통해서 서버 통계 정보를 살펴보는 방법과
   함께 또 다른 한 방법은 각각의 정보를 제공하는 
   함수를 사용하는 방법이다.  위에서 
   소개한 뷰들의 뷰 정의를 살펴보면, 
   각각의 뷰가 어떤 함수들을 사용하는지 알 수 있다.
   (예를 들면, <application>psql</> 에서
    <literal>\d+ pg_stat_activity</> 명령을 사용하면 된다.)
   데이터베이스 단위로 통계 정보를 보여주는 
   함수들에 대해서는 함수의 입력 인자로 데이터베이스 OID를 
   입력해야 한다.  이처럼, 테이블별, 인덱스별,
   함수별 통계 정보를 살펴보려면,
   그 각 객체의 OID를 입력 인자로 사용하면 된다.
   기억해야 할 점은, 테이블, 인덱스, 함수 같은 각 데이터베이스
   소속 객체들을 입력 인자로 쓰는 함수라면, 
   그 데이터베이스는 현재 접속한 데이터베이스가 된다.
  </para>

  <para>
   부가적으로 제공하는 통계 관련 함수들은 <xref
   linkend="monitoring-stats-funcs-table">에서 소개한다.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>부가 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       현재 세션을 처리하는 서버 프로세스의 프로세스 ID
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       특정 PID를 갖는 백엔드 정보를 담은 레코드를 리턴하거나 인자가 <symbol>NULL</symbol>일 경우에는 시스템에서 활성화된 
       각 백엔드의 레코드를 리턴함. 리턴된 필드는 <structname>pg_stat_activity</structname> 뷰의 부분집합
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 통계치 스냅샷을 버림
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 통계치 카운터 전체를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       인자에 따라서 전체 클러스터 통계치 카운터를 0으로 만듦(슈퍼 유저 권한이 필요함) 
       <literal>pg_stat_reset_shared('bgwriter')</>를 호출하면 
       <structname>pg_stat_bgwriter</>뷰에 보여진 전체 카운터들을 0으로 만듦
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 한 테이블 혹은 인덱스에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       현재 데이터베이스의 한 함수에 대한 통계치를 0으로 만듦(슈퍼 유저 권한이 필요함)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</> 뷰에서 사용되는
   <function>pg_stat_get_activity</function> 함수는
   지정한 한 세션의 현재 상태에 대한 모든 정보를 
   레코드 자료형으로 리턴한다. 
   이렇게, 가끔은 뷰보다, 함수를 직접 사용하는 것이 
   보다 유용할 때가 있다.  위에서 소개한 뷰들(<xref
   linkend="monitoring-stats-backend-funcs-table">)은 
   함수를 호출하고 그것을 뷰로 보여주기 때문에, 
   뷰를 내용으로 출력 되는 결과는 이미 지난 자료 집합이다
   보다 정확한 현재 상태를 파악 하고자 할 때, 
   이런 함수를 직접 사용하는 방법이 좋다. 
   한 예제를 소개하면,
   다음은, 현재 접속해 있는 세션들의 <acronym>PID</>와
   현재 실행 중인 쿼리 내용을 보는 쿼리다:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <title>백엔드 단위 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>현재 활성화된 백엔드 ID 넘버 집합(1부터 활성화된 백엔드 개수까지)</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>백엔드의 최근 쿼리의 텍스트</>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>최근 쿼리가 시작된 시간</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>백엔드에 연결된 클라이언트의 IP 주소</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>클라이언트가 커뮤니케이션에 쓰고 있는 TCP 포트 넘버</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>백엔드가 연결된 데이터베이스의 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>백엔드의 프로세스 ID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>프로세스가 시작된 시간</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>백엔드에 로그인한 사용자의 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting(integer)</function></literal></entry>
      <entry><type>boolean</type></entry>
      <entry>백엔드가 현재 잠금을 기다리고 있는 경우엔 true</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>현재 트랜잭션이 시작된 시간</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>잠금 보기</title>

  <indexterm zone="monitoring-locks">
   <primary>잠금</primary>
   <secondary>모니터링</secondary>
  </indexterm>

  <para>
   데이터베이스 운영 상태를 모니터링 하는 또 다른 도구는
   <structname>pg_locks</structname> 시스템 뷰다.
   이 테이블은 잠금 관리자가 현재 처리하고 있는 
   여러 잠금들에 대한 정보를 제공한다.
   이 테이블로 다음과 같은 정보들을 살펴 볼 수 있다:

   <itemizedlist>
    <listitem>
     <para>
      모든 잠금 상황을 보거나, 
      특정 데이터베이스에 속한 객체들의 잠금을 보거나,
      특정 객체와 관계된 잠금들, 또는 
      <productname>PostgreSQL</productname> 특정
      세션에 관계된 잠금들을 볼 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      현재 데이터베이스에서 어떤 세션이 잠금이 필요한데, 
      다른 세션이 먼저 잠그고 있어 다른 세션들이 대기 상태로 있는지를 
      조사할 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      잠금 경합 빈도를 살펴 전반적인 서버 성능을 조사할 수 있다.
      또한 이런 경합이 데이터베이스 사용량 변화에 어떤 
      영향을 주는지도 살펴 볼 수 있다.
     </para>
    </listitem>
   </itemizedlist>
   잠금에 대한 설명은 <productname>PostgreSQL</productname>
   동시성 제어에 대한 이해가 선행되어야 쉽게 읽을 수 있다.
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <title>Dynamic Tracing</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname>은 데이터 서버의 dynamic tracing을 지원하는 기능을 제공한다. 코드 특정 지점에서 호출된 외부 유틸리티로 dynamic tracing을 한다.
  </para>

  <para>
   프로브probe 혹은 trace point는 소스 코드에 이미 삽입돼 있는 경우가 많다. 프로브는 데이터베이스 개발자와 관리자들이 사용하도록 되어 있다. 기본적으로 프로브는 
   <productname>PostgreSQL</productname>로 컴파일 되지 않는다. 사용자는 설정 스크립트에 프로브를 컴파일 하도록 명시해야 한다. 
  </para>

  <para>
   현재 
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   유틸리티가 지원되고 있는데, 이 다큐멘테이션이 작성되는 시점에는 Solaris, mac OSX, FreeBSD, NetBSD, Oracle Linux에서 사용 가능하다. 리눅스의 
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink> 프로젝트로 DTrace와 비슷한 유틸리티를 사용할 수 있다. 이 외의 dynamic tracing 유틸리티는 <filename>src/include/utils/probes.h</>에 있는 매크로 정의를 변경하여 사용할 수 있다.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Dynamic Tracing을 위한 컴파일링</title>

  <para>
   기본적으로 프로브는 사용하지 않으므로, 설정 스크립트에 <productname>PostgreSQL</productname>이 프로브를 사용하도록 명시해 주어야 한다. DTrace를 활성화 하기 위해서 <option>--enable-dtrace</>를 명시해 주어야 한다. 
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Built-in Probes</title>

  <para>
   대부분의 표준 프로브는 <xref linkend="dtrace-probe-point-table">처럼 소스 코드에서 제공된다.
   <xref linkend="typedefs-table">에서 프로브에 사용된 타입을 볼 수 있다. 프로브가 많을수록 <productname>PostgreSQL</>의 가관측성observability을 높일 수 있다.
  </para>

 <table id="dtrace-probe-point-table">
  <title>내장된 DTrace 프로브</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>설명</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>새로운 트랜잭션이 시작하는 지점에서 발생하는 프로브. 인자는 트랜잭션 ID</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>트랜잭션이 성공적으로 완료할 때 발생하는 프로브. 인자는 트랜잭션 ID</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>트랜잭션이 성공적으로 완료되지 않았을 때 발생하는 프로브. 인자는 트랜잭션 ID</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <entry>쿼리 처리가 시작됐을 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <entry>쿼리 처리가 끝났을 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <entry>쿼리 파싱이 시작됐을 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <entry>쿼리 파싱이 끝났을 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <entry>쿼리를 다시 쓰기 시작할 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <entry>쿼리 다시 쓰기가 완료됐을 때 발생하는 프로브. 인자는 쿼리 문자열</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <entry>쿼리 플래닝이 시작됐을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <entry>쿼리 플래닝이 끝났을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <entry>쿼리 수행이 시작됐을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <entry>쿼리 수행이 끝났을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <entry>서버 프로세스가 
      <structname>pg_stat_activity</>.<structfield>status</>를 업데이트할 때마다 발생하는 프로브. 인자는 새로운 상태 문자열</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>체크포인트가 시작되면 발생하는 프로브. 인자는 shutdown나 immediate, force같은 체크포인트 타입을 표시하는 비트 플래그</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <entry>체크포인트가 완료되면 발생하는 프로브(체크포인트 처리 도중에 그 다음 차례인 프로브가 연속적으로 발생함) 첫 번째 인자는 쓰여진 버퍼의 개수. 두 번째 인자는 버퍼의 총 개수. 세 번째, 네 번째, 다섯 번째 인자는 추가되고 삭제되고 재사용된 각 xlog 파일 개수</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>체크포인트의 CLOG 부분이 시작됐을 때 발생하는 프로브. 인자를 일반 체크 포인트의 경우 true로, shutdown 체크포인트의 경우 false로 전달</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>체크 포인트의 CLOG 부분이 완료되면 발생하는 프로브. 인자는 clog-checkpoint-start인자와 같은 뜻</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>체크포인트의 SUBTRANS 부분이 시작되면 발생하는 프로브. 인자는 일반 체크포인트의 경우 true로, shutdown 체크포인트의 경우 false로 전달</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>체크포인트의 SUBTRANS 부분이 끝나면 발생하는 프로브. 인자는 subtrans-checkpoint-start인자와 같은 뜻</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>체크포인트의 MultiXact 부분이 시작되면 발생하는 프로브. 인자는 일반적인 체크포인트의 경우 true로, shutdown 체크포인트의 경우 false로 전달</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>체크포인트의 MultiXact부분이 완료되면 발생하는 프로브. 인자는 multixact-checkpoint-start인자와 같은 뜻</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>체크포인트의 버퍼 쓰기 부분이 시작되면 발생하는 프로브. 인자는 shutdown, immediate, force같은 체크포인트 타입을 구별하기 위한 비트 플래그</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <entry>체크포인트 중간에(어떤 버퍼가 쓰여야 하는지 식별한 후) dirty 버퍼를 쓰기 시작할 때 발생하는 프로브. 첫 번째 인자는 버퍼 총 개수를 뜻함. 두 번째 인자는 현재 dirty하고 쓰여져야 하는 버퍼의 개수를 뜻함</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <entry>체크포인트 중간에 버퍼가 쓰여질 때마다 발생하는 프로브. 인자는 버퍼의 ID 넘버</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <entry>모든 dirty 버퍼가 쓰여졌을 때 발생하는 프로브. 첫 번째 인자는 버퍼의 총 개수를 의미. 두 번째 인자는 체크포인트 프로세스가 실제로 쓴 버퍼의 개수. 세 번째 인자는 쓰기로 예상된 버퍼의 넘버(buffer-sync-start의 두 번째 인자). any difference reflects other processes flushing buffers during the checkpoint.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <entry>dirty 버퍼가 커널에 쓰여진 이후와 fsync 요청을 보내기 이전에 발생한 프로브</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <entry>버퍼와 디스크 동기화가 완료될 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <entry>체크포인트 두 단계가 시작됐을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <entry>체크포인트의 두 단계 부분이 완료됐을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</entry>
     <entry>버퍼 읽기가 시작될 때 발생하는 프로브. 첫 번째 인자와 두 번째 인자는 페이지의 포크와 블록 넘버를 전달(두 번째 인자는 릴레이션 익스텐션relation extension 요청일 경우 -1). 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스와 데이터베이스, 릴레이션의 식별자인 릴레이션 OID를 뜻함. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함. 일곱 번째 인자는 릴레이션 익스텐션을 요청할 때 true이고, 일반 읽기 작업에는 false를 전달함.</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</entry>
     <entry>버퍼 읽기를 완료했을 때 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크와 블록 넘버를 전달(릴레이션 익스텐션 요청의 경우 두 번째 인자는 새로 추가된 블록의 블록 넘버를 가짐). 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 뜻함. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함. 일곱 번째 인자는 릴레이션 익스텐션을 요청할 때 true이고, 일반 읽기 작업에는 false를 전달함. 여덟 번째 인자는 풀에서 버퍼를 발견하면 true이고 아니면 false를 전달함.</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>공유 버퍼에 쓰기 요청을 하기 전에 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 전달함</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>쓰기 요청이 완료됐을 때 발생하는 프로브. (데이터를 커널에 전달하는 시간만 알려 주며, 디스크에 쓰여지지 않았을 때임) 인자들은 buffer-flush-start와 같음</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>서버 프로세스가 dirty 버퍼를 쓸 때 발생하는 프로브. (자주 발생하면 
      shared-buffers가 너무 작거나 bgwriter control 매개변수가 조정이 필요함을 뜻함) 첫 번째와 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달함. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션 식별하는 릴레이션 OID를 전달함</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>dirty-buffer 쓰기가 완료됐을 때 발생하는 프로브. 인자는 buffer-write-dirty-start와 같음</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <entry>WAL 버퍼 공간이 남아 있지 않아서 서버 프로세스가 dirty WAL 버퍼에 쓰기 시작할 때 발생하는 프로브(자주 발생하면 
      wal-buffers가 너무 작다는 뜻임)</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <entry>dirty WAL 버퍼 쓰기가 완료됐을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <entry>WAL 레코드가 삽입됐을 때 발생하는 프로브. 첫 번째 인자는 해당 레코드의 리소스 관리자(rmid)임. 두 번째 인자는 info 플래그를 전달함</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <entry>WAL 세그먼트 스위치를 요청했을 때 발생하는 프로브</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>릴레이션에서 블록을 읽기 시작할 때 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달함. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 전달. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함.</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>블록 읽기가 완료됐을 때 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달함. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 전달. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함. 일곱 번째 인자는 실제로 읽힌 바이트 수를 뜻하고, 여덟 번째 인자는 요청된 숫자를 뜻함(이 두 개가 다르면 문제가 발생)</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>릴레이션에 블록을 쓸 때 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달함. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 전달. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함.</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>블록 쓰기가 완료됐을 때 발생하는 프로브. 첫 번째 및 두 번째 인자는 페이지의 포크 및 블록 넘버를 전달함. 세 번째, 네 번째, 다섯 번째 인자는 테이블스페이스, 데이터베이스, 릴레이션을 식별하는 릴레이션 OID를 전달. 여섯 번째 인자는 로컬 버퍼에 임시 릴레이션을 만든 백엔드의 ID 이거나 공유 버퍼의 InvalidBackendID (-1)을 뜻함. 일곱 번째 인자는 실제로 쓰여진 바이트 수를 뜻하고 여덟 번째 인자는 요청된 숫자를 뜻함(이 두 개가 다르면 문제가 발생)</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <entry>정렬 작업이 시작됐을 때 발생하는 프로브. 첫 번째 인자는 heap, 인덱스, 데이터 정렬을 뜻함. 두 번째 인자는 unique-value를 시행할 경우 true를 전달. 세 번째 인자는 키 컬럼의 수이고, 네 번째 인자는 허용된 워크 메모리의 킬로바이트 수를 뜻하고, 다섯 번째 인자는 정렬 결과에 랜덤 액세스random access가 요청됐을 때 true를 전달함.</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <entry>정렬이 완료됐을 때 발생하는 프로브. 첫 번째 인자는 외부 정렬일 경우 true이고, 내부 정렬일 경우에는 false임. 두 번째 인자는 외부 정렬에 사용된 디스크 블록의 수이거나 내부 정렬에 사용된 메모리의 킬로바이트 수를 뜻함</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>LWLock이 획득됐을 때 발생하는 프로브. 첫 번째 인자는 LWLock의 ID. 두 번째 인자는 요청된 잠금 모드로 독점적이거나 공유됨</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(LWLockId)</entry>
     <entry>LWLock이 풀렸을 때 발생하는 프로브(waiter가 아직 깨어있지 않을 때). 인자는 LWLock의 ID임.</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>LWLock이 즉시 가용하지 않고, 서버 프로세스가 잠금이 가용해질 때까지 기다리기 시작했을 때 발생하는 프로브. 첫 번째 인자는 LWLock의 ID이고, 두 번째 인자는 요청된 잠금 모드로 독점적이거나 공유됨</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>서버 프로세스가 LWLock 대기 상태에서 풀려났을 때(잠금을 아직 획득하지 않은 상태) 발생하는 프로브. 첫 번째 인자는 LWLock의 ID임. 두 번째 인자는 요청된 잠금 모드로 독점적이거나 공유됨</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>호출자가 대기 하지 않겠다고 하고, LWLock을 획득했을 때 발생하는 프로브. 첫 번째 인자는 LWLock의 ID임. 두 번째 인자는 요청된 잠금 모드로 독점적이거나 공유됨</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>호출자가 대기 하지 않겠다고 했는데, LWLock을 획득하지 못했을 때 발생하는 프로브. 첫 번째 인자는 LWLock의 ID임. 두 번째 인자는 요청된 잠금 모드로 독점적이거나 공유됨</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>잠금이 가용하지 않아서 heavyweight 잠금(lmgr lock) 요청이 대기하기 시작했을 때 발생하는 프로브. 첫 번째부터 네 번째까지의 인자들은 오브젝트가 잠겼는지 식별하는 태그 필드들임. 다섯 번째 인자는 잠긴 오브젝트 타입을 가리키고, 여섯 번째 인자는 요청된 잠금 타입을 가리킴.</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>heavyweight 잠금(lmgr lock) 요청의 대기 상태가 끝났을 때(예를 들어 잠금을 획득한 경우) 발생하는 프로브. 인자들은 lock-wait-start의 인자와 같음</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <entry>교착상태 감지detector가 교착상태를 발견했을 때 발생하는 프로브</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>Defined Types Used in Probe Parameters</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>자료형</entry>
     <entry>Definition</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>무부호unsigned int</entry>
    </row>
    <row>
     <entry>LWLockId</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>무부호unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>무부호unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
   <title>Using Probes</title>

  <para>
   아래 예시는 트랜잭션 수를 분석하는 DTrace 스크립트로써 성능 테스트 이전과 이후에 
   <structname>pg_stat_database</>의 스냅샷을 찍는 역할을 한다.
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   수행 하면 위 D 스크립트는 다음과 같이 출력한다.
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <para>
    SystemTap은 trace point가 호환돼도 DTrace와 다른 trace 스크립트 기호를 사용한다. SystemTap 스크립트는 하이픈 기호 대신 이중 언더스코어 기호를 사용해서 프로브 이름을 레퍼런싱해야 한다. 이는 향후 SystemTap 버전에서 개선될 예정이다.
   </para>
  </note>

  <para>
   DTrace 스크립트는 쓰거나 디버깅할 때 주의해야 한다. 수집된 trace 정보의 의미가 사라질 수 있기 때문이다. 문제가 발생하는 대부분의 경우, 시스템 내부가 아니라 장치가 원인이다. Dynamic tracing을 사용해서 정보를 얻을 때, DTrace 스크립트도 체크하고 확인해야 한다.
  </para>

  <para>
   더 많은 스크립트 예제는 PgFoundry 
   <ulink url="http://pgfoundry.org/projects/dtrace/">dtrace project</ulink>에서 참조할 수 있다.
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Defining New Probes</title>

  <para>
   개발자가 원하는 위치 내에서 새로운 프로브를 정의할 수 있는데, 재컴파일이 필요하다. 아래는 새로운 프로브를 삽입하는 과정이다.
  </para>

  <procedure>
   <step>
    <para>
     1.프로브 이름과 프로브로 가용한 데이터를 정하라.
    </para>
   </step>

   <step>
    <para>
     2.<filename>src/backend/utils/probes.d</>에 프로브 정의를 추가하라.
    </para>
   </step>

   <step>
    <para>
     3.프로브 point가 있는 모듈에 <filename>pg_trace.h</>가 없으면 포함시키고, 
     <literal>TRACE_POSTGRESQL</>프로브 매크로를 소스 코드의 원하는 위치에 넣는다.
    </para>
   </step>

   <step>
    <para>
     4.다시 컴파일하고 새 프로브가 가용한지 확인한다.
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>Example:</title>
   <para>
    트랜잭션 ID로 모든 새로운 트랜잭션을 추적하기 위해 프로브를 추가하는 예제이다.
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     1.이름은 <literal>transaction-start</> 이고 LocalTransactionId 타입인 매개변수를 갖는 프로브를 정하라.
    </para>
   </step>

   <step>
    <para>
     2.프로브 정의를 <filename>src/backend/utils/probes.d</>에 추가하라:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     프로브 이름 안의 이중 언더스코어가 있음을 유의하자. 프로브를 사용한 DTrace 스크립트에서 이중 밑줄은 하이픈으로 대체되므로 사용자 문서 이름은 <literal>transaction-start</>다.
    </para>
   </step>

   <step>
    <para>
     3.컴파일 시점에, <literal>transaction__start</>는 <literal>TRACE_POSTGRESQL_TRANSACTION_START</>라 불리는 매크로로 바뀐다(언더스코어가 각각 한 개씩 쓰이는 것을 주의하자). 이 매크로는 
     <filename>pg_trace.h</>를 포함했을 때 가용하다. 매크로 호출 부분을 소스 코드의 적당한 위치에 넣는다. 예를 들면 다음과 같다.
<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     4.재컴파일링과 새 바이너리 파일을 실행하면, 아래 DTrace 명령어를 실행했을 때 새로 추가된 프로브가 가용하다는 것을 알 수 있다. 아래와 비슷한 출력을 확인할 수 있을 것이다.
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   trace 매크로를 C코드에 추가할 때 몇 가지 주의할 점이 있다. 

   <itemizedlist>
    <listitem>
     <para>
      프로브의 매개변수로 명시된 데이터 타입이 매크로 변수의 데이터 타입과 일치해야 한다. 그렇지 않으면 컴파일 에러가 발생할 것이다.
     </para>
    </listitem>


    <listitem>
     <para>
      대부분의 플랫폼의 경우, <productname>PostgreSQL</productname>이 <option>--enable-dtrace</>로 설치되면, trace 매크로 인자들을 컨트롤할 때마다 <emphasis>trace하지 않아도</> 검증된다. 몇 개의 로컬 변수 값을 확인하는 목적이라면 크게 신경 쓰지 않아도 된다. 하지만 인자에 고비용의 함수 호출을 넣는 것은 주의해야 한다. 그런 경우에는 trace가 실제로 활성화 되었는지 확인해서 매크로를 보호하는 것이 좋다. :

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      각 trace 매크로에는 <literal>ENABLED</> 매크로가 있다.
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>

