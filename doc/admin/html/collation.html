<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>콜레이션 지원</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="로컬라이제이션"
HREF="charset.html"><LINK
REL="PREVIOUS"
TITLE="로케일(Locale) 지원"
HREF="locale.html"><LINK
REL="NEXT"
TITLE="문자 집합 지원"
HREF="multibyte.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-26T04:43:18"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="로케일(Locale) 지원"
HREF="locale.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="charset.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 6. 로컬라이제이션</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="문자 집합 지원"
HREF="multibyte.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COLLATION"
>6.2. 콜레이션 지원</A
></H1
><P
>   콜레이션 기능으로 칼럼별 및 연산별 데이터의 정렬 순서 및 문자 분류 동작을 지정할 수 있다. 
   이것은 데이터베이스 생성 후 <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> 및 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> 설정을 변경하지 못하도록 하는 제한을 풀어 준다.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN6909"
>6.2.1. 개념</A
></H2
><P
>    개념적으로 콜레이션 가능한 데이터 타입의 모든 표현식은 콜레이션을 갖고 있다. 
    (콜레이션 가능한 내장된 데이터 타입은 <TT
CLASS="TYPE"
>text</TT
> 및 <TT
CLASS="TYPE"
>varchar</TT
>, <TT
CLASS="TYPE"
>char</TT
>이다. 
    사용자 정의된 베이스 타입은 콜레이션 가능으로 표시될 수 있으며, 콜레이션 가능한 데이터 타입의 도메인도 콜레이션이 가능하다.) 
    표현식이 칼럼 참조인 경우 표현식의 콜레이션은 칼럼이 정의한 콜레이션이다. 표현식이 상수인 경우 콜레이션은 상수 데이터 타입의 기본 콜레이션이다. 
    좀 더 복잡한 표현식의 콜레이션은 아래 설명대로 입력 콜레이션으로부터 결정된다.
   </P
><P
>    표현식의 콜레이션은 데이터베이스에 대해 정의된 로케일(locale) 설정을 의미하는 <SPAN
CLASS="QUOTE"
>"기본"</SPAN
> 콜레이션이 될 수 있다. 
    표현식의 콜레이션을 결정되지 않은 상태로 하는 것도 가능하다. 
    이런 경우 콜레이션을 알아야 하는 정렬 명령 및 기타 명령은 실패한다.
   </P
><P
>    데이터베이스 시스템이 정렬 또는 문자 분류를 수행해야 하는 경우 입력 표현식의 콜레이션이 사용된다. 
    이것은, 예를 들면 <TT
CLASS="LITERAL"
>ORDER BY</TT
> 절 및 함수 또는  <TT
CLASS="LITERAL"
>&lt;</TT
> 같은 연산자 호출을 사용할 때 결정된다. 
    <TT
CLASS="LITERAL"
>ORDER BY</TT
> 절에 적용되는 콜레이션은 단순히 정렬 키의 콜레이션이다. 함수 또는 연산자 호출에 적용되는 콜레이션은 아래 설명된 인자로부터 결정된다. 
    비교 연산자 외에, 콜레이션은 <CODE
CLASS="FUNCTION"
>lower</CODE
> 및 <CODE
CLASS="FUNCTION"
>upper</CODE
>, <CODE
CLASS="FUNCTION"
>initcap</CODE
> 같이 대소문자 사이를 변환하는 함수와 
    그리고 패턴 일치 및 <CODE
CLASS="FUNCTION"
>to_char</CODE
>와 관련 함수를 사용할 때 결정된다.
   </P
><P
>    함수 또는 연산자 호출의 경우 인자 콜레이션 검사로 결정된 콜레이션이 작업 성능을 위해 런타임에 사용된다. 
    함수나 연산자 호출의 결과가 콜레이션 가능한 데이터 타입인 경우, 
    콜레이션에 대한 정보가 필요한 주변 표현식이 있을 때 콜레이션도 파싱 할 때의 함수 또는 연산자 표현식의 정의된 콜레이션으로 사용된다.
   </P
><P
>    표현식의 <I
CLASS="FIRSTTERM"
>콜레이션 결정</I
>은 암시적 또는 명시적일 수 있다. 
    이 차이는 서로 다른 콜레이션이 표현식에 나타나는 경우, 콜레이션이 결합되는 방식에 영향을 준다. 
    <TT
CLASS="LITERAL"
>COLLATE</TT
> 절을 사용하면 명시적 콜레이션이 결정되고, 그 외 모든 콜레이션은 암시적으로 결정된다. 
    예를 들면, 함수 호출에서 여러 콜레이션을 결합해야 하는 경우 다음과 같은 규칙이 사용된다.
    <P
></P
></P><OL
TYPE="1"
><LI
><P
>       입력 표현식이 명시적 콜레이션을 결정하는 경우 입력 표현식에서 명시적으로 결정된 모든 콜레이션은 동일해야 한다. 
       그렇지 않으면 에러가 발생한다. 명시적으로 결정된 콜레이션은 콜레이션 결합의 결과물이다.
      </P
></LI
><LI
><P
>       그 외에는, 모든 입력 표현식은 동일한 암시적 콜레이션을 결정하거나 기본 콜레이션을 사용해야 한다. 
       기본값이 아닌 콜레이션은 콜레이션 결합의 결과물이다. 그 외에는 기본 콜레이션이다.
      </P
></LI
><LI
><P
>       입력 표현식 사이에 기본이 아닌 암시적 콜레이션의 충돌이 있을 경우 결합은 불확정적인 콜레이션을 쓰는 것으로 간주된다. 
       호출하려는 특정 함수가 적용해야 할 콜레이션을 알아야 하는 경우가 아니면 이것은 에러 조건이 아니다. 
       그 외에는 런타임 시 에러가 발생된다.
      </P
></LI
></OL
><P>
예를 들어, 다음과 같은 테이블 정의를 생각해 보자.
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE test1 (
    a text COLLATE "de_DE",
    b text COLLATE "es_ES",
    ...
);</PRE
><P>
그러면,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; 'foo' FROM test1;</PRE
><P>
    이 구문에서 <TT
CLASS="LITERAL"
>&lt;</TT
> 비교는, 표현식이 명시적으로 결정된 콜레이션을 기본 콜레이션과 결합하기 때문에 <TT
CLASS="LITERAL"
>de_DE</TT
> 규칙에 따라 수행된다. 
    그러나,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; ('foo' COLLATE "fr_FR") FROM test1;</PRE
><P>
    이 구문에서는 명시적 콜레이션이 암시적 콜레이션을 오버라이드하므로 <TT
CLASS="LITERAL"
>fr_FR</TT
> 규칙으로 비교가 수행된다. 
    게다가,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; b FROM test1;</PRE
><P>
    이 구문에서는 <TT
CLASS="STRUCTFIELD"
>a</TT
> 및 <TT
CLASS="STRUCTFIELD"
>b</TT
> 칼럼의 암시적 콜레이션이 충돌하므로 어떤 콜레이션을 적용할 것인지 파서로 결정할 수 없다. 
    <TT
CLASS="LITERAL"
>&lt;</TT
> 연산자는 어떤 콜레이션을 사용할 것인지 알 필요가 없으므로, 결과적으로 에러가 발생한다. 
    암시적 콜레이션 지정자(specifier)를 입력 표현식에 추가하면 이 에러가 해결된다. 따라서,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a &lt; b COLLATE "de_DE" FROM test1;</PRE
><P>
    또는 동일하게, 다음과 같이 할 수 있다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a COLLATE "de_DE" &lt; b FROM test1;</PRE
><P>
    즉, 구조상 동일한,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a || b FROM test1;</PRE
><P>
    이 구문은 <TT
CLASS="LITERAL"
>||</TT
> 연산자가 콜레이션에 대해 무심하므로 결과적으로 에러가 발생한다. 
    이 결과는 콜레이션과 무관하게 동일하다.
   </P
><P
>    또한 함수 또는 연산자의 결합된 입력 표현식에 할당된 콜레이션은 함수 또는 연산자가 콜레이션 가능한 데이터 타입의 결과를 전달하는 경우, 
    함수 또는 연산자의 결과에 적용되는 것으로 간주된다. 
    따라서,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || 'foo';</PRE
><P>
    이 구문은 <TT
CLASS="LITERAL"
>de_DE</TT
> 규칙에 따라 정렬된다. 그러나 이 쿼리는,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || b;</PRE
><P>
    <TT
CLASS="LITERAL"
>||</TT
> 연산자는 콜레이션에 대해 알고 있을 필요가 없지만 <TT
CLASS="LITERAL"
>ORDER BY</TT
> 절은 그렇게 하므로 결과적으로 에러가 발생한다. 
    이전과 같이, 명시적 콜레이션 지정자를 사용하면 충돌을 해결할 수 있다.
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM test1 ORDER BY a || b COLLATE "fr_FR";</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN6957"
>6.2.2. 콜레이션 관리</A
></H2
><P
>    콜레이션은 SQL 이름을 운영 체제 로케일(locale)에 맵핑하는 SQL 스키마 개체이다. 
    특히, <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> 및 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> 조합에 맵핑한다. (이름이 암시하듯 콜레이션의 주요 목적은 정렬 순서를 제어하는 <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
>를 설정하는 것이다. 
    그러나, 실제로는 <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
>와 다른 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>를 갖는 것은 거의 불필요하므로 표현식별로 
    <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> 설정에 대한 다른 인프라를 생성하는 대신 한 가지 개념 하에서 이것을 수집하는 것이 더 편리하다.) 
    또한 콜레이션은 문자 집합 인코딩에 연결된다(<A
HREF="multibyte.html"
>6.3절</A
> 참조). 다른 인코딩으로 동일한 콜레이션 이름이 존재할 수도 있다.
   </P
><P
>    모든 플랫폼에서 이름이 <TT
CLASS="LITERAL"
>default</TT
> 및 <TT
CLASS="LITERAL"
>C</TT
>, <TT
CLASS="LITERAL"
>POSIX</TT
>인 콜레이션을 사용할 수 있다. 
    추가적인 콜레이션은 운영 체제 지원에 따라 사용할 수 있다. 
    <TT
CLASS="LITERAL"
>default</TT
> 콜레이션은 데이터베이스 생성 시에 지정된 <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> 및 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
> 값을 선택한다. 
    <TT
CLASS="LITERAL"
>C</TT
> 및 <TT
CLASS="LITERAL"
>POSIX</TT
> 콜레이션 둘 다 ASCII 문자 <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>A</TT
>"</SPAN
> ~ <SPAN
CLASS="QUOTE"
>"<TT
CLASS="LITERAL"
>Z</TT
>"</SPAN
>만 글자로 처리되고 
    문자 코드 바이트 값으로 엄격하게 정렬이 되는 <SPAN
CLASS="QUOTE"
>"전형적인 C"</SPAN
> 동작을 지정한다.
   </P
><P
>    운영 체제가 단일 프로그램(<CODE
CLASS="FUNCTION"
>newlocale</CODE
> 및 관련 함수) 내에서 복수의 로케일(locale)을 사용하는 지원을 제공하는 경우 데이터베이스 클러스터가 초기화되면, 
    <TT
CLASS="COMMAND"
>initdb</TT
>는 당시에 운영 체제에서 찾은 모든 로케일(locale)에 따라 콜레이션으로 시스템 카탈로그 <TT
CLASS="LITERAL"
>pg_collation</TT
>을 채운다. 
    예를 들면, 운영 체제는 <TT
CLASS="LITERAL"
>de_DE.utf8</TT
>이라는 이름의 로케일(locale)을 제공할 수도 있다. 
    그러면 <TT
CLASS="COMMAND"
>initdb</TT
>는 <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> 및 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>가 둘 다 <TT
CLASS="LITERAL"
>de_DE.utf8</TT
>로 설정된 
    <TT
CLASS="LITERAL"
>UTF8</TT
> 인코딩에 대해 <TT
CLASS="LITERAL"
>de_DE.utf8</TT
>이라는 콜레이션을 생성한다. 
    또한 이것은 이름 일부만 추려낸 <TT
CLASS="LITERAL"
>.utf8</TT
> 태그를 사용하여 콜레이션을 생성한다. 
    따라서 작성이 간편하고 인코딩에 대한 이름 의존도가 낮은 <TT
CLASS="LITERAL"
>de_DE</TT
>라는 이름으로 콜레이션을 사용할 수도 있다. 
    그래도 콜레이션 이름의 초기 설정은 플랫폼에 따라 달라진다.
   </P
><P
>    <TT
CLASS="SYMBOL"
>LC_COLLATE</TT
> 및 <TT
CLASS="SYMBOL"
>LC_CTYPE</TT
>에 대한 값이 서로 다른 콜레이션이 필요한 경우 
    CREATE COLLATION 명령을 사용하여 새로운 콜레이션을 생성할 수도 있다. 
    또한 해당 명령으로 기존 콜레이션에서 새 콜레이션을 생성할 수도 있으며, 이것은 애플리케이션에서 운영 체제로부터 독립된 콜레이션 이름을 사용할 때 유용하다.
   </P
><P
>    특정한 데이터베이스 내에서 데이터베이스의 인코딩을 사용하는 콜레이션만 중요하다. 
    <TT
CLASS="LITERAL"
>pg_collation</TT
>의 다른 항목은 무시된다. 
    따라서 <TT
CLASS="LITERAL"
>de_DE</TT
> 같이 일부만 추려낸 콜레이션 이름은 전역적으로는 고유하지 않더라도 지정된 데이터베이스 내에서는 고유한 것으로 간주될 수 있다. 
    데이터베이스 인코딩을 다른 것으로 변경하기로 결정한 경우 변경 사항이 적은 추려낸 콜레이션 이름을 사용하는 것이 권장한다. 
    그러나 <TT
CLASS="LITERAL"
>default</TT
> 및 <TT
CLASS="LITERAL"
>C</TT
>, <TT
CLASS="LITERAL"
>POSIX</TT
> 콜레이션은 데이터베이스 인코딩과 무관하게 사용할 수 있다.
   </P
><P
>    <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>은 속성이 동일한 경우에도 별개의 콜레이션 개체는 호환되지 않는 것으로 간주한다. 
    따라서 예를 들면,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT a COLLATE "C" &lt; b COLLATE "POSIX" FROM test1;</PRE
><P>
    이 구문은 <TT
CLASS="LITERAL"
>C</TT
> 및 <TT
CLASS="LITERAL"
>POSIX</TT
> 콜레이션의 동작이 동일하더라도 에러가 발생된다. 
    따라서 추려낸 콜레이션 이름과 추려내지 않은 콜레이션 이름의 혼용은 권장하지 않는다.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="locale.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="multibyte.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>로케일(Locale) 지원</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="charset.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>문자 집합 지원</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>