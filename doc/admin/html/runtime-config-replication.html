<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>복제</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="서버 환경 설정"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Write Ahead 로그"
HREF="runtime-config-wal.html"><LINK
REL="NEXT"
TITLE="쿼리 플랜"
HREF="runtime-config-query.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-26T04:43:18"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Write Ahead 로그"
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 2. 서버 환경 설정</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="쿼리 플랜"
HREF="runtime-config-query.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-REPLICATION"
>2.6. 복제</A
></H1
><P
> 이 설정은 내장 <I
CLASS="FIRSTTERM"
>streaming replication</I
> 기능의 동작을 제어한다(<A
HREF="warm-standby.html#STREAMING-REPLICATION"
>9.2.5절</A
> 참조). 서버는 마스터 서버거나 대기 서버다. 
 마스터 서버는 데이터를 전송할 수 있고, 대기 서버는 언제나 복제된 데이터의 수신자이다. cascading replication(<A
HREF="warm-standby.html#CASCADING-REPLICATION"
>9.2.7절</A
> 참조)을 사용하는 경우 대기 서버는 수신자 겸 전송자일 수 있다. 
 매개변수는 주로 전송 및 대기 서버에 대한 것이며, 일부 매개변수는 마스터 서버에서만 의미가 있다. 클러스터 간에 설정은 필요 시 별 문제 없이 다르게 할 수 있다.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-SENDER"
>2.6.1. 전송 서버(들)</A
></H2
><P
>이 매개변수는 복제 데이터를 하나 이상의 대기 서버로 전송하는 서버에 설정할 수 있다. 마스터는 항상 전송 서버 이므로 이 매개변수를 언제나 마스터에 설정해야 한다. 
이 매개변수의 역할 및 의미는 대기 서버가 마스터로 된 이후에 변경되지 않는다.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-WAL-SENDERS"
></A
><TT
CLASS="VARNAME"
>max_wal_senders</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
>대기 서버 또는 스트리밍 베이스 백업 클라이언트로부터의 동시 연결 최대 수를 지정한다(예: 동시에 실행 중인 WAL 전송자 프로세스의 최대 수). 
기본값은, 복제를 비활성화하는 0이다. WAL 전송자 프로세스는 총 연결 수에 포함되므로 매개변수를 <A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>보다 큰 값으로 설정할 수 없다. 
스트리밍 클라이언트의 연결이 갑작스럽게 끊어지면 타임아웃이 될 때까지 고아 연결 슬롯이 생기므로, 예상되는 클라이언트의 최대 수보다 이 매개변수를 약간 더 크게 설정하여 연결이 끊어진 클라이언트가 즉시 재연결될 수 있도록 해야 한다. 
이 매개변수는 서버 시작 시에만 설정 가능하다. 대기 서버로부터의 연결이 가능하도록 <TT
CLASS="VARNAME"
>wal_level</TT
>은 <TT
CLASS="LITERAL"
>archive</TT
>와 같거나 크게 설정해야 한다.
 </P
></DD
><DT
><A
NAME="GUC-MAX-REPLICATION-SLOTS"
></A
><TT
CLASS="VARNAME"
>max_replication_slots</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
> 서버가 지원할 수 있는 복제 슬롯의 최대 수를 지정한다(<A
HREF="warm-standby.html#STREAMING-REPLICATION-SLOTS"
>9.2.6절</A
> 참조). 기본값은 0이다. 이 매개변수는 서버 시작 시에만 설정 가능하다. 
 복제 슬롯의 사용이 가능하도록 <TT
CLASS="VARNAME"
>wal_level</TT
>은 <TT
CLASS="LITERAL"
>archive</TT
>와 같거나 크게 설정해야 한다. 현재 존재하는 복제 슬롯 수보다 작은 값으로 설정하면 서버가 시작되지 않는다.</P
></DD
><DT
><A
NAME="GUC-WAL-KEEP-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>wal_keep_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
 </DT
><DD
><P
>대기 서버가 streaming replication을 위해 과거 로그 파일을 가져와야 하는 경우 <TT
CLASS="FILENAME"
>pg_xlog</TT
> 디렉토리에 저장되는 과거 로그 파일 세그먼트의 최소 수를 지정한다. 
각 세그먼트는 보통 16메가바이트이다. 전송 서버에 연결된 대기 서버가 <TT
CLASS="VARNAME"
>wal_keep_segments</TT
> 세그먼트에 휠씬 못 미치면 전송 서버는 대기 서버에 의해 필요한 만큼 WAL 세그먼트를 삭제하고, 이때 복제 연결이 중단된다. 
다운스트림 연결도 결과적으로 실패한다. (단, 대기 서버는 WAL 아카이빙이 사용 중인 경우 아카이브에서 세그먼트를 가져와서 복구할 수 있다.)
 </P
><P
>이것은, <TT
CLASS="FILENAME"
>pg_xlog</TT
>에 저장되는 최소 세그먼트 수만 지정한다. 시스템은 WAL 아카이브용으로 또는 checkpoint에서 복구용으로 세그먼트를 좀 더 보유해야 할 수 있다. 
<TT
CLASS="VARNAME"
>wal_keep_segments</TT
>가 0(기본값)인 경우 시스템은 대기 서버를 위한 추가 세그먼트를 유지하지 않으므로, 대기 서버에서 사용 가능한 예전 WAL 세그먼트의 수는 이전 checkpoint의 위치 및 WAL 아카이빙의 상태 함수이다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-SENDER-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>wal_sender_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>지정된 밀리초 이상 작동되지 않은 복제 연결이 중단된다. 이것은 전송 서버가 대기 서버 충돌 또는 네트워크 중단을 검출할 때 유용하다. 0 값은 시스템 타임아웃 메커니즘을 비활성화한다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 기본값은 60초이다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-MASTER"
>2.6.2. 마스터 서버</A
></H2
><P
>이 매개변수는 복제 데이터를 하나 이상의 대기 서버로 전송하는 마스터/운영 서버에 설정할 수 있다. 
이 매개변수 외에, <A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
>은 마스터 서버에 적절하게 설정되어야 하고 옵션으로 WAL 아카이빙도 활성화될 수 있다(<A
HREF="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING"
>2.5.3절</A
> 참조). 
사용자가 대기 서버가 마스터가 될 가능성에 대비하여 이 매개변수를 설정하고 싶어 하더라도 대기 서버의 이 매개변수 값은 아무 상관이 없다.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SYNCHRONOUS-STANDBY-NAMES"
></A
><TT
CLASS="VARNAME"
>synchronous_standby_names</TT
> (<TT
CLASS="TYPE"
>string</TT
>)&#13;</DT
><DD
><P
><A
HREF="warm-standby.html#SYNCHRONOUS-REPLICATION"
>9.2.8절</A
>에 설명된 대로 <I
CLASS="FIRSTTERM"
>동기 복제</I
>를 지원할 수 있는 대기 서버 이름을 쉼표로 구분된 목록으로 지정한다. 작동 중인 동기 대기 서버는 한 번에 많아야 하나이다. 
커밋 대기 중인 트랜잭션은 이 대기 서버가 데이터 수신을 확인한 후에 진행이 허용된다. 
동기 대기 서버는 이 목록 중에서 현재 연결되어 있고 실시간으로 데이터를 스트리밍하는 첫 번째 대기 서버다(<A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
><TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
> 뷰에서 <TT
CLASS="LITERAL"
>streaming</TT
> 상태로 표시됨). 
이 목록에서 나중에 나타난 다른 대기 서버는 잠재적 동기 대기 서버를 나타낸다. 현재 동기 대기 서버가 어떤 이유로든 연결이 끊어진 경우 우선 순위가 그 다음으로 높은 대기 서버로 즉시 대체된다.
대기 서버 이름을 2개 이상 지정하면 매우 높은 고가용성을 달성할 수 있다.
 </P
><P
>대기 서버의 WAL 수신자의 <TT
CLASS="VARNAME"
>primary_conninfo</TT
>에 설정된 대로 이런 용도의 대기 서버 이름은 대기 서버의 <TT
CLASS="VARNAME"
>application_name</TT
> 설정이다. 고유성을 적용하는 메커니즘은 없다. 
복제의 경우, 일치하는 대기 서버 중 하나는 정확히 어떤 것인지 가늠하기 어렵지만 동기 대기 서버가 되도록 선택된다. 특수 항목 <TT
CLASS="LITERAL"
>*</TT
>는 <TT
CLASS="LITERAL"
>walreceiver</TT
>의 기본 애플리케이션 이름을 비롯한 모든 <TT
CLASS="VARNAME"
>application_name</TT
>과 일치한다.
 </P
><P
>동기 대기 서버 이름이 여기서 지정되지 않으면 동기 복제는 활성화되지 않고 트랜잭션 커밋은 복제를 기다리지 않는다. 이것은 기본 환경 설정이다. 
동기 복제가 활성화되더라도 개별 트랜잭션은 <A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
> 매개변수를 <TT
CLASS="LITERAL"
>local</TT
> 또는 <TT
CLASS="LITERAL"
>off</TT
>로 설정함으로써 복제를 기다리지 않도록 환경 설정할 수 있다.
 </P
><P
>이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
></DD
><DT
><A
NAME="GUC-VACUUM-DEFER-CLEANUP-AGE"
></A
><TT
CLASS="VARNAME"
>vacuum_defer_cleanup_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
><TT
CLASS="COMMAND"
>VACUUM</TT
> 및 <ACRONYM
CLASS="ACRONYM"
>HOT</ACRONYM
> 업데이트가 데드 로우(dead row) 버전의 클린업을 연기하기 되는 트랜잭션 수를 지정한다. 기본값은 0개 트랜잭션이다. 
이것은 데드 로우(dead row) 버전이 열린 트랜잭션에서 더 이상 보이지 않는 즉시, 가능한 한 빨리 제거될 수 있다는 것을 의미한다. 
사용자는 <A
HREF="hot-standby.html"
>9.5절</A
>에 설명된 대로 핫 스탠바이가 지원하는 운영 서버에서 이 값을 0이 아닌 다른 값으로 설정하고 싶을 수도 있다. 
이것은 행의 조기 클린업에 의한 충돌 없이 대기 서버에서 쿼리가 완료되는 시간적 여유를 허용한다. 
그러나, 운영 서버에서 발생한 쓰기 트랜잭션 수에 관해서 값이 평가되므로, 대기 서버 쿼리에 대해 얼마만큼의 유예 시간이 가능한지를 예측하기는 어렵다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
>대체 서버로서 대기 서버의 <TT
CLASS="VARNAME"
>hot_standby_feedback</TT
>을 이 매개변수의 사용으로 설정하는 것도 고려해야 한다.
 </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-STANDBY"
>2.6.3. 대기 서버</A
></H2
><P
>이 설정은 복제 데이터를 수신하는 대기 서버의 동작을 제어한다. 마스터 서버의 값은 무관하다.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-HOT-STANDBY"
></A
><TT
CLASS="VARNAME"
>hot_standby</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
><A
HREF="hot-standby.html"
>9.5절</A
>에 설명된 대로 복구 중에 사용자가 쿼리를 연결하고 실행할 수 있는지를 지정한다. 기본값은 <TT
CLASS="LITERAL"
>off</TT
>이다. 이 매개변수는 서버 시작 시에만 설정 가능하다. 
복구 중 또는 대기 서버 모드에서만 효과가 있다.
 </P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-ARCHIVE-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>핫 스탠바이가 작동 중이면 <A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>9.5.2절</A
>에서 설명된 대로 이 매개변수는 적용 직전의 WAL 항목과 충돌하는 대기 서버 쿼리를 취소하기 전에 대기 서버가 기다려야 하는 시간을 결정한다. 
WAL 데이터를 WAL 아카이브에서 읽어오는 경우(따라서 현재가 아닌 경우) <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
>가 적용된다. 기본값은 30초이다. 
지정되지 않으면 단위는 밀리초이다. -1 값은 쿼리 충돌이 완료될 때까지 대기 서버가 무한정 대기하도록 허용한다. 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
>취소 전 쿼리를 실행할 수 있는 시간 길이와 <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
>는 동일하지 않는 점에 유의해야 한다. 오히려 이것은 WAL 세그먼트의 데이터를 적용하는 것이 허용된 최대 총 시간이다. 
따라서 WAL 세그먼트 초반에 어떤 쿼리 때문에 상당한 지연이 발생한 경우 후속 충돌 쿼리는 유예 시간이 훨씬 짧아진다.
 </P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-STREAMING-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>핫 스탠바이가 작동 중이면 <A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>9.5.2절</A
>에서 설명된 대로 이 매개변수는 적용 직전의 WAL 항목과 충돌하는 대기 서버 쿼리를 취소하기 전에 대기 서버가 기다려야 하는 시간을 결정한다. 
WAL 데이터를 스트리밍 복제를 통해 수신하는 경우 <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>가 적용된다. 기본값은 30초이다. 지정되지 않으면 단위는 밀리초이다. -1 값은 쿼리 충돌이 완료될 때까지 대기 서버가 무한정 대기하도록 허용한다. 
이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
>취소 전 쿼리를 실행할 수 있는 시간 길이와 <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>는 동일하지 않은 점에 유의해야 한다. 오히려 이것은 운영 서버로부터 수신했던 WAL데이터를 적용하는 것이 허용된 최대 총 시간이다. 
따라서 어떤 쿼리 때문에 상당한 지연이 발생한 경우 후속 충돌 쿼리는 대기 서버가 다시 따라잡을 때까지 유예 시간이 훨씬 짧아진다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-RECEIVER-STATUS-INTERVAL"
></A
><TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
> 대기 서버의 WAL 수신자 프로세스가 복제 프로세스에 대한 정보를 운영 서버 또는 업스트림 스탠바이로 전송하는 최소 빈도를 지정한다. 이것은 <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
> <TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
> 뷰를 사용하여 볼 수 있다. 
 대기 서버는 작성된 마지막 트랜잭션 로그 위치, 디스크에 기록한 마지막 위치 및 적용된 마지막 위치를 알려 준다. 이 매개변수의 값은 리포트 지점간 초 단위의 최대 간격이다. 
 업데이트는 쓰기 또는 플러시(flush) 위치가 변경될 때마다 전송되거나 최소한 이 매개변수가 지정한 빈도로 전송된다. 따라서 적용 위치는 실제 위치보다 약간 뒤처질 수 있다. 
 이 매개변수를 0으로 설정하면 상태 업데이트가 완전히 비활성화된다. 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 기본값은 10초이다.</P
></DD
><DT
><A
NAME="GUC-HOT-STANDBY-FEEDBACK"
></A
><TT
CLASS="VARNAME"
>hot_standby_feedback</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)&#13;</DT
><DD
><P
>핫 스탠바이가 대기 서버에서 현재 실행 중인 쿼리에 대해 운영 서버 또는 업스트림 스탠바이로 피드백을 전송할 것인지를 지정한다. 
이 매개변수는 클린업 레코드에 의해 야기된 쿼리 취소를 없애는 데 사용할 수 있지만 일부 작업 부하의 경우 운영 서버에서 데이터베이스 팽창을 초래할 수 있다. 
피드백 메시지는 <TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
>당 한 번 이상 전송되지 않는다. 기본값은 <TT
CLASS="LITERAL"
>off</TT
>이다. 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다.
 </P
><P
>케스케이드형 복제를 사용 중인 경우 운영 서버에 도달할 때까지 피드백이 상류로 전달된다. 상류 전달 외에, 대기 서버는 수신하는 피드백을 다른 용도로 사용하지 않는다.
 </P
></DD
><DT
><A
NAME="GUC-WAL-RECEIVER-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>wal_receiver_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)&#13;</DT
><DD
><P
>지정된 밀리초 이상 작동되지 않은 복제 연결이 중단된다. 이것은 대기 서버가 프라이머리 노드 충돌 또는 네트워크 중단을 검출할 때 유용하다. 
0 값은 시스템 타임아웃 메커니즘을 비활성화한다. 이 매개변수는 <TT
CLASS="FILENAME"
>postgresql.conf</TT
> 파일 또는 서버 커맨드 라인에서만 설정 가능하다. 기본값은 60초이다.
 </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-query.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Write Ahead 로그</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>쿼리 플랜</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>