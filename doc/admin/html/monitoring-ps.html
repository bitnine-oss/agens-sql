<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>표준 유닉스 도구들</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Agens SQL 1.0 문서"
HREF="index.html"><LINK
REL="UP"
TITLE="데이터베이스 성능 모니터링"
HREF="monitoring.html"><LINK
REL="PREVIOUS"
TITLE="데이터베이스 성능 모니터링"
HREF="monitoring.html"><LINK
REL="NEXT"
TITLE="통계 수집기"
HREF="monitoring-stats.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=UTF-8"><META
name="viewport"
content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width"><META
NAME="creation"
CONTENT="2015-06-26T04:43:18"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Agens SQL 1.0 문서</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="데이터베이스 성능 모니터링"
HREF="monitoring.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>장 11. 데이터베이스 성능 모니터링</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="통계 수집기"
HREF="monitoring-stats.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="MONITORING-PS"
>11.1. 표준 유닉스 도구들</A
></H1
><P
>   대부분의 유닉스 환경에서는 <SPAN
CLASS="PRODUCTNAME"
>Agens SQL</SPAN
>
   서버의 동작 상태를 <TT
CLASS="COMMAND"
>ps</TT
> 쉘 명령어만으로도 대략적으로
   살펴 볼 수 있다. 왜냐하면 서버는 자신의 각
   하위 프로세스들의 명령어 이름들을 동적으로 바꾸어서 운영체제가 
   그것을 볼 수 있도록 하기 때문이다. 그래서 다음과 같은 간단한 
   명령어로 서버 상태를 살펴 볼 수 있다:

</P><PRE
CLASS="SCREEN"
>$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction</PRE
><P>

   (이 명령은 여러 유닉스 제각각이다. 윗 예제는 요즘 사용하는 리눅스 
   시스템에서 사용하는 명령어다. <TT
CLASS="COMMAND"
>ps</TT
> 명령의 옵션에 대한
   자세한 설명은 사용하고 있는 유닉스 운영체제 설명서를 
   설펴보는 것이 좋다.)
   윗 예제 출력 결과의 첫번째 줄은 데이터베이스 서버의 
   최상위 프로세스이며, 서버를 실행 할 때 사용했던 옵션들도 
   함께 보인다. (Agens SQL 서버는 쓰레드 방식이 아니라, 
   다중 프로세스 방식으로 운영된다.  다중 프로세스 방식이란 
   서버 관리자가 서버 실행 명령어를 OS 쉘에서 실행하면 
   서버 최상위 프로세스 실행되고 그 프로세스를 필요한 
   여러 프로세스를 실행하는 방식이다. )
   다음 다섯 줄은 이 최상위 프로세스가 실행한 서버 운영에 필요한 
   하위 프로세스들이다.  이것을 서버 백그라운드 프로세스라고 한다.
   이 프로세스들은 윗 예제와 꼭 같지는 않다. 
   <SPAN
CLASS="QUOTE"
>"autovacuum launcher"</SPAN
> 프로세스는 autovacuum 기능을 
   사용하지 않으면 보이지 않을 것이며, 
   서버 로그를 stderr 쪽으로 보내지 않고 따로 보관하는 
   기능을 사용하면, <SPAN
CLASS="QUOTE"
>"postgres: logger process"</SPAN
>
   같은 프로세스도 보일 것이다.
   나머지는 클라이언트가 접속해서 서버측에서 만든 
   세션 프로세스들이다. 이 세션 프로세스들은 
   다음과 같은 양식으로 보여준다.

</P><PRE
CLASS="SCREEN"
>postgres: <TT
CLASS="REPLACEABLE"
><I
>사용자</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>데이터베이스</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>호스트</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>현재작업상태</I
></TT
></PRE
><P>

  사용자, 데이터베이스, (클라이언트) 호스트 정보는 
  그 프로세스가 종료 될 때까지 항상 같지만 
  현재 작업 상태 정보는 그 세션의 작업 상태에 따라 
  바뀐다. 
  현재 작업 상태에 <TT
CLASS="LITERAL"
>idle</TT
>은 
  이 세션이 클라이언트의 명령을 대기하고 있음을 뜻한다.
  <TT
CLASS="LITERAL"
>idle in transaction</TT
>으로 표시되는 것은 
  그 세션이 현재 <TT
CLASS="COMMAND"
>BEGIN</TT
> 명령을 사용해서 
  트랜잭션 영역 안에 있지만 클라이언트 측에서 
  아무 작업도 안하고 있는 상태이다.
  <TT
CLASS="LITERAL"
>SELECT</TT
>와 같이 명령어 종류를 보여 주는 경우도 있고, 
  그 뒤에 <TT
CLASS="LITERAL"
>waiting</TT
>이 붙어 있는 경우도 있다. 
  이 경우는 다른 프로세스가 어떤 작업을 하고 있어 
  이 세션이 해당 작업을 대기하고 있는 상태를 나타낸다.
  윗 예제를 보면 15610 프로세스 때문에 
  15606 프로세스가 작업을 대기하고 있음을 알 수 있다. 
  (윗 예제 화면에서는 다른 세션들이 없기 때문에 
  15610 프로세스가 잠금 문제를 일으킨 프로세스로 
  파악 할 수 있다.  어떤 잠금을 사용하고 있기에 
  다른 프로세스가 기다리고 있는지에 대한 자세한 정보는
  <TT
CLASS="STRUCTNAME"
>pg_locks</TT
>
  뷰를 통해서 알 수 있다.)
  </P
><P
>   update-process-title 환경 설정값을 
   off로 지정했을 때 프로세스 현재작업상태 자리에는
   그 프로세스의 첫 작업에 대한 이름으로 지정되면 
   그 프로세스가 종료될 때까지 그대로 유지된다.
   일부 OS에서는 이 프로세스 이름을 바꾸는 작업이 부하를 유발한다고
   사용하지 않는 경우도 있고, 또 일부 OS에서는 
   이 작업에 대해서 전혀 신경 쓰지 않는 경우도 있다.
  </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>작은 정보: </B
>  <SPAN
CLASS="PRODUCTNAME"
>Solaris</SPAN
>에서는 
  이 부분 처리가 독특하다. 
  먼저 <TT
CLASS="COMMAND"
>/bin/ps</TT
> 명령 대신에 
  <TT
CLASS="COMMAND"
>/usr/ucb/ps</TT
> 사용하고 
  <TT
CLASS="OPTION"
>w</TT
> 옵션을 두 개 지정하고 
  서버 시작 최상위 프로세스의 이름이 
  각 세션 프로세스의 이름보다 짧게 지정하면 
  세션 프로세스들의 이름이 동적으로 바뀌는 것을 살펴볼 수 있다.
  하지만 이 세가지 조건 중 하나라도 만족하지 않으면 
  모든 프로세스 이름은 서버 최상위 프로세스의 이름과 같게 보인다.
  </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="P"
>이전</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>처음으로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="monitoring-stats.html"
ACCESSKEY="N"
>다음</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>데이터베이스 성능 모니터링</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>위로</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>통계 수집기</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>