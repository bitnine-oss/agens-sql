<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
<title>서버 설정 및 운용</title>
	
<para>
	  이 장에서는 데이터베이스 서버를 설정하고 실행하는 방법과 운영 체제와 상호 작용하는 방법에 대해 다룬다.
</para>
	
<sect1 id="agens-user">
<title><productname>Agens SQL</productname> 사용자 계정</title>
	
<indexterm>
<primary>agens 사용자</primary>
</indexterm>
	
<para>
	   외부에서 액세스 가능한 서버 데몬과 마찬가지로 <productname>Agens SQL</productname>도 별도의 사용자 계정으로 실행하는 것이 좋다. 이 사용자 계정은 서버에서 관리되는 데이터만 소유해야 하며, 다른 데몬과 공유해서는 안 된다. (예를 들면, 사용자 <literal>nobody</literal>를 사용하는 것은 바람직하지 않음.) 그럴 경우 손상된 시스템이 자체 바이너리를 변경할 수 있으므로 이 사용자가 소유한 실행 파일을 실행하는 것은 권장되지 않는다.
</para>
	
<para>
	   Unix 사용자 계정을 시스템에 추가하려면 
<command>useradd</command> 또는 <command>adduser</command> 명령을 찾아본다. 이 설명서에 빈번하게 등장하는 사용자 이름 <systemitem>agens</systemitem>는 설정된 것으로, 원하는 다른 이름을 대신 사용할 수 있다.
</para>
</sect1>
	
<sect1 id="creating-cluster">
<title>데이터베이스 클러스터 생성</title>
<indexterm>
<primary>데이터베이스 클러스터</primary>
</indexterm>
	
	  <indexterm>
	   <primary>데이터 영역</primary>
	   <see>데이터베이스 클러스터</see>
	  </indexterm>
	
	  <para>
	   작업을 하기 전에 디스크의 데이터베이스 저장소 영역을 초기화해야 한다. 이것을 <firstterm>데이터베이스 클러스터</firstterm>라고 한다.
	   (<acronym>SQL</acronym>에서는 카탈로그 클러스터라고 함.) 데이터베이스 클러스터는 실행 중인 데이터베이스 서버의 단일 인스턴스에 의해 관리되는 데이터베이스 컬렉션이다. 초기화 후 데이터베이스 클러스터에는 일명  <literal>agens</literal>라는 데이터베이스가 포함되는데, 이것은 유틸리티, 사용자 및 타사 어플리케이션이 사용하는 기본 데이터베이스이다. 데이터베이스 서버 자체는 <literal>agens</literal> 데이터베이스가 불필요하지만,  다수의 외부 유틸리티 프로그램은 이 데이터베이스가 존재한다는 것을 전제로 한다. 초기화 중에 각 클러스터 내에 생성되는 또 다른 데이터베이스는 <literal>template1</literal>이라고 한다. 이름에서 알 수 있듯이, 이것은 이후에 생성된 데이터베이스의 템플릿으로 사용되며, 실제 작업에 사용해서는 안 된다. (클러스터 내에서 데이터베이스로 새로 생성하는 방법은 <xref linkend="managing-databases"> 참조.)
	  </para>
	
	  <para>
	   파일 시스템의 관점에서, 데이터베이스 클러스터는 모든 데이터가 저장되는 단일 디렉토리이다. 
	이것을 <firstterm>데이터 디렉토리</firstterm> 또는 <firstterm>데이터 영역</firstterm>이라고 한다. 데이터를 어디에 저장할 것인지는 전적으로 사용자의 선택에 달려 있다. <filename>/usr/local/pgsql/data</filename> 또는 <filename>/var/lib/pgsql/data</filename>가 일반적이지만, 필수는 아니다.데이터베이스 클러스터를 초기화하려면 <productname>Agens SQL</productname>과 함께 설치된 <indexterm><primary>initdb</></> 명령을 사용한다.
	   데이터베이스 클러스터의 원하는 파일 시스템 위치는 
	   <option>-D</option> 옵션으로 나타낼 수 있다. 예를 들면:
	<screen>
	<prompt>$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
	</screen>
	   앞에서 설명한 대로 <productname>Agens SQL</productname> 사용자 계정으로 로그인한 상태에서 이 명령을 실행해야 한다.
	  </para>
	
	  <tip>
	   <para>
	    As an alternative to the <option>-D</option> 옵션 대신 환경 변수 <envar>PGDATA</envar>를 설정할 수 있다.
	    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
	   </para>
	  </tip>
	
	  <para>
	   또는, 다음과 같이 <indexterm><primary>pg_ctl</></> 프로그램으로 <command>initdb</command>를 실행할 수 있다.
	<screen>
	<prompt>$</> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
	</screen>
	   좀 더 직관적으로, 서버를 시작하고 중지하는 데 <command>pg_ctl</command>을 사용하면(<xref linkend="server-start">참조), <command>pg_ctl</command>은 데이터베이스 서버 인스턴스를 관리하는 유일한 명령이 된다.
	  </para>
	
	  <para>
	   <command>initdb</command>는 지정한 디렉토리가 존재하지 않는 경우에 디렉토리를 생성한다. 디렉토리를 생성하는 권한은 없을 가능성이 높다(당사 조언을 따랐고 권한이 없는 계정을 만든 경우). 그럴 경우 root 권한으로 디렉토리를 직접 생성하고 소유자를 <productname>Agens SQL</productname> 사용자로 변경해야 한다. 다음과 같이 할 수 있다.
	<screen>
	<prompt>root#</> <userinput>mkdir /usr/local/pgsql/data</userinput>
	<prompt>root#</> <userinput>chown agens /usr/local/pgsql/data</userinput>
	<prompt>root#</> <userinput>su agens</userinput>
	<prompt>agens$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
	</screen>
	  </para>
	
	  <para>
	   <command>initdb</command>는 데이터 디렉토리가 초기화된 것으로 보일 경우 실행을 거부한다.</para>
	
	  <para>
	   데이터 디렉토리에는 데이터베이스의 모든 데이터가 저장되어 있으므로 무단 액세스로부터 데이터 디렉토리를 보호하는 것이 중요하기 때문에 <command>initdb</command>는 <productname>Agens SQL</productname> 사용자를 제외한 모든 사용자로부터 접근 권한을 해지한다.
	  </para>
	
	  <para>
	   단, 디렉토리 내용이 보호 중인 경우 기본 클라이언트 인증 설정은 로컬 사용자의 데이터베이스 연결을 허용하고 로컬 사용자가 데이터베이스 수퍼유저가 되는 것을 허용하기도 한다. 다른 로컬 사용자를 신뢰하지 않을 경우에는 <command>initdb</command>의 <option>-W</option>, <option>--pwprompt</option> 또는 <option>--pwfile</option> 옵션 중 하나를 사용하여 데이터베이스 수퍼유저에게 패스워드를 할당하는 것이 좋다.
	   <indexterm>
	     <primary>패스워드</>
	     <secondary>슈퍼유저의</>
	   </indexterm>
	   또한 <option>-A md5</> 또는
	   <option>-A password</>를 지정하여 기본 <literal>trust</> 인증 모드가 사용되지 않게 하거나, 서버를 처음으로 시작하기 <emphasis>전에</> <command>initdb</command>를 실행한 후 생성된 <filename>pg_hba.conf</filename> 파일을 수정해야 한다. (기타 합리적 접근법에는 <literal>peer</literal> 인증 또는 파일 시스템 권한을 사용하여 연결을 제한하는 것이 있다. 자세한 내용은 <xref
	   linkend="client-authentication"> 참조.)
	  </para>
	
	  <para>
	   <command>initdb</command>에서 데이터베이스 클러스터의 기본 로케일(<indexterm><primary>locale</></>)을 초기화할 수도 있다. 일반적으로는 환경의 로케일(locale) 설정을 가져와서, 이것을 초기화된 데이터베이스에 적용한다. 데이터베이스에 서로 다른 로케일(locale)을 지정할 수 있다. 자세한 내용은 <xref linkend="locale">에 나와 있다. 특정 데이터베이스 클러스터 내에서 사용되는 기본 정렬 순서는 
	   <command>initdb</command>로 설정되며, 서로 다른 정렬 순서로 새로운 데이터베이스를 생성하는 경우 initdb로 생성된 템플릿 데이터베이스에 사용되는 정렬 순서는 삭제 및 재생성하지 않고는 변경할 수 없다.  <literal>C</> 또는 <literal>POSIX</> 이외의 로케일(locale)을 사용하는 경우 성능에도 영향을 미칠 수 있다. 따라서 처음부터 올바른 선택을 하는 것이 중요하다.
	  </para>
	
	  <para>
	   <command>initdb</command>로 데이터베이스 클러스터용 기본 문자 집합 인코딩도 설정한다. 일반적으로, 이것은 로케일(locale) 설정과 동일하게 선택해야 한다. 자세한 내용은 <xref linkend="multibyte"> 참조.
	  </para>
	
	  <sect2 id="creating-cluster-nfs">
	   <title>네트워크 파일 시스템</title>
	
	   <indexterm zone="creating-cluster-nfs">
	    <primary>네트워크 파일 시스템</primary>
	   </indexterm>
	   <indexterm><primary><acronym>NFS</></><see>네트워크 파일 시스템</></>
	   <indexterm><primary>Network Attached Storage (<acronym>NAS</>)</><see>네트워크 파일 시스템</></>
	
	   <para>
	    여러 가지 설치로 네트워크 파일 시스템에 데이터베이스 클러스터가 만들어지는데, <acronym>NFS</>를 통해 직접 생성되거나, 내부적으로 <acronym>NFS</>를 사용하는 <acronym>NAS</>(Network Attached Storage) 장치로 생성되기도 한다. <productname>Agens SQL</>이 <acronym>NFS</>파일 시스템에 특별한 무언가를 하는 것은 아니며, <acronym>NFS</>가 정확히 로컬로 연결된 드라이브
	    (<acronym>DAS</>, Direct Attached Storage)처럼 동작한다. 클라이언트 및 서버 
	    <acronym>NFS</> 구현에 비표준 의미 체계가 있을 경우 안정성에 문제가 된다(<ulink
	    url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink> 참조).
	    특히, <acronym>NFS</>서버에 대한 쓰기 지연(비동기)은 안정성 문제의 원인이 되므로, 이러한 문제를 피하려면 가능한 한 <acronym>NFS</> 파일 시스템을 캐시 없이 동기적으로 마운트해야 한다. 또한 <acronym>NFS</>의 소프트 마운트는 권장되지 않는다.
	    (<acronym>SAN</>(Storage Area Networks)은 <acronym>NFS</>가 아닌 저수준 통신 프로토콜을 사용한다.)
	   </para>
	
	  </sect2>
	
	 </sect1>
	
	 <sect1 id="server-start">
	  <title>데이터베이스 서버 시작</title>
	
	  <para>
	   데이터베이스에 액세스하기 전에 데이터베이스 서버를 시작해야 한다. 데이터베이스 서버 프로그램을 
	   <command>agens</command>라고 한다. <indexterm><primary>agens</></>
	   <command>agens</command>프로그램은 사용하려는 데이터가 어디에 있는지 알고 있어야 한다. 이것은 
	   <option>-D</option> 옵션으로 가능하다. 따라서 서버를 시작하는 가장 손쉬운 방법은 다음과 같이 하는 것이다.
	<screen>
	<prompt>$</> <userinput>agens -D /usr/local/pgsql/data</userinput>
	</screen>
	   이렇게 하면 서버가 포그라운드에서 실행된다. 이것은 <productname>Agens SQL</productname> 사용자 계정으로 로그인한 상태에서 해야 한다. <option>-D</option>가 없으면 이름이 환경 변수 <envar>PGDATA</envar>인 데이터 디렉토리를 서버가 사용하려고 한다. 해당 변수가 제공되지 않으면 실패하게 된다.
	  </para>
	
	  <para>
	   보통은 백그라운드에서 <command>agens</command>를 시작하는 것이 좋다. 이것의 경우 일반적인 Unix 쉘 구문을 사용한다.
	<screen>
	<prompt>$</> <userinput>agens -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
	</screen>
	   위와 같이 서버의 <systemitem>stdout</> 및
	   <systemitem>stderr</> 출력을 어딘가에 저장해 놓는 것이 중요하다. 그러면 감사 및 문제 진단 시 도움이 된다. (로그 파일 처리에 대한 자세한 내용은 <xref
	   linkend="logfile-maintenance"> 참조)
	  </para>
	
	  <para>
	   <command>agens</command> 프로그램에는 다른 명령줄 옵션도 많이 있다. 자세한 내용은 
	   agens 참조 페이지 및 아래의 runtime-config 을 참조 바란다.
	  </para>
	
	  <para>
	   쉘 구문은 지루하고 따분하다. 따라서 일부 작업을 단순화할 수 있는 래퍼 프로그램 
	   <indexterm><primary>pg_ctl</primary></indexterm>이 제공된다. 예:
	<programlisting>
	pg_ctl start -l logfile
	</programlisting>
	   이것은 서버를 백그라운드에서 시작하고 출력을 지명된 로그 파일로 출력한다. <option>-D</option> 옵션은 <command>agens</command>에서 사용된 것과 의미가 동일하다. <command>pg_ctl</command>으로도 서버를 중지할 수 있다.
	  </para>
	
	  <para>
	   보통은, 컴퓨터 부팅 시 데이터베이스 서버도 시작하는 것이 일반적이다. <indexterm>
	     <primary>부팅</>
	     <secondary>시 데이터베이스 서버 시작</>
	   </indexterm>
	   자동 시작 스크립트는 운영 체제마다 다르다. 
	   <productname>Agens SQL</productname>에서 배포되는 몇 가지 스크립트가 
	   <filename>contrib/start-scripts</> 디렉토리에 있다. 하나를 설치하려면 루트 권한이 필요하다.
	  </para>
	
	  <para>
	   시스템이 다르면 부팅 시 데몬을 시작하기 위한 규칙(convention)도 달라진다. 다수의 시스템에 
	   <filename>/etc/rc.local</filename> 또는
	   <filename>/etc/rc.d/rc.local</filename> 파일이 있다. 그 외에는 <filename>init.d</filename> 또는
	   <filename>rc.d</> 디렉토리를 사용한다. 서버는 <emphasis>루트</emphasis> 또는 다른 사용자가 아닌 <productname>Agens SQL</productname> 사용자 계정으로 실행해야 한다. 그러므로 
	   <literal>su agens -c '...'</literal> 류의 명령을 사용해야 한다. 예를 들면:
	<programlisting>
	su agens -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
	</programlisting>
	  </para>
	
	  <para>
	   운영 체제별로 특수한 몇 가지 예시는 다음과 같다. (각각의 경우 적절한 설치 디렉토리와 사용자 이름을 사용해야 하며, 여기서는 일반적인 값을 사용한다.)
	
	   <itemizedlist>
	    <listitem>
	     <para>
	      <productname>FreeBSD</productname>의 경우 <productname>Agens SQL</productname> 소스 배포에서 
	      <filename>contrib/start-scripts/freebsd</filename> 파일을 검토해야 한다.
	      <indexterm><primary>FreeBSD</><secondary>시작 스크립트</secondary></>
	     </para>
	    </listitem>
	
	    <listitem>
	     <para>
	      <productname>OpenBSD</productname>에서 다음 라인을 <filename>/etc/rc.local</filename> 파일에 추가해야 한다.
	      <indexterm><primary>OpenBSD</><secondary>시작 스크립트</secondary></>
	<programlisting>
	if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/agens ]; then
	    su -l agens -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/Agens SQL/log -D /usr/local/pgsql/data'
	    echo -n ' Agens SQL'
	fi
	</programlisting>
	     </para>
	    </listitem>
	
	    <listitem>
	     <para>
	      <productname>Linux</productname> 시스템에서는
	      <indexterm><primary>Linux</><secondary>시작 스크립트</secondary></>
	<programlisting>
	/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
	</programlisting>
	      를 <filename>/etc/rc.d/rc.local</filename>
	      또는 <filename>/etc/rc.local</filename>에 추가하거나 <productname>Agens SQL</productname> 소스 배포에서 
	      <filename>contrib/start-scripts/linux</filename> 파일을 검토해야 한다.
	     </para>
	    </listitem>
	
	    <listitem>
	     <para>
	      <productname>NetBSD</productname>에서는 기본 설정에 따라 
	      <productname>FreeBSD</productname> 또는
	      <productname>Linux</productname> 시작 스크립트를 사용해야 한다.
	      <indexterm><primary>NetBSD</><secondary>시작 스크립트</secondary></>
	     </para>
	    </listitem>
	
	    <listitem>
	     <para>
	      <productname>Solaris</productname>에서는 다음 라인이 포함된 
	      <filename>/etc/init.d/Agens SQL</filename> 파일을 생성해야 한다.
	      <indexterm><primary>Solaris</><secondary>시작 스크립트</secondary></>
	<programlisting>
	su - agens -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
	</programlisting>
	      그런 다음, <filename>S99Agens SQL</>로써 <filename>/etc/rc3.d</>에 심볼릭 링크를 생성해야 한다.
	     </para>
	    </listitem>
	   </itemizedlist>
	
	  </para>
	
	   <para>
	    서버 실행 중에 
	    <acronym>PID</acronym>는 데이터 디렉토리의 
	    <filename>postmaster.pid</filename> 파일에 저장된다. 이것은 동일한 데이터 디렉토리에서 실행되는 다중 서버 인스턴스를 방지하는 데 사용되고, 서버를 셧다운하는 데에도 사용될 수 있다.
	   </para>
	
	   <sect2 id="server-start-failures">
	    <title>서버 시작 실패</title>
	
	    <para>
	     서버 시작 실패에는 몇 가지 공통된 원인이 있다. 서버의 로그 파일을 확인하거나 직접 시작해서(표준 출력 또는 표준 에러를 리다이렉트하지 않고) 에러 메시지를 확인해야 한다. 아래는 몇 가지 공통된 에러 메시지를 자세히 설명한다.
	    </para>
	
	    <para>
	<screen>
	<computeroutput>
	LOG:  could not bind IPv4 socket: Address already in use
	HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
	FATAL:  could not create TCP/IP listen socket
	</computeroutput>
	</screen>
	     일반적으로 이것은 서버가 이미 실행되고 있는 포트에서 사용자가 다른 서버를 시작하려고 했음을 의미한다. 단, 커널 에러 메시지가 <computeroutput>Address already in use</computeroutput>가 아니거나, 이것과 약간 다른 경우 다른 문제일 가능성이 있다. 예를 들면, 예약된 포트 번호에서 서버를 시작하려고 하면 다음과 같이 할 것이다.
	<screen>
	<prompt>$</> <userinput>agens -p 666</userinput>
	<computeroutput>
	LOG:  could not bind IPv4 socket: Permission denied
	HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
	FATAL:  could not create TCP/IP listen socket
	</computeroutput>
	</screen>
	    </para>
	
	    <para>
	    메시지는 다음과 같이 나타난다.
	<screen>
	FATAL:  could not create shared memory segment: Invalid argument
	DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
	</screen>
	     이것은 공유 메모리 크기에 대한 커널 제한이 <productname>Agens SQL</productname>
	     이 생성하려고 하는 작업 영역보다 작다는 것을 의미하는 것일 수 있다(이 예시에서 4011376640바이트). 또는 커널에 환경 설정된 System-V-style 공유 메모리가 일절 지원되지 않는다는 것을 의미할 수도 있다. 임시 해결책으로, 버퍼 수를 정상보다 작게 해서 서버 시작을 시도해볼 수 있다(<xref linkend="guc-shared-buffers">). 결국에는 허용된 공유 메모리 크기를 늘리기 위해 사용자는 커널 다시 환경 설정을 할 수도 있다. 또한 동일한 머신에서 다중 서버를 시작하려는 경우 총 요청 공간이 커널 제한을 초과하면 이 메시지가 나타날 수도 있다.
	    </para>
	
	    <para>
	     에러가 다음과 같을 수 있다.
	<screen>
	FATAL:  could not create semaphores: No space left on device
	DETAIL:  Failed system call was semget(5440126, 17, 03600).
	</screen>
	     이것은 사용자의 디스크 공간이 소진되었음을 의미하지 <emphasis>않는다</emphasis>. 이것은 <systemitem
	     class="osname">System V</> 세마포어에 대한 커널 수 제한이 생성하려는 
	     <productname>Agens SQL</productname>의 수보다 작다는 것을 의미한다. 위와 마찬가지로, 허용된 연결 수
	     (<xref linkend="guc-max-connections">)를 줄여서 서버를 시작함으로써 문제를 해결할 수 있지만, 결국에는 커널 제한을 늘리는 것이 좋다.
	    </para>
	
	    <para>
	     <quote>illegal system call</> 에러가 나타난 경우 공유 메모리 또는 세마포어가 사용자의 커널에서 일절 지원되지 않는 것일 수 있다. 이런 경우 유일한 방법은 이 기능이 가능하도록 커널을 다시 환경 설정하는 것뿐이다.
	    </para>
	
	    <para>
	     <systemitem class="osname">System V</>
	     <acronym>IPC</> 기능 환경 설정에 대한 자세한 내용은 <xref linkend="sysvipc">에 나와 있다.
	    </para>
	   </sect2>
	
	   <sect2 id="client-connection-problems">
	    <title>클라이언트 연결 문제</title>
	
	    <para>
	     클라이언트 측에서 가능한 에러 조건이 다양하고 애플리케이션에 의존적이지만, 그 중 몇 가지는 서버를 시작한 방법과 직접적인 관련이 있다. 아래 표시된 조건 외에 다른 것은 각각의 클라이언트 어플리케이션을 사용하여 문서화되어야 한다.
	    </para>
	
	    <para>
	<screen>
	psql: could not connect to server: Connection refused
	        Is the server running on host "server.joe.com" and accepting
	        TCP/IP connections on port 5432?
	</screen>
	     이것은 일반적인 <quote>I couldn't find a server to talk
	     to</quote> 실패이다. TCP/IP 통신을 시도할 때 위와 같이 보인다.  흔한 실수로 TCP/IP 연결이 가능하도록 서버를 환경 설정하는 것을 잊어버리는 것이다.
	    </para>
	
	    <para>
	     그 대신, 로컬 서버에 대한 Unix 도메인 소켓 통신을 시도할 때 연결할 수도 있다.
	<screen>
	psql: could not connect to server: No such file or directory
	        Is the server running locally and accepting
	        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
	</screen>
	    </para>
	
	    <para>
	     마지막 라인은 클라이언트가 올바른 곳으로 연결을 시도하고 있는지 확인할 때 유용하다. 사실상, 실행 중인 서버가 없는 경우 커널 에러 메시지는 설명한 대로 보통 <computeroutput>Connection refused</computeroutput> 또는
	     <computeroutput>No such file or directory</computeroutput> 중 하나이다. (이 문맥의 
	     <computeroutput>Connection refused</computeroutput>는 서버가 사용자의 연결 요청을 접수했고 거부했다는 것을 의미하지 
	     <emphasis>않는다는</emphasis> 것을 알고 있는 것이 중요하다. 해당 사례는 <xref
	     linkend="client-authentication-problems">에 표시된 대로 다른 메시지가 나타난다.) <computeroutput>Connection timed out</computeroutput> 같은 다른 에러 메시지는 네트워크 연결성 부족 같은 좀 더 근본적인 문제를 나타내는 것일 수 있다.
	    </para>
	   </sect2>
	  </sect1>
	
	 <sect1 id="kernel-resources">
	  <title>커널 리소스 관리</title>
	
	  <para>
	   <productname>Agens SQL</>은 특히 서버의 복수 사본을 동일한 시스템에서 실행 중인 경우 또는 대규모 설치 중인 경우, 가끔씩 다양한 운영 체제 리소스 제한을 소진시킨다. 이 절에서는 <productname>Agens SQL</>가 사용하는 커널 리소스 및 커널 리소스 소비와 관련된 문제 해결 단계를 다룬다.
	  </para>
	
	  <sect2 id="sysvipc">
	   <title>공유 메모리 및 세마포어</title>
	
	   <indexterm zone="sysvipc">
	    <primary>공유 메모리</primary>
	   </indexterm>
	
	   <indexterm zone="sysvipc">
	    <primary>세마포어</primary>
	   </indexterm>
	
	   <para>
	    공유 메모리 및 세마포어는 통칭 
	    <quote><systemitem class="osname">System V</>
	    <acronym>IPC</></quote>라고 한다(<productname>Agens SQL</>과 무관한 메시지 큐와 함께).
	    <systemitem class="osname">Windows</> 외에, <productname>Agens SQL</>이 이러한 기능에 대한 자체적인 대체 구현을 제공하는 경우 
	    <productname>Agens SQL</>을 실행하기 위해 이러한 기능이 요구된다.
	   </para>
	
	   <para>
	    이러한 기능의 완전한 부재는 서버 시작 시 
	    <errorname>잘못된 시스템 호출</> 에러에 의해 보통 드러난다. 이런 경우 커널을 다시 환경 설정하는 것 외에는 대안이 없다. <productname>Agens SQL</>은 커널 없이 작동되지 않는다. 이러한 상황은 최신 운영 체제에서는 거의 일어나지 않는다.
	   </para>
	
	   <para>
	    <productname>Agens SQL</>이 다양한 하드 
	    <acronym>IPC</>제한 하나를 초과한 경우 서버는 시작을 거부하고 문제와 조치를 설명하는 지시적 에러 메시지를 남긴다. (<xref linkend="server-start-failures"> 참조) 관련 커널 파라미터의 이름은 각종 시스템 간에 동일하며, <xref linkend="sysvipc-parameters">에 개략적인 내용이 나와 있다. 단, 파라미터 설정 방법은 다를 수 있다. 일부 플랫폼에 대한 제시는 아래에 나와 있다.
	   </para>
	
	   <note>
	     <para>
	       <productname>Agens SQL</> 9.3 이전에는, 서버 시작에 훨씬 더 많은 System V 공유 메모리가 필요했다. 버전이 오래된 서버를 실행 중인 경우 문서에서 서버 버전을 참고하기 바란다.
	     </para>
	   </note>
	
	   <table id="sysvipc-parameters">
	    <title><systemitem class="osname">System V</> <acronym>IPC</> 파라미터</title>
	
	    <tgroup cols="3">
	     <thead>
	      <row>
	       <entry>이름</>
	       <entry>설명</>
	       <entry>적절한 값</>
	      </row>
	     </thead>
	
	     <tbody>
	      <row>
	       <entry><varname>SHMMAX</></>
	       <entry>공유 메모리 세그먼트의 최대 크기(바이트)</>
	       <entry>최소 1kB(서버 사본이 다수 실행되는 경우 그 이상)</entry>
	      </row>
	
	      <row>
	       <entry><varname>SHMMIN</></>
	       <entry>공유 메모리 세그먼트의 최소 크기(바이트)</>
	       <entry>1</>
	      </row>
	
	      <row>
	       <entry><varname>SHMALL</></>
	       <entry>사용 가능한 공유 메모리의 총 양(바이트 또는 페이지)</>
	       <entry>바이트인 경우 <varname>SHMMAX</varname>와 동일; 페이지인 경우 <literal>ceil(SHMMAX/PAGE_SIZE)</literal></>
	      </row>
	
	      <row>
	       <entry><varname>SHMSEG</></>
	       <entry>프로세스당 공유 메모리 세그먼트의 최대 수</>
	       <entry>1개 세그먼트만 필요하지만 기본값이 훨씬 큼</>
	      </row>
	
	       <row>
	        <entry><varname>SHMMNI</></>
	        <entry>시스템 차원(system-wide)의 공유 메모리 세그먼트의 최대 수</>
	        <entry><varname>SHMSEG</>와 동량 외 다른 애플리케이션의 여유분</>
	       </row>
	
	       <row>
	        <entry><varname>SEMMNI</></>
	        <entry>세마포어 식별자의 최대 수(예: 세트)</>
	        <entry>최소한 <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</literal></>
	       </row>
	
	       <row>
	        <entry><varname>SEMMNS</></>
	        <entry>시스템 차원(system-wide)의 세마포어 최대 수</>
	        <entry><literal>ceil((max_connections + autovacuum_max_workers + 4) / 16) * 17</literal> 외 다른 애플리케이션의 여유분</>
	       </row>
	
	       <row>
	        <entry><varname>SEMMSL</></>
	        <entry>세트별 세마포어 최대 수</>
	        <entry>최소한 17</>
	       </row>
	
	       <row>
	        <entry><varname>SEMMAP</></>
	        <entry>세마포어 맵에서 항목 수</>
	        <entry>텍스트 참조</>
	       </row>
	
	       <row>
	        <entry><varname>SEMVMX</></>
	        <entry>세마포어 최대 값</>
	        <entry>최소한 1000 (기본값은 대체로 32767; 필요한 경우 외에는 변경하지 말 것)</>
	       </row>
	
	     </tbody>
	    </tgroup>
	   </table>
	
	   <para>
	    <productname>Agens SQL</>은 서버 사본별로 System V 공유 메모리 수 바이트가 필요하다(64비트 플랫폼의 경우 보통 48바이트). 최신 운영 체제에서 이 정도 양은 손쉽게 할당 가능하다. 그러나, 서버 사본을 다수 실행 중이거나 다른 어플리케이션도 System V 공유 메모리를 사용 중인 경우 바이트 단위의 공유 메모리 최대 크기인 <varname>SHMMAX</>를 늘려야 하거나 시스템 차원(system-wide)의 System V 공유 메모리인 <varname>SHMALL</>를 늘려야 할 수 있다. <varname>SHMALL</>는 여러 시스템에서 바이트 단위가 아니라 페이지 단위로 처리된다는 점에 유의하라.
	   </para>
	
	   <para>
	    <productname>Agens SQL</>의 경우 많아야 약 32바이트에 불과하기 때문에(대개 1) 문제의 원인이 공유 메모리 세그먼트의 최소 크기(<varname>SHMMIN</>)일 가능성은 낮다. 시스템 차원(system-wide)의 세그먼트 최대 수(SHMMNI) 또는 프로세스당 최대 수(<varname>SHMMNI</>) 또는 프로세스당 최대 수(<varname>SHMSEG</>)는 시스템이 영(0)으로 설정되지 않는 한 문제의 원인이 될 가능성은 낮다.
	   </para>
	
	   <para>
	    <productname>Agens SQL</>은 16개 한 세트로, 허용된 연결당
	    (<xref linkend="guc-max-connections">) 및 autovacuum worker 프로세스당(<xref linkend="guc-autovacuum-max-workers">) 1개의 세마포어를 사용한다. 각각의 세트마다 다른 어플리케이션에서 사용되는 세마포어 세트와의 충돌을 감지하기 위한 <quote>매직 넘버</quote>가 17번째 세마포어에 포함되어 있다. 시스템에서 세마포어 최대 수는 <varname>SEMMNS</>에 의해 설정되며, 따라서 최소한 <varname>max_connections</> +
	    <varname>autovacuum_max_workers</> + 각각 허용된 16개 연결에 1 추가 + worker여야 한다(<xref
	    linkend="sysvipc-parameters"> 공식 참조). 파라미터 <varname>SEMMNI</>는 시스템에 동시에 존재할 수 있는 세마포어 세트 수에 대한 제한을 결정한다. 그러므로, 이 파라미터는 최소한 <literal>ceil((max_connections + autovacuum_max_workers + 4) / 16)</>여야 한다. 
	허용 연결 수를 줄이면 실패를 임시 방편으로 해결할 수 있으며, <function>semget</> 함수로부터 <quote>No space
	    left on device</>라는 애매한 메시지를 받게 된다.
	   </para>
	
	   <para>
	    경우에 따라서는 
	    <varname>SEMMAP</>를 적어도 
	    <varname>SEMMNS</>와 유사하게 늘릴 필요가 있을 수 있다. 이 파라미터는 세마포어 리소스 맵의 크기를 정의하며, 이 맵에서는 사용 가능한 세마포어의 연속 블록마다 항목을 필요로 한다. 세마포어 세트가 해제되면, 해제된 블록에 인접한 기존 항목에 추가되거나 새로운 맵 항목 아래에 등록된다. 맵이 꽉 차면 해제된 세마포어는 분실된다(리부팅될 때까지). 세마포어 공간의 조각화는 시간이 흐를수록 원래 있어야 할 것보다 사용 가능한 세마포어 수가 작아진다.
	   </para>
	
	   <para>
	    세트에 포함될 수 있는 세마포어 수를 결정하는 <varname>SEMMSL</>은 
	    <productname>Agens SQL</>의 경우 최소 17이어야 한다.
	   </para>
	
	   <para>
	    <varname>SEMMNU</> 및 <varname>SEMUME</> 같은 <quote>semaphore undo</>와 관련된 다양한 기타 설정은 
	    <productname>Agens SQL</>에 영향을 미치지 않는다.
	   </para>
	
	
	    <variablelist>
	     <varlistentry>
	      <term><systemitem class="osname">AIX</>
	      <indexterm><primary>AIX</><secondary>IPC configuration</></>
	      </term>
	      <listitem>
	       <para>
	        모든 메모리가 공유 메모리로 사용되도록 설정되므로, 적어도 버전 5.1은 
	        <varname>SHMMAX</varname>같은 파라미터에 대해 특수한 설정을 할 필요가 없다. 이것은 <application>DB/2</application> 같은 다른 데이터베이스에서 일반적으로 사용된 설정의 한 종류이다.</para>
	
	       <para> 그러나, 파일 크기(<varname>fsize</varname>)와 파일 수(<varname>nofiles</varname>)에 대한 기본 하드 제한이 가 너무 낮으므로 전역 
	       <command>ulimit</command> 정보를 
	       <filename>/etc/security/limits</filename>에서 변경해야 할 수 있다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	
	     <varlistentry>
	      <term><systemitem class="osname">FreeBSD</>
	      <indexterm><primary>FreeBSD</><secondary>IPC configuration</></>
	      </term>
	      <listitem>
	       <para>
	        기본 설정은 <command>sysctl</command> 또는
	        <command>loader</command> 인터페이스를 사용하여 변경할 수 있다. 다음 파라미터는 <command>sysctl</command>을 사용하여 설정할 수 있다.
	<screen>
	<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
	<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
	</screen>
	        리부팅 시에 이 설정을 유지하려면 
	        <filename>/etc/sysctl.conf</filename>를 수정해야 한다.
	       </para>
	
	       <para>
	        이러한 세마포어 관련 설정은 
	        <command>sysctl</command>에 관한 한 읽기 전용이지만 
	        <filename>/boot/loader.conf</filename>에서 설정 가능하다.
	<programlisting>
	kern.ipc.semmni=256
	kern.ipc.semmns=512
	kern.ipc.semmnu=256
	</programlisting>
	        이 값을 수정한 후에는 새 설정을 적용하려면 리부팅이 필요하다. (참고: FreeBSD는 <varname>SEMMAP</>를 사용하지 않는다. 오래된 버전은 <literal>kern.ipc.semmap</>에 대한 설정을 수용하지만 무시하고 새 버전은 완전히 무시한다.)
	       </para>
	
	       <para>
	        사용자는 커널을 환경 설정하여 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 못하게 하기를 원할 수 있다. 이것은 <command>sysctl</command>
	        설정 <literal>kern.ipc.shm_use_phys</literal>를 사용하면 가능하다.
	       </para>
	
	       <para>
	        <application>sysctl</>의 <literal>security.jail.sysvipc_allowed</>를 활성화하여 FreeBSD jail에서 실행 중인 경우 서로 다른 jail에서 실행 중인 <application>postmaster</>들은 서로 다른 시스템 사용자에 의해 실행되어야 한다. 루트 사용자가 아닌 경우 서로 다른 jail에서 사용자가 공유 메모리 또는 세마포어를 간섭하지 못하게 하고 Agens SQL IPC 클린업 코드가 올바로 작동되게 하기 때문에 이것은 보안을 개선시킨다. (FreeBSD 6.0 이상에서 IPC 클린업 코드는 서로 다른 jail에서 동일한 포트에 postmaster의 실행을 방지하기 때문에 다른 jail에서 프로세스를 올바로 감지하지 못한다.)
	       </para>
	
	       <para>
	        <systemitem class="osname">FreeBSD</> 4.0 이전 버전은 
	        <systemitem class="osname">OpenBSD</>처럼 작동된다(아래 참조).
	       </para>
	      </listitem>
	     </varlistentry>
	
	     <varlistentry>
	      <term><systemitem class="osname">NetBSD</>
	      <indexterm><primary>NetBSD</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        <systemitem class="osname">NetBSD</>5.0 이상에서, IPC 파라미터는 <command>sysctl</command>을 사용하여 조절 가능하다. 예를 들면:
	<screen>
	<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=16777216</userinput>
	</screen>
	        리부팅 시에 이 설정을 유지하려면 
	        <filename>/etc/sysctl.conf</filename>를 수정해야 한다.
	       </para>
	
	       <para>
	       사용자는 커널을 환경 설정하여 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 못하게 하기를 원할 수 있다. 이것은 <command>sysctl</command>
	        설정 <literal>kern.ipc.shm_use_phys</literal>를 사용하면 가능하다.
	       </para>
	
	       <para>
	        <systemitem class="osname">NetBSD</> 5.0 이전 버전은 키워드 <literal>option</>이 아니라 <literal>options</>로 설정되어야만 하는 파라미터인 경우 외에는 <systemitem class="osname">OpenBSD</> (아래 참조)처럼 작동된다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	     <varlistentry>
	      <term><systemitem class="osname">OpenBSD</>
	      <indexterm><primary>OpenBSD</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        옵션 <varname>SYSVSHM</> 및 <varname>SYSVSEM</>은 커널이 컴파일된 경우에 활성화되어야 한다(기본으로 설정돼 있음).  공유 메모리의 최대 크기는 옵션 <varname>SHMMAXPGS</> (페이지 단위)에 의해 결정된다. 다음 예시는 다양한 파라미터 설정 방법을 보여준다.
	<programlisting>
	option        SYSVSHM
	option        SHMMAXPGS=4096
	option        SHMSEG=256
	
	option        SYSVSEM
	option        SEMMNI=256
	option        SEMMNS=512
	option        SEMMNU=256
	option        SEMMAP=256
	</programlisting>
	       </para>
	
	       <para>
	        사용자는 커널을 환경 설정하여 공유 메모리를 RAM에 잠그고 스왑을 위해 페이지 아웃되지 못하게 하기를 원할 수 있다. 이것은 <command>sysctl</command>
	        설정 <literal>kern.ipc.shm_use_phys</literal>를 사용하면 가능하다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	     <varlistentry>
	      <term><systemitem class="osname">HP-UX</>
	      <indexterm><primary>HP-UX</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        기본 설정은 보편적으로 정상적인 설치에 충분하다. <productname>HP-UX</> 10에서 
	        <varname>SEMMNS</>의 출고시 기본 설정은 128이며, 이것은 거대 데이터베이스 사이트에는 너무 적을 수 있다.
	       </para>
	       <para>
	        <acronym>IPC</> 파라미터는 <menuchoice><guimenu>Kernel
	        Configuration</><guimenuitem>Configurable Parameters</></> 아래의 <application>System
	        Administration Manager</> (<acronym>SAM</>)에서 설정할 수 있다. 완료 시 
	        <guibutton>Create A New Kernel</>을 선택해야 한다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	
	     <varlistentry>
	      <term><systemitem class="osname">Linux</>
	      <indexterm><primary>Linux</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        최대 세그먼트 크기 기본값은 32 MB이며, 최대 총 크기 기본값은 2097152페이지이다. <quote>huge pages</quote>를 이용한 특수한 커널 환경 설정일 때 외에는 페이지는 거의 항상 4096바이트이다(확인하려면 <literal>getconf PAGE_SIZE</literal> 사용).
	       </para>
	
	       <para>
	        공유 메모리 크기 설정은 <command>sysctl</command> 인터페이스를 통해 변경 가능하다. 예를 들어, 16 GB를 허용하려면:
	<screen>
	<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
	<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
	</screen>
	        또한, <filename>/etc/sysctl.conf</filename> 파일에서 리부팅 사이에서도 이 설정을 보존할 수 있다. 이렇게 하는 것이 매우 바람직하다.
	       </para>
	
	       <para>
	        오래된 배포에는 <command>sysctl</command> 프로그램이 없을 수도 있지만 <filename>/proc</filename> 파일 시스템을 처리하여 동일하게 변경할 수 있다.
	<screen>
	<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
	<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
	</screen>
	       </para>
	
	       <para>
	        나머지 기본 설정은 아주 넉넉한 크기로, 일반적으로 변경이 불필요하다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	
	     <varlistentry>
	      <term><systemitem class="osname">OS X</>
	      <indexterm><primary>OS X</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        OS X에서 공유 메모리를 환경 설정하는 권장 방법은 다음과 같은 변수 할당이 포함된 <filename>/etc/sysctl.conf</> 파일을 생성하는 것이다.
	<programlisting>
	kern.sysv.shmmax=4194304
	kern.sysv.shmmin=1
	kern.sysv.shmmni=32
	kern.sysv.shmseg=8
	kern.sysv.shmall=1024
	</programlisting>
	        일부 OS X 버전에서, 
	        <emphasis>모두 5개</>의 공유 메모리 파라미터를 
	        <filename>/etc/sysctl.conf</>에 설정해야 하며, 그렇지 않으면 값이 무시된다는 점에 유의해야 한다.
	       </para>
	
	       <para>
	        OS X 최근 릴리스는 설정된 <varname>SHMMAX</>가 정확히 4096의 배수가 아니면 이 값을 무시한다.
	       </para>
	
	       <para>
	        <varname>SHMALL</>는 이 플랫폼에서 4 kB로 평가된다.
	       </para>
	
	       <para>
	        OS X 구 버전에서는 공유 메모리 파라미터에 대한 변경 내용이 적용되려면 리부팅 해야 한다. 10.5는 현재, <application>sysctl</>을 사용하여 <varname>SHMMNI</>를 제외한 모두를 상황에 따라 변경 가능하다. 그러나 리부팅 사이에 값이 유지될 수 있도록 <filename>/etc/sysctl.conf</>를 통해 원하는 값을 설정하는 것이 최선이다.
	       </para>
	
	       <para>
	        <filename>/etc/sysctl.conf</> 파일은 OS X 10.3.9 이상에서만 유효하다. 이전 10.3.x 릴리스를 실행 중인 경우 <filename>/etc/rc</>
	        파일을 편집하여 다음 명령으로 값을 변경해야 한다.
	<programlisting>
	sysctl -w kern.sysv.shmmax
	sysctl -w kern.sysv.shmmin
	sysctl -w kern.sysv.shmmni
	sysctl -w kern.sysv.shmseg
	sysctl -w kern.sysv.shmall
	</programlisting>
	        Note that
	        <filename>/etc/rc</>는 일반적으로 OS X 시스템 업데이트 시 덮어쓰기 되므로 업데이트가 있을 때마다 사용자는 이러한 편집을 반복해야 한다.
	       </para>
	
	       <para>
	        OS X 10.2 이전 버전에서는 <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</> 파일에서 이 명령을 편집해야 한다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	
	     <varlistentry>
	      <term><systemitem class="osname">SCO OpenServer</>
	      <indexterm><primary>SCO OpenServer</><secondary>IPC configuration</></>
	      </term>
	      <listitem>
	       <para>
	        기본 환경 설정에서 세그먼트당 512 kB의 공유 메모리만 허용된다. 설정을 변경하려면 먼저 <filename>/etc/conf/cf.d</>디렉토리로 이동해야 한다. 
	        <varname>SHMMAX</>의 현재 값을 표시하려면 다음을 실행한다.
	<programlisting>
	./configure -y SHMMAX
	</programlisting>
	        <varname>SHMMAX</>에 새 값을 설정하려면 다음을 실행한다.
	<programlisting>
	./configure SHMMAX=<replaceable>value</>
	</programlisting>
	        여기서 <replaceable>value</>는 사용하려는 새 값이다(바이트 단위). <varname>SHMMAX</>를 설정한 후에는 커널을 리빌드한다.
	<programlisting>
	./link_unix
	</programlisting>
	        그런 다음 리부팅한다.
	       </para>
	      </listitem>
	     </varlistentry>
	     <varlistentry>
	      <term><systemitem class="osname">Solaris</> 2.6 to 2.9 (Solaris
	      6 ~ Solaris 9)
	      <indexterm><primary>Solaris</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        해당 설정은 
	        <filename>/etc/system</>에서 변경 가능하다. 예를 들면:
	<programlisting>
	set shmsys:shminfo_shmmax=0x2000000
	set shmsys:shminfo_shmmin=1
	set shmsys:shminfo_shmmni=256
	set shmsys:shminfo_shmseg=256
	
	set semsys:seminfo_semmap=256
	set semsys:seminfo_semmni=512
	set semsys:seminfo_semmns=512
	set semsys:seminfo_semmsl=32
	</programlisting>
	        변경한 내용을 적용하려면 사용자의 리부팅이 필요하다. 이전 Solaris 버전에서 공유 메모리에 대한 내용은 
	        <ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
	        을 참조 바란다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	     <varlistentry>
	      <term><systemitem class="osname">Solaris</> 2.10 (Solaris
	      10) 이상</term>
	      <term><systemitem class="osname">OpenSolaris</></term>
	      <listitem>
	       <para>
	        Solaris 10 이상 및 OpenSolaris에서 기본 공유 메모리 및 세마포어 설정은 대부분의 
	        <productname>Agens SQL</> 애플리케이션에서 충분하다. 이제 Solaris는 시스템 <acronym>RAM</>의 1/4을 <varname>SHMMAX</> 기본값으로 설정한다. 이 설정을 좀 더 조정하려면 <literal>agens</> 사용자에 대한 프로젝트 설정을 사용해야 한다. 예를 들면, <literal>root</>로 다음을 실행한다.
	<programlisting>
	projadd -c "Agens SQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U agens -G agens user.agens
	</programlisting>
	       </para>
	
	       <para>
	        이 명령은 <literal>user.agens</> 프로젝트를 추가하고 <literal>agens</>
	        사용자에 대한 공유 메모리 최대값을 8GB로 설정하고, 다음에 사용자 로그인 시 적용되거나 <productname>Agens SQL</> 재시작 시 적용된다(리로드 아님). 위의 것은 <productname>Agens SQL</>이 <literal>agens</> 그룹의 <literal>agens</> 사용자로 실행되는 것으로 간주한다. 서버 리부팅은 불필요하다.
	       </para>
	
	       <para>
	        연결이 다수 있는 데이터베이스 서버에 대한 다른 권장 커널 설정 변경은 다음과 같다.
	<programlisting>
	project.max-shm-ids=(priv,32768,deny)
	project.max-sem-ids=(priv,4096,deny)
	project.max-msg-ids=(priv,4096,deny)
	</programlisting>
	       </para>
	
	       <para>
	        또한 zone 내에서 <productname>Agens SQL</>을 실행 중인 경우 zone 리소스 사용 제한도 올려야 할 필요가 있다. <literal>projects</> 및 <command>prctl</>에 대한 자세한 내용은 <citetitle>System Administrator's Guide</>의 "Chapter2:  Projects and Tasks"를 참조 바란다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	
	     <varlistentry>
	      <term><systemitem class="osname">UnixWare</>
	      <indexterm><primary>UnixWare</><secondary>IPC 설정</></>
	      </term>
	      <listitem>
	       <para>
	        <productname>UnixWare</> 7에서 공유 메모리 세그먼트의 최대 크기는 기본 환경 설정에서 512 kB이다. <varname>SHMMAX</>의 현재 값을 표시하려면 다음을 실행한다.
	<programlisting>
	/etc/conf/bin/idtune -g SHMMAX
	</programlisting>
	        이것은 현재값, 기본값, 최소값 및 최대값을 표시한다. <varname>SHMMAX</>에 새 값을 설정하려면 다음을 실행한다.
	<programlisting>
	/etc/conf/bin/idtune SHMMAX <replaceable>value</>
	</programlisting>
	        여기서 <replaceable>value</>는 사용하려는 바이트 단위의 새 값이다. <varname>SHMMAX</>를 설정한 후에는 커널을 리빌드한다.
	<programlisting>
	/etc/conf/bin/idbuild -B
	</programlisting>
	        그런 다음 리부팅한다.
	       </para>
	      </listitem>
	     </varlistentry>
	
	    </variablelist>
	
	  </sect2>
	
	  <sect2>
	   <title>리소스 제한</title>
	
	   <para>
	    Unix계열의 운영 체제는 사용자의 <productname>Agens SQL</productname> 서버에도 영향을 미칠 수 있는 리소스 제한 형태가 다양하다. 그 중에 사용자별 프로세스 수, 프로세스당 개방 파일 수, 각 프로세스에서 사용 가능한 메모리 양에 대한 제한이 특히 중요하다. 이러한 제한은 각각 <quote>하드</quote> 및     <quote>소프트</quote> 제한이 있다. 소프트 제한은 실제로 계산하는 것이지만, 사용자가 하드 제한까지 증가 시킬 수 있다. 하드 제한은 root 사용자만이 변경 가능하다. 시스템 호출 
	    <function>setrlimit</function>는 이러한 파라미터의 설정을 담당한다. 쉘의 빌트인 명령어 <command>ulimit</command>
	    (Bourne 쉘) 또는 <command>limit</command> (<application>csh</>)는 커맨드 라인에서 리소스 제한을 제어하는 데 사용된다. BSD 파생 시스템에서  <filename>/etc/login.conf</filename> 파일은 로그인 동안 다양한 리소스 제한 설정을 제어한다. 자세한 내용은 운영 체제 문서를 참조 바란다. 관련 파라미터는 <varname>maxproc</varname>, <varname>openfiles</varname> 및 <varname>datasize</varname>들이 있다. 예제는 아래와 같다.
	<programlisting>
	default:\
	...
	        :datasize-cur=256M:\
	        :maxproc-cur=256:\
	        :openfiles-cur=256:\
	...
	</programlisting>
	    (<literal>-cur</literal>는 소프트 제한이다. 하드 제한을 설정하려면 
	    <literal>-max</literal>를 덧붙인다.)
	   </para>
	
	   <para>
	    커널은 일부 리소스에 대해 시스템 차원(system-wide)의 제한을 가질 수 있다.
	    <itemizedlist>
	     <listitem>
	      <para>
	      <productname>Linux</productname>에서 
	      <filename>/proc/sys/fs/file-max</filename>는 커널이 지원하는 개방 파일의 최대 수를 결정한다. 파일 내에 다른 수를 적거나 <filename>/etc/sysctl.conf</filename>에 할당을 추가하면 변경이 가능하다. 프로세스당 파일의 최대 제한은 커널이 컴파일되는 시점에 수정된다. 자세한 내용은 
	      <filename>/usr/src/linux/Documentation/proc.txt</filename>를 참조 바란다.
	      </para>
	     </listitem>
	    </itemizedlist>
	   </para>
	
	   <para>
	    <productname>Agens SQL</productname> 서버는 연결당 프로세스 1개를 사용하므로 허용된 연결 수에 해당되는 프로세스는 최소한 제공한 다음에 사용자는 시스템에서 필요로 하는 나머지를 제공해야 한다. 이것은 일반적으로 문제가 되지 않지만 머신 1대에 몇 개의 서버를 실행하는 경우에는 쉽지 않을 수 있다.
	   </para>
	
	   <para>
	    개방 파일에 대한 기본 제한은 시스템 리소스를 부적절하게 분할하지 않고도 여러 사용자가 머신에 공존할 수 있는 값인 
	    <quote>사회적으로 용인되는</quote> 값으로 설정된다. 사용자가 필요에 따라 머신 1대에서 여러 개의 서버를 실행하지만, 특정한 전용 서버의 제한만 올리고자 할 수도 있다.
	   </para>
	
	   <para>
	    다른 한편으로, 일부 시스템에서는 독립된 프로세스들이 많은 수의 파일들을 열 수 있게 한다. 그러면 몇 개의 프로세스만 실행되더라도 시스템 차원(system-wide)의 제한이 손쉽게 초과된다. 이러한 상황이 발생되었지만 시스템 차원(system-wide)의 제한을 변경하고 싶지 않을 경우에는 <productname>Agens SQL</>의 <xref linkend="guc-max-files-per-process"> 환경 설정 파라미터를 설정하여 개방 파일의 소비를 제한할 수 있다.
	   </para>
	  </sect2>
	
	  <sect2 id="linux-memory-overcommit">
	   <title>Linux 메모리 Overcommit</title>
	
	   <para>
	    Linux 2.4 이상에서 기본 가상 메모리 동작은 <productname>Agens SQL</productname>의 경우 최적화 되어 있지 않다. 커널이 메모리 오버커밋을 이행하는 방식 때문에 <productname>Agens SQL</productname> 또는 다른 프로세스의 메모리 수요가 시스템의 가상 메모리가 소진되는 원인이 되는 경우 커널은 
	    <productname>Agens SQL</productname> postmaster(마스터 서버 프로세스)를 종료해야 한다.
	   </para>
	
	   <para>
	    이런 경우가 발생하면 이와 같은 커널 메시지가 나타난다(해당 메시지를 찾아 보려면 시스템 문서 및 환경 설정 참조).
	<programlisting>
	Out of Memory: Killed process 12345 (agens).
	</programlisting>
	    이것은 <filename>agens</filename> 프로세스가 메모리 압박 때문에 종료되었음을 나타낸다. 기존 데이터베이스 연결이 정상 작동되더라도 새로운 연결은 수락되지 않는다. 복구하려면 <productname>Agens SQL</productname>을 재시작해야 한다.
	   </para>
	
	   <para>
	    이 문제를 방지하는 방법 중 하나는 다른 프로세스 때문에 머신의 메모리가 소진되지 않을 것이 확실한 머신에서 
	    <productname>Agens SQL</productname>을 실행하는 것이다. 실제 메모리와 swap 공간이 소진된 경우에만 메모리 부족(OOM) 킬러가 호출되기 때문에 메모리에 여유가 없는 경우에는 운영 체제의 swap 공간을 늘리면 문제를 방지하는 데 도움이 된다.
	   </para>
	
	   <para>
	    <productname>Agens SQL</productname> 자체가 메모리 부족의 원인인 경우 환경 설정을 변경하면 문제를 방지할 수 있다. 경우에 따라 메모리 관련 환경 설정 파라미터, 특히 
	    <link linkend="guc-shared-buffers"><varname>shared_buffers</></link>
	    및 <link linkend="guc-work-mem"><varname>work_mem</></link>을 줄이는 것이 도움이 된다. 그 외에는 데이터베이스 서버 자체로의 연결을 너무 많이 허용하는 것이 문제의 원인일 수 있다. 대체로, 
	    <link linkend="guc-max-connections"><varname>max_connections</></link>를 줄이는 대신 외부 연결 풀링 소프트웨어를 이용하는 것이 좋다.
	   </para>
	
	   <para>
	    Linux 2.6 이상에서 커널의 동작을 수정해서 메모리 <quote>오버커밋</quote>을 방지할 수 있다. 
	    이 설정으로 <ulink
	    url="http://lwn.net/Articles/104179/">OOM killer</>의 호출이 전적으로 방지되는 않지만 가능성은 확연히 줄어들며, 따라서 시스템 동작이 좀 더 견고해진다. <command>sysctl</command>을 통해 엄격한 오버커밋 모드를 선택함으로써 이것이 가능해진다.
	<programlisting>
	sysctl -w vm.overcommit_memory=2
	</programlisting>
	    또는 동일한 항목을 <filename>/etc/sysctl.conf</>에 입력해도 된다. 
	    사용자는 이와 관련된 설정인 <varname>vm.overcommit_ratio</>의 수정을 원할 수도 있다. 자세한 내용은 커널 문서 파일 <filename>Documentation/vm/overcommit-accounting</>을 참조 바란다.
	   </para>
	
	   <para>
	    <varname>vm.overcommit_memory</>를 변경 또는 변경없이 사용하는 또다른 방법은 postmaster 프로세스의 프로세스 특정 
	    <varname>oom_score_adj</> 값을 <literal>-1000</>으로 설정하는 것이다. 그렇게 함으로써 OOM 킬러의 타겟이 되는 것을 면할 수 있다. 이렇게 하는 가장 간단한 방법은
	<programlisting>
	echo -1000 > /proc/self/oom_score_adj
	</programlisting>
	    postmaster를 호출하기 전에 상기 명령을 postmaster의 시작 스크립트에서 실행하는 것이다. 이러한 액션은 root로 실행하지 않으면 아무런 효력이 없으므로 root권한 소유의 시작 스크립트를 이용하는 것이 가장 간단하다. 이를 위해 사용자는 <varname>CPPFLAGS</>에 추가된 <literal>-DLINUX_OOM_SCORE_ADJ=0</>를 사용하여 <productname>Agens SQL</>을 빌드할 수 있다. 이것은 postmaster 자식 프로세스가 <varname>oom_score_adj</> 일반값 0으로 실행되는 원인이 되어 OOM 킬러가 필요 시 타겟으로 삼을 수 있다.
	   </para>
	
	   <para>
	이전 Linux 커널은 <filename>/proc/self/oom_score_adj</>를 제공하지 않지만 <filename>/proc/self/oom_adj</>가 동일한 기능을 제공할 수도 있다. 이것은 비활성 값이 <literal>-1000</>이 아니라 <literal>-17</>인 경우 외에는 동일하게 작동된다. <productname>Agens SQL</>에 해당되는 동일한 빌드 플래그는 <literal>-DLINUX_OOM_ADJ=0</>이다.
	   </para>
	
	   <note>
	   <para>
	일부 공급업체의 Linux 2.4 커널은 2.6 오버커밋 <command>sysctl</command> 파라미터의 초기 버전을 가지고 있는 것으로 알려져 있다. 그러나, 관련 코드가 없는 2.4 커널에서 <literal>vm.overcommit_memory</>가 2로 설정되는 것은 상황을 더 나쁘게 만든다. 실제 커널 소스 코드를 확인하여( <filename>mm/mmap.c</> 파일에서 <function>vm_enough_memory</> 참조) 2.4 설치에서 이것을 시도하기 전에 사용자의 커널에서 무엇이 지원되는지 확인하는 것이 좋다. <filename>overcommit-accounting</> 문서 파일이 존재한다고 해서 기능이 지원된다는 증거로 생각해서는 <emphasis>안</> 된다. 의심스러울 경우는 커널 전문가 또는 커널 공급업체에게 문의 바란다.
	   </para>
	   </note>
	  </sect2>
	
	  <sect2 id="linux-huge-pages">
	   <title>Linux huge pages</title>
	
	   <para>
	huge pages를 사용하면 <productname>Agens SQL</productname> 같이 인접한 거대 메모리 청크 사용 시 오버헤드가 줄어든다. <productname>Agens SQL</productname>에서 이 기능을 활성화하려면 <varname>CONFIG_HUGETLB_PAGE=y</varname> 및 <varname>CONFIG_HUGETLBFS=y</varname>를 사용하는 커널이 필요하다. 시스템 설정 <varname>vm.nr_hugepages</varname>도 튜닝해야 한다. 필요한 huge pages 수를 추정하려면 huge pages 활성화 없이 <productname>Agens SQL</productname>을 시작하고 proc 파일 시스템에서 <varname>VmPeak</varname> 값을 확인해야 한다.
	<programlisting>
	<prompt>$</> <userinput>head -1 /path/to/data/directory/postmaster.pid</userinput>
	4170
	<prompt>$</> <userinput>grep ^VmPeak /proc/4170/status</userinput>
	VmPeak:  6490428 kB
	</programlisting>
	<literal>6490428</literal> / <literal>2048</literal> (이 경우 <varname>PAGE_SIZE</varname>는 <literal>2MB</literal>)는 대략 <literal>3169.154</literal> huge pages이므로 최소 <literal>3170</literal> huge pages가 필요하다.
	<programlisting>
	<prompt>$</> <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
	</programlisting>
	가끔 커널은 원하는 수의 huge pages를 할당할 수 없어서 해당 명령을 반복하거나 리부팅이 필요할 수 있다. 리부팅 시에 이 설정을 유지하려면 <filename>/etc/sysctl.conf</filename>에 항목을 추가하는 것을 잊으면 안 된다.
	   </para>
	
	   <para>
	<productname>Agens SQL</productname>에서 huge pages의 기본 동작은 가능할 경우 사용하는 것이고 실패할 경우 정상 페이지로 폴백(fallback)하는 것이다. <link linkend="guc-huge-pages"><varname>huge_pages</varname></link>를 <literal>on</literal>으로 설정하면 huge pages를 강제로 사용할 수 있다. 이 경우 사용 가능한 huge pages가 부족하면 <productname>Agens SQL</productname>을 시작하지 못할 수도 있다.
	   </para>
	
	   <para>
	<productname>Linux</productname> huge pages 기능에 대한 자세한 설명은 <ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</ulink>를 읽어 보기 바란다.
	   </para>
	
	  </sect2>
	 </sect1>
	
	
	 <sect1 id="server-shutdown">
	  <title>서버 셧다운</title>
	
	  <indexterm zone="server-shutdown">
	   <primary>셧다운</>
	  </indexterm>
	
	  <para>
	   데이터베이스 서버를 셧다운 하는 방법에는 몇 가지가 있다. 사용자는 마스터 
	   <command>agens</command> 프로세스에 서로 다른 신호를 전송하여 셧다운 유형을 제어한다.
	
	   <variablelist>
	    <varlistentry>
	     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
	     <listitem>
	      <para>
	       이것은 <firstterm>스마트 셧다운</firstterm> 모드이다. 
	       <systemitem>SIGTERM</systemitem>을 수신한 후, 서버는 새로운 연결을 불허하지만 기존 세션은 정상적인 종료를 허용한다. 모든 세션이 종료된 후에만 셧다운된다. 서버가 온라인 백업 모드인 경우 온라인 백업 모드가 더 이상 작동하지 않을 때까지 조금 더 대기한다. 백업 모드가 작동되는 중에는 새로운 연결이 수퍼유저에게만 계속 허용된다(이러한 예외는 온라인 백업 모드를 종료하기 위해 수퍼유저가 연결하는 것을 허용). 서버가 복구 중인 상태에서 스마트 셧다운이 요청되면, 모든 정규 세션이 종료된 후에만 복구 및 streaming replication이 중단된다.
	      </para>
	     </listitem>
	    </varlistentry>
	
	    <varlistentry>
	     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
	     <listitem>
	      <para>
	       이것은 <firstterm>빠른 셧다운</firstterm> 모드이다.
	       서버는 새로운 연결을 불허하고 모든 기존 서버 프로세스 <systemitem>SIGTERM</systemitem>을 전송하는데, 이로써 현재 트랜잭션이 중단되고 즉시 종료된다. 그런 다음, 모든 서버 프로세스가 종료되도록 기다렸다가 최종적으로 셧다운된다. 서버가 온라인 백업 모드인 경우 백업이 무용지물임이 표시되면서 백업 모드가 종료된다.
	      </para>
	     </listitem>
	    </varlistentry>
	
	    <varlistentry>
	     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
	     <listitem>
	      <para>
	이것은 <firstterm>즉시 셧다운 모드</firstterm>이다. 서버는 <systemitem>SIGQUIT</systemitem>를 모든 자식 프로세스에 전송하고 자식 프로세스가 종료될 때까지 대기한다. 5초 이내에 종료되지 않는 프로세스에는 마스터 <command>agens</command> 프로세스에 의해 <systemitem>SIGKILL</systemitem>이 전송되고, 따라서 더 이상 대기하지 않고 종료된다. 이것은 다음 시작 시 복구로 이어진다(WAL 로그 리플레이에 의해). 이것은 비상 시에만 권장된다.
	      </para>
	     </listitem>
	    </varlistentry>
	   </variablelist>
	  </para>
	
	  <para>
	pg_ctl 프로그램은 이러한 서버 셧다운 신호를 전송하기 위한 편리한 인터페이스를 제공한다. 또는 Windows가 아닌 시스템에서 <command>kill</>을 사용하여 직접 신호를 전송할 수 있다. <command>agens</command> 프로세스의 <acronym>PID</>는 <command>ps</command> 프로그램을 사용하여 찾을 수 있거나 데이터 디렉토리에서 <filename>postmaster.pid</filename> 파일에서 찾을 수 있다. 예를 들어, 빠른 셧다운을 하려면 아래와 같은 명령어로 가능하다.
	<screen>
	<prompt>$</> <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
	</screen>
	  </para>
	
	  <important>
	   <para>
	서버 셧다운 시 <systemitem>SIGKILL</systemitem>은 사용하지 않는 것이 최선이다. 그럴 경우 서버에서 공유 메모리 및 세마포어가 해제되지 않아서, 새 서버를 시작하기 전에 수동으로 해제를 해야 할 수 있다. 또한 <systemitem>SIGKILL</systemitem>은 하위 프로세스로 신호를 전달하지 않고 <command>agens</command>를 kill하므로 각각의 하위 프로세스 역시 직접 kill해야 한다.
	   </para>
	  </important>
	
	  <para>
	다른 세션은 계속하면서 개별 세션을 종료하려면 <function>pg_terminate_backend()</>를 사용하거나 세션과 관련된 자식 프로세스에 <systemitem>SIGTERM</> 신호를 전송해야 한다.
	  </para>
	 </sect1>
	
	 <sect1 id="upgrading">
	  <title><productname>Agens SQL</> 클러스터 업그레이드</title>
	
	  <indexterm zone="upgrading">
	   <primary>업그레이드</primary>
	  </indexterm>
	
	  <indexterm zone="upgrading">
	   <primary>버전</primary>
	   <secondary>호환성</secondary>
	  </indexterm>
	
	  <para>
	이 절에서는 <productname>Agens SQL</> 릴리스의 데이터베이스 데이터를 새로운 것으로 업그레이드하는 방법을 다룬다.
	  </para>
	
	  <para>
	<productname>Agens SQL</> 메이저 버전은 버전 번호의 첫 두 자리이며, 예를 들면 8.4이다. <productname>Agens SQL</> 마이너 버전은 버전 번호의 세 번째 자릿수부터이다. 예를 들면, 8.4.2는 8.4의 두 번째 부 릴리스이다. 마이너 릴리스는 내부 스토리지 형식을 절대 변경하지 않으며 메이저 버전 번호가 동일하면 이전 및 이후 마이너 릴리스와 항상 호환된다. 예를 들면, 8.4.2는 8.4, 8.4.1 및 8.4.6과 호환된다. 호환 버전 간에 업데이트를 하려면 서버를 다운한 상태에서 실행 파일을 간단히 교체하고 서버를 시작하면 된다. 데이터 디렉토리는 변경되지 않고 유지된다. 마이너 업그레이드는 간단하다.
	  </para>
	
	  <para>
	<productname>Agens SQL</>의 <emphasis>메이저</> 릴리스의 경우, 내부 데이터 스토리지 형식이 변경되므로 업그레이드가 복잡하다. 데이터를 새로운 메이저 버전으로 옮기는 전형적인 방법은 느릴 수 있지만 데이터베이스를 덤프하고 다시 불러오는 것이다. 더 빠른 방법은 pgupgrade이다. 복제 방법도 아래에 언급된 바와 같이 사용 가능하다.
	  </para>
	
	  <para>
	일반적으로 새 메이저 버전에서도 사용자 가시(user-visible) 비호환성이 도입되므로 어플리케이션 프로그래밍 변경이 요구되곤 한다. 모든 사용자 가시(user-visible) 변경은 릴리스 노트에 나와 있다. "마이그레이션" 절을 특히 주의 깊게 보아야 한다. 몇 가지 메이저 버전에 걸쳐 업그레이드하는 경우 각각의 매개 버전에 대한 릴리스 노트를 읽어 보아야 한다.
	  </para>
	
	  <para>
	세심한 사용자라면 새 버전으로 완전히 넘어가기 전에 클라이언트 어플리케이션을 새 버전에서 테스트해보고 싶을 것이다. 그러므로, 이전 버전과 새 버전의 동시 설치를 설정하는 것이 좋은 아이디어이다. <productname>Agens SQL</> 메이저 업그레이드를 테스트할 때 다음과 같이 변경 가능성이 있는 카테고리를 고려해야 한다.
	  </para>
	
	  <variablelist>
	
	   <varlistentry>
	    <term>관리</term>
	    <listitem>
	     <para>
	      서버를 모니터링 및 관리하기 위해 관리자가 사용할 수 있는 기능이 메이저 릴리스에서 주로 변경 및 개선된다.
	     </para>
	    </listitem>
	   </varlistentry>
	
	   <varlistentry>
	    <term>SQL</term>
	    <listitem>
	     <para>
	      일반적으로 새 SQL 명령이 여기에 포함되고, 특별한 언급이 릴리스 노트에 없으면 동작하지 않는 변경은 없다.
	     </para>
	    </listitem>
	   </varlistentry>
	
	   <varlistentry>
	    <term>라이브러리 API</term>
	    <listitem>
	     <para>
	릴리스 노트에 특별한 언급이 없으면, <application>libpq</> 같은 전형적인 라이브러리만 새로운 기능을 추가한다.
	     </para>
	    </listitem>
	   </varlistentry>
	
	   <varlistentry>
	    <term>시스템 카탈로그</term>
	    <listitem>
	     <para>
	      시스템 카탈로그 변경은 보통 데이터베이스 관리 도구에만 영향을 미친다.
	     </para>
	    </listitem>
	   </varlistentry>
	
	   <varlistentry>
	    <term>서버 C 언어 API</term>
	    <listitem>
	     <para>
	      이것은 C 프로그래밍 언어로 작성된 백엔드 함수 API의 변경과 관련이 있다. 해당 변경은 서버 내 백엔드 함수를 참조하는 코드에 영향을 미친다.
	     </para>
	    </listitem>
	   </varlistentry>
	
	  </variablelist>
	
	  <sect2 id="upgrading-via-pgdumpall">
	   <title><application>pg_dumpall</>을 통한 데이터 업그레이드</title>
	
	   <para>
	업그레이드 방법 중 하나는 <productname>Agens SQL</>의 메이저 버전에서 데이터를 덤프하고 다른 버전에서 다시 불러오는 것이다. 이렇게 하려면 <application>pg_dumpall</> 같은 <emphasis>논리적</> 백업 툴을 사용해야 한다. 파일 시스템 레벨 백업 방법은 작동되지 않는다. (호환되지 않는 <productname>Agens SQL</productname> 버전으로는 데이터 디렉토리를 사용하지 못하도록 하는 검사가 존재하며,  그래서 데이터 디렉토리에서 잘못된 서버 버전을 시작하려는 시도가 있더라도 큰 위험은 방지된다.)
	   </para>
	
	   <para>
	이 프로그램에서 개선 기능의 장점을 활용하려면 <emphasis>새</> 버전의 <productname>Agens SQL</>에서 <application>pg_dump</> 및 <application>pg_dumpall</> 프로그램을 사용하는 것이 바람직하다. 덤프 프로그램의 현재 릴리스는 과거의 모든 서버 버전부터 7.0까지의 데이터를 읽을 수 있다.
	   </para>
	
	   <para>
	이 지침은 기존 설치가 <filename>/usr/local/pgsql</> 디렉토리이고, 데이터 영역이 <filename>/usr/local/pgsql/data</>인 것으로 간주한다. 사용자 경로에 맞게 적절한 대체가 필요하다.
	   </para>
	
	   <procedure>
	    <step>
	     <para>
	백업 시 데이터베이스가 업데이트 중이 아닌지 확인해야 한다. 이것이 백업의 무결성에는 영향을 미치지 않지만 변경된 데이터는 당연히 포함되지 않는다. 필요 시 <filename>/usr/local/pgsql/data/pg_hba.conf</> 파일(또는 동등한 파일)에서 권한을 편집하여 사용자 본인을 제외한 모든 사람의 액세스를 불허해야 한다. 액세스 제어에 대한 자세한 내용은 <xref linkend="client-authentication">을 참조 바란다.
	     </para>
	
	     <para>
	      <indexterm>
	       <primary>pg_dumpall</primary>
	       <secondary>use during upgrade</secondary>
	      </indexterm>
	
	      데이터베이스 설치를 백업하려면 다음을 입력한다.
	<screen>
	<userinput>pg_dumpall &gt; <replaceable>outputfile</></userinput>
	</screen>
	     </para>
	
	     <para>
	백업을 하기 위해 현재 실행 중인 버전에서 <application>pg_dumpall</application> 명령을 선택할 수 있다. 자세한 내용은 <xref
	      linkend="backup-dump-all">을 참조 바란다. 최고의 결과를 내려면 버그 수정 기능이 있고 이전 버전보다 개선된 <productname>Agens SQL</productname> 9.4.1에서 <application>pg_dumpall</application> 명령의 사용을 시도해야 한다. 새 버전을 아직 설치하지 않았기 때문에 이 권고가 이상해 보일 수 있지만 새 버전을 이전 버전과 병행 설치할 생각이면 이것을 따르는 것이 좋다. 이런 경우 설치를 정상적으로 완료하고 데이터는 나중에 전송할 수 있다. 이렇게 하면 다운타임도 줄어든다.
	     </para>
	    </step>
	
	    <step>
	     <para>
	      이전 서버 셧다운:
	<screen>
	<userinput>pg_ctl stop</>
	</screen>
	부팅 시에 <productname>Agens SQL</>이 시작되는 시스템에서 같은 작업을 수행하는 파일이 있을 수 있다. 예를 들면, <systemitem class="osname">Red Hat Linux</> 시스템에서도 이러한 동작을 찾아볼 수 있다.
	<screen>
	<userinput>/etc/rc.d/init.d/Agens SQL stop</userinput>
	</screen>
	서버 시작 및 중단에 대한 내용은 <xref linkend="runtime">을 참조 바란다.
	     </para>
	    </step>
	
	    <step>
	     <para>
	백업으로부터 복구하는 경우 버전이 명시된 것이 아니라면 이전 설치 디렉토리의 이름을 변경하거나 디렉토리를 삭제해야 한다. 문제가 발생해서 되돌아 가야 할 때를 대비해서 디렉토리를 삭제하는 것보다는 이름을 변경하는 것이 낫다. 디렉토리는 디스크 공간을 상당량 차지한다는 사실을 잊으면 안 된다. 디렉토리 이름을 변경하려면 다음과 같은 명령을 사용한다.
	<screen>
	<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</>
	</screen>
	     (디렉토리를 단일 유닛으로 이동하여 관련 경로가 바뀌지 않게 해야 한다.)
	     </para>
	    </step>
	
	    <step>
	     <para>
	<productname>Agens SQL</productname> 새 버전은 <![%standalone-include[the next section.]]>
	      <![%standalone-ignore[install-procedure.]]>에 요약된 대로 설치한다.
	     </para>
	    </step>
	
	    <step>
	     <para>
	필요 시 데이터베이스 클러스터를 새로 생성한다. 특수한 데이터베이스 사용자 계정(업그레이드 중 이미 보유하고 있는)으로 로그인한 상태에서 이 명령을 실행해야 한다는 것을 잊으면 안 된다.
	
	<programlisting>
	<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
	</programlisting>
	     </para>
	    </step>
	
	    <step>
	     <para>
	이전 <filename>pg_hba.conf</> 및 모든 <filename>Agens SQL.conf</> 수정 내용을 복원한다.
	     </para>
	    </step>
	
	    <step>
	     <para>
	특수 데이터베이스 사용자 계정을 사용하여 데이터베이스 서버를 다시 시작한다.
	<programlisting>
	<userinput>/usr/local/pgsql/bin/agens -D /usr/local/pgsql/data</>
	</programlisting>
	     </para>
	    </step>
	
	    <step>
	     <para>
	마지막으로 다음 명령으로 데이터를 복원한다.
	<screen>
	<userinput>/usr/local/pgsql/bin/psql -d agens -f <replaceable>outputfile</></userinput>
	</screen>
	이때 <emphasis>새</> <application>psql</>을 사용한다.
	     </para>
	    </step>
	   </procedure>
	
	   <para>
	새 서버를 다른 디렉토리에 설치하고 이전 및 새 서버를 서로 다른 포트에서 병렬 실행하면 다운타임을 최소화할 수 있다. 그런 다음, 사용자는 데이터를 전송하기 위해 다음과 같은 명령어를 사용할 수 있다.
	
	<programlisting>
	pg_dumpall -p 5432 | psql -d agens -p 5433
	</programlisting>
	이 명령으로 데이터가 전송된다.
	   </para>
	
	  </sect2>
	
	  <sect2 id="upgrading-via-pg-upgrade">
	   <title><application>pg_upgrade</>를 통한 데이터 업그레이드</title>
	
	   <para>
	pgupgrade 모듈은 메이저 <productname>Agens SQL</> 버전에서 다른 버전으로 현재 위치에 마이그레이션되는 설치를 허용한다. 특별히 <option>--link</> 모드를 사용하면 수 분 이내에 업그레이드가 가능하다. 이것은 위의 <application>pg_dumpall</>과 유사한 단계가 필요하다(예: 서버 시작/중지, <application>initdb</> 실행). <application>pg_upgrade</>문서에는 필수 단계가 간략하게 나와 있다.
	   </para>
	
	  </sect2>
	
	  <sect2 id="upgrading-via-replication">
	   <title>복제를 통한 데이터 업그레이드</title>
	
	   <para>
	<productname>Slony</> 같은 특정한 복제 방법을 사용하여 <productname>Agens SQL</> 업그레이드 버전의 스탠바이 서버를 생성할 수도 있다. 이것은 Slony가 메이저 <productname>Agens SQL</> 버전 간 복제를 지원하기 때문에 가능하다. 스탠바이는 동일한 컴퓨터 또는 다른 컴퓨터에 있는 것일 수 있다. 일단 마스터 서버(<productname>Agens SQL</>의 이전 버전 실행 중)와 동기화되면, 마스터 서버를 전환하고 마스터 서버를 스탠바이한 상태에서 이전 데이터베이스 인스턴스를 셧다운할 수 있다. 따라서 이러한 전환 방식에 의하면, 업그레이드 다운타임이 수 초에 불과하게 된다.
	   </para>
	
	  </sect2>
	 </sect1>
	
	 <sect1 id="preventing-server-spoofing">
	  <title>서버 스푸핑 방지</title>
	
	  <indexterm zone="preventing-server-spoofing">
	   <primary>서버 스푸핑</primary>
	  </indexterm>
	
	  <para>
	서버 실행 중에 악의적 사용자가 정상적인 데이터베이스 서버를 차지하는 것은 불가능하다. 단, 서버 다운 시 로컬 사용자가 자신의 서버를 시작함으로써 정상적인 서버를 스푸핑하는 것은 가능하다. 스푸핑 서버는 클라이언트가 보낸 패스워드와 쿼리를 읽을 수 있지만 디렉토리 권한 때문에 <varname>PGDATA</> 디렉토리는 보호되므로 데이터를 리턴할 수는 없다. 어떤 사용자든 데이터베이스 서버를 시작할 수 있으므로 스푸핑이 가능하다. 특수하게 환경 설정되지 않은 경우 클라이언트가 잘못된 서버를 식별해낼 수는 없다.
	  </para>
	
	  <para>
	<literal>local</> 연결에 대한 스푸핑을 방지하는 가장 간단한 방법은 신뢰된 로컬 사용자에 대해서만 쓰기 권한이 있는 Unix 도메인 소켓 디렉토리(<xref
	   linkend="guc-unix-socket-directories">)를 사용하는 것이다. 이로써 악의적 사용자가 자체 소켓 파일을 해당 디렉토리에 생성하는 것이 방지된다. 일부 어플리케이션이 소켓 파일로 <filename>/tmp</>를 계속 참조해야 해서 스푸핑에 취약한 경우라면 운영 체제 시작 시에 위치 변경된 소켓 파일을 가리키는 심볼릭 링크 <filename>/tmp/.s.PGSQL.5432</>를 생성해야 한다. 또한 사용자의 <filename>/tmp</> 클린업 스크립트를 수정해서 심볼릭 링크가 삭제되지 않게 해야 한다.
	  </para>
	
	  <para>
	TCP 연결에 대한 스푸핑을 방지하기 위한 최고의 해결책은 SSL 인증서를 사용하여 클라이언트가 서버 인증서를 확인하게 하는 것이다. 이렇게 하려면 <literal>hostssl</> 연결만 수락하고(<xref
	   linkend="auth-pg-hba-conf">) SSL 키와 인증서 파일(<xref linkend="ssl-tcp">)을 갖도록 서버를 환경 설정해야 한다. TCP 클라이언트는 <literal>sslmode=verify-ca</> 또는 <literal>verify-full</>을 사용하여 연결해야 하며, 적절한 루트 인증서 파일이 설치되어야 한다.
	  </para>
	 </sect1>
	
	 <sect1 id="encryption-options">
	  <title>암호화 옵션</title>
	
	  <indexterm zone="encryption-options">
	   <primary>암호화</primary>
	  </indexterm>
	
	  <para>
	<productname>Agens SQL</productname>은 데이터베이스 서버 도난, 비양심적인 관리자 및 불안정한 네트워크로 인해 데이터가 공개되지 않도록 보호하는 데 있어 몇 가지 단계의 암호화와 유연성을 제공한다. 또한 암호화는 의료 기록 또는 금융 트랜잭션 같은 중요 데이터의 보호를 위해서도 필요하다.
	  </para>
	
	  <variablelist>
	
	  <varlistentry>
	   <term>패스워드 스토리지 암호화</term>
	   <listitem>
	
	    <para>
	기본적으로 데이터베이스 사용자 패스워드는 MD5 해시로 저장되므로 사용자에게 할당된 실제 패스워드를 관리자가 판단할 수 없다. 클라이언트 인증에 MD5 암호화를 사용하는 경우, 네트워크를 통해 전송하기 전에 클라이언트가 MD5 암호화를 실행하므로 잠시라도 암호화되지 않는 패스워드가 서버에 제공되지 않는다.
	    </para>
	   </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>특정 컬럼에 대한 암호화</term>
	
	   <listitem>
	    <para>
	pgcrypto 모듈은 특정 필드를 암호화해서 저장하는 것을 허용한다. 일부 데이터만 중요한 경우에 이것이 유용하다. 클라이언트가 암호 해독 키를 제공하고 데이터가 서버에서 암호 해독된 다음, 클라이언트로 전송된다.
	    </para>
	
	    <para>
	암호 해독된 데이터 및 암호 해독 키는 암호가 해독되고 클라이언트와 서버 간에 통신이 일어나는 짧은 시간 동안 서버에 제공된다. 여기에는 시스템 관리자처럼 데이터베이스 서버에 대한 전체 액세스 권한이 있는 누군가가 데이터와 키를 가로챌 수 있는 짧은 순간이 존재한다.
	    </para>
	   </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>데이터 파티션 암호화</term>
	
	   <listitem>
	    <para>
	스토리지 암호화는 파일 시스템 레벨 또는 블록 레벨에서 수행된다. Linux 파일 시스템 암호화 옵션에는 eCryptfs 및 EncFS가 포함되는 반면, FreeBSD는 PEFS를 사용한다. 블록 레벨 또는 풀 디스크 암호화 옵션에는, Linux에서는 dm-crypt + LUKS가 포함되고 FreeBSD에서는 GEOM 모듈 geli 및 gbde가 포함된다. Windows를 비롯한 여러 가지 다른 운영 체제에서 이 기능이 지원된다.
	    </para>
	
	    <para>
	드라이브 또는 전제 컴퓨터가 도난 당한 경우 이 메커니즘은 암호화되지 않은 데이터를 드라이브에서 읽지 못하게 한다. 파일 시스템이 마운트될 때 운영 체제가 암호화되지 않은 데이터 뷰를 제공하므로 파일 시스템이 마운트된 상태에서는 공격으로부터 데이터를 보호하지 못한다. 그러나, 파일 시스템을 마운트하려면 암호화 키를 운영 체제에 전달하는 방법이 필요하며, 디스크를 마운트하는 호스트 어딘가에 키를 저장해야 할 때도 있다.
	    </para>
	   </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>네트워크에서 패스워드 암호화</term>
	
	   <listitem>
	     <para>
	<literal>MD5</> 인증 방법은 서버로 전송하기 전에 클라이언트에서 패스워드를 이중으로 암호화한다. 데이터베이스가 연결되면 이것은 먼저 사용자 이름을 기준으로 MD5 암호화한 다음, 서버에 의해 전송되는 랜덤 salt를 기준으로 암호화된다. 이것이 네트워크를 통해 서버에 전송되는 이중 암호화된 값이다. 이중 암호화는 패스워드 검색을 방지하는 것 외에도, 동일한 암호화된 패스워드를 사용하여 나중에 데이터베이스 서버에 연결하는 새로운 연결도 방지한다.
	     </para>
	    </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>네트워크에서 데이터 암호화</term>
	
	    <listitem>
	     <para>
	SSL 연결은 네트워크로 전송된 모든 데이터(패스워드, 쿼리 및 리턴 데이터)를 암호화한다. <filename>pg_hba.conf</> 파일은 어떤 호스트가 암호화되지 않은 연결을 사용할 수 있는지(<literal>host</>) 및 어떤 것이 SSL-암호화된 연결을 요구하는지(<literal>hostssl</>)를 관리자가 지정할 수 있게 한다. 또한 클라이언트는 SSL을 통해서만 서버에 연결하도록 지정 가능하다. <application>Stunnel</> 또는 <application>SSH</>는 전송을 암호화할 때에도 사용할 수 있다.
	     </para>
	    </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>SSL 호스트 인증</term>
	
	   <listitem>
	    <para>
	이것은 클라이언트 및 서버 양쪽에서 서로 간에 SSL 인증서를 제공하는 것이 가능하다. 양쪽에서 추가적인 설정이 일부 필요하지만 이로써 단순히 패스워드만 사용하는 것보다 훨씬 강력한 ID 검증이 가능하다. 이것은 클라이언트가 보낸 패스워드를 읽는 데 필요한 시간만큼 컴퓨터가 서버인 척하는 것을 방지한다. 또한 클라이언트와 서버 사이에 있는 컴퓨터가 서버인 척 해서 클라이언트와 서버 사이의 모든 데이터를 읽고 전달하는 <quote>중간자(man in the middle)</> 공격을 방지하는 데에도 효과가 있다.
	    </para>
	   </listitem>
	  </varlistentry>
	
	  <varlistentry>
	   <term>클라이언트 측 암호화</term>
	
	   <listitem>
	    <para>
	서버 머신의 시스템 관리자를 신뢰할 수 없는 경우 클라이언트가 데이터를 암호화해야 한다. 이러한 방식으로 암호화되지 않은 데이터를 데이터베이스 서버에 절대 나타나지 않는다. 데이터는 서버로 전송되기 전에 클라이언트에서 암호화되고 데이터베이스 결과는 사용 전에 클라이언트에서 암호가 해독되어야 한다.
	    </para>
	   </listitem>
	  </varlistentry>
	
	  </variablelist>
	
	 </sect1>
	
	 <sect1 id="ssl-tcp">
	  <title>SSL을 사용한 TCP/IP 연결 보호</title>
	
	  <indexterm zone="ssl-tcp">
	   <primary>SSL</primary>
	  </indexterm>
	
	  <para>
	<productname>Agens SQL</>은 <acronym>SSL</> 연결을 사용하여 보안 강화를 위한 클라이언트/서버 통신을 암호화하는 기본적인 지원이 있다. 이것은 클라이언트와 서버 시스템에 <productname>OpenSSL</productname>을 설치해야 하고 <productname>Agens SQL</>에서의 지원이 빌드 시 활성화되어야 한다. 
	  </para>
	
	  <para>
	컴파일된 <acronym>SSL</> 지원을 사용함으로써 <filename>Agens SQL.conf</>에서 파라미터 <xref linkend="guc-ssl">을 <literal>on</>으로 설정하면 <acronym>SSL</>를 활성화한 상태로 <productname>Agens SQL</> 서버를 시작할 수 있다. 서버는 동일한 TCP 포트에서 일반 및 <acronym>SSL</> 연결을 listen하고 <acronym>SSL</> 연결 여부에 대해 클라이언트 연결을 성사시킨다. 기본적으로 이것은 클라이언트의 옵션이다. 일부 또는 모든 연결에 대해 <acronym>SSL</>의 사용을 요구하도록 서버를 설정하는 방법은 <xref
	   linkend="auth-pg-hba-conf">을 참조 바란다.
	  </para>
	
	  <para>
	<productname>Agens SQL</productname>은 시스템 차원(system-wide)의 <productname>OpenSSL</productname> 환경 설정 파일을 판독한다. 기본적으로 이 파일의 이름은 <filename>openssl.cnf</filename>이고 <literal>openssl version -d</>로 보고된 디렉토리에 위치한다. 이러한 기본값은 환경 변수 <envar>OPENSSL_CONF</envar>를 원하는 환경 설정 파일 이름에 설정함으로써 덮어쓸 수 있다.
	  </para>
	
	  <para>
	<productname>OpenSSL</productname>은 다양한 암호화 및 다양한 레벨의 인증 알고리즘을 지원한다. 암호 목록을 <productname>OpenSSL</productname> 환경 설정 파일에 지정할 수 있는 반면, <filename>Agens SQL.conf</>에서 <xref linkend="guc-ssl-ciphers">를 수정함으로써 데이터베이스 서버에서 특별히 사용하기 위한 암호를 사용자가 지정할 수 있다.
	  </para>
	
	  <note>
	   <para>
	<literal>NULL-SHA</> 또는 <literal>NULL-MD5</> 암호를 사용하여 암호화 오버헤드 없이 인증을 하는 것이 가능하다. 단, 중간자(man-in-the-middle)는 클라이언트와 서버 사이의 통신을 판독하고 패스할 수 있다. 또한 암호화 오버헤드는 인증 오버헤드에 비해 아주 적다. 이러한 이유로, NULL 암호는 권장되지 않는다.
	   </para>
	  </note>
	
	  <para>
	<acronym>SSL</> 모드에서 시작하려면 서버 인증서가 포함된 파일과 개인 키가 존재해야 한다. 기본적으로, 이러한 파일은 각각 서버의 데이터 디렉토리에서 이름이 <filename>server.crt</> 및 <filename>server.key</>일 것으로 예상되지만, 환경 설정 파라미터  <xref linkend="guc-ssl-cert-file"> 및 <xref linkend="guc-ssl-key-file">을 사용하여 다른 이름과 위치를 지정할 수 있다. Unix 시스템에서 <filename>server.key</filename>에 대한 권한은 월드 또는 그룹에 대한 액세스를 불허해야 한다. 이것은 <command>chmod 0600 server.key</command> 명령에 의해 수행된다. 개인 키가 암호로 보호되는 경우 서버는 암호를 묻는 메시지를 표시하고 암호가 입력되기 전에는 서버가 시작되지 않는다.
	  </para>
	
	  <para>
	경우에 따라 서버 인증서를 클라이언트가 직접 신뢰하지 않고 <quote>중간</> 인증 기관에서 서명할 수 있다. 해당 인증서를 사용하려면 <filename>server.crt</> 파일에 서명 기관의 인증서를 첨부한 다음, 해당 상급 기관의 인증서를 첨부하는 순으로 클라이언트에 의해 신뢰된 인증 기관, <quote>root</> 또는 <quote>중간</>까지 첨부한다(예를 들면 클라이언트의 <filename>root.crt</filename> 파일에서 인증서로 서명된).
	  </para>
	
	  <sect2 id="ssl-client-certificates">
	   <title>클라이언트 인증서 사용</title>
	
	   <para>
	신뢰된 인증서 제공을 클라이언트에게 요구하려면 사용자가 신뢰하는 인증 기관(<acronym>CA</acronym>)의 인증서를 데이터 디렉토리의 <filename>root.crt</filename> 파일에 삽입하고, <filename>Agens SQL.conf</filename>의 <xref linkend="guc-ssl-ca-file"> 파라미터를 <literal>root.crt</literal>로 설정하고 <filename>pg_hba.conf</>의 적절한 <literal>hostssl</> 라인에서 <literal>clientcert</literal>파라미터를 1로 설정해야 한다. 그러면, SSL 연결 시작 중에 인증서가 클라이언트로부터 요청된다. 서버는 클라이언트 인증서가 신뢰된 인증 기관 중 한 곳에서 서명된 것인지 검증한다. 중간 <acronym>CA</>가 <filename>root.crt</filename>에 나타나면 파일에도 루트 <acronym>CA</>에 인증서 체인이 포함되어야 한다. <xref linkend="guc-ssl-crl-file"> 파라미터가 설정된 경우 Certificate Revocation List (CRL) 항목도 확인된다. (SSL 인증서 사용을 보여주는 다이어그램은 <ulink
	   url="http://h71000.www7.hp.com/DOC/83final/BA554_90007/ch04s02.html"></> 참조)
	  </para>
	
	  <para>
	   <filename>pg_hba.conf</>의 <literal>clientcert</literal> 옵션은 모든 인증 방법에서 사용할 수 있지만 <literal>hostssl</>로 지정된 행에만 해당된다. <literal>clientcert</literal>가 지정되지 않았거나 0으로 설정되면, 환경 설정된 것이 있을 경우 서버가 CA 목록 대비 제공된 클라이언트 인증서를 계속 검증하지만, 클라이언트 인증서의 제공을 요구하지는 않는다.
	  </para>
	
	  <para>
	서버의 <filename>root.crt</filename>는 클라이언트 인증서 서명을 위해 신뢰된 것으로 간주되는 최상위 CA가 나열되어 있다. 대부분의 경우 클라이언트 인증서에 대해 CA를 신뢰하더라도 원칙적으로는 서버의 인증서를 서명한 CA를 나열할 필요는 없다.
	
	  </para>
	
	  <para>
	사용자가 클라이언트 인증서를 설정하는 경우 <literal>cert</> 인증 방법을 사용한다면 인증서로 사용자 인증을 제어하고 연결 보안도 제공할 수 있다. 자세한 내용은 <xref linkend="auth-cert">을 참조 바란다.
	  </para>
	  </sect2>
	
	  <sect2 id="ssl-server-files">
	   <title>SSL 서버 파일 사용</title>
	
	   <para>
	    <xref linkend="ssl-file-usage">는 서버에서 SSL 설정과 관련된 파일들을 요약한 것이다. (표시된 파일 이름은 기본값 또는 일반적인 이름이다. 로컬로 환경 설정된 이름은 다를 수 있다.)
	   </para>
	
	  <table id="ssl-file-usage">
	   <title>SSL 서버 파일 사용</title>
	   <tgroup cols="3">
	    <thead>
	     <row>
	      <entry>파일</entry>
	      <entry>내용</entry>
	      <entry>효과</entry>
	     </row>
	    </thead>
	
	    <tbody>
	
	     <row>
	      <entry><xref linkend="guc-ssl-cert-file"> (<filename>$PGDATA/server.crt</>)</entry>
	      <entry>서버 인증서</entry>
	      <entry>클라이언트로 전송되어 서버 ID 표시</entry>
	     </row>
	
	     <row>
	      <entry><xref linkend="guc-ssl-key-file"> (<filename>$PGDATA/server.key</>)</entry>
	      <entry>서버 개인 키</entry>
	      <entry>소유자가 보낸 서버 인증서 검증; 인증서 소유자가 믿을만하다는 것을 나타내지는 않음</entry>
	     </row>
	
	     <row>
	      <entry><xref linkend="guc-ssl-ca-file"> (<filename>$PGDATA/root.crt</>)</entry>
	      <entry>신뢰된 인증서 기관</entry>
	      <entry>클라이언트 인증서가 신뢰된 인증 기관에 의해 서명되었는지 확인</entry>
	     </row>
	
	     <row>
	      <entry><xref linkend="guc-ssl-crl-file"> (<filename>$PGDATA/root.crl</>)</entry>
	      <entry>인증 기관에서 취소된 인증서</entry>
	      <entry>클라이언트가 인증서가 이 목록에 있으면 안 됨</entry>
	     </row>
	
	    </tbody>
	   </tgroup>
	  </table>
	
	   <para>
	    <filename>server.key</>, <filename>server.crt</>,
	    <filename>root.crt</filename> 및 <filename>root.crl</filename>
	    파일(또는 환경 설정된 다른 이름)은 서버 시작 중에만 검사되므로 변경 내용을 적용하려면 서버를 재시작해야 한다.
	   </para>
	  </sect2>
	
	  <sect2 id="ssl-certificate-creation">
	   <title>자체 서명된 인증서 생성</title>
	
	   <para>
	서버용 자체 서명된 인증서를 빠르게 생성하려면 다음과 같은 <productname>OpenSSL</productname> 명령을 사용해야 한다.
	<programlisting>
	openssl req -new -text -out server.req
	</programlisting>
	<application>openssl</>이 요청하는 정보를 입력하고, 로컬 호스트 이름을 <quote>Common Name</>으로 입력했는지 확인한다. 챌린지 패스워드는 비워둘 수 있다. 프로그램은 보호된 패스프레이즈인 키를 생성한다. 4글자 미만의 패스프레이즈는 수락되지 않는다. 패스프레이즈를 삭제하려면(서버의 자동 시작을 원하는 경우처럼) 다음 명령을 실행한다.
	<programlisting>
	openssl rsa -in privkey.pem -out server.key
	rm privkey.pem
	</programlisting>
	    이전 패스프레이즈를 입력하여 기존 키를 해제하기 위해 아래와 같이 입력한다.
	<programlisting>
	openssl req -x509 -in server.req -text -key server.key -out server.crt
	</programlisting>
	    그러면 인증서가 자체 서명된 인증서로 전환되고, 서버가 찾는 위치로 키와 인증서가 복사된다. 마지막으로, 다음과 같이 입력한다.
	<programlisting>
	chmod og-rwx server.key
	</programlisting>
	이렇게 하는 이유는 권한이 이것보다 좀 더 자유로운 경우에 서버가 파일을 거부하기 때문이다. 서버 개인 키와 인증서를 생성하는 방법에 대한 자세한 내용은 <productname>OpenSSL</> 문서를 참조 바란다.
	   </para>
	
	   <para>
	자체 서명된 인증서를 테스트용으로 사용할 수 있지만 클라이언트가 서버 ID를 검증할 수 있도록 인증 기관(<acronym>CA</>) (전역 <acronym>CA</> 또는 로컬 CA 중 하나)에 의해 서명된 인증서는 실제 운영 중에 사용되어야 한다. 모든 클라이언트가 기관에 대해 로컬인 경우 로컬 <acronym>CA</>를 사용하는 것이 권장된다.
	   </para>
	
	  </sect2>
	
	 </sect1>
	
	 <sect1 id="ssh-tunnels">
	  <title><application>SSH</application> 터널을 사용하여 TCP/IP 연결 보호</title>
	
	  <indexterm zone="ssh-tunnels">
	   <primary>ssh</primary>
	  </indexterm>
	
	  <para>
	클라이언트와 <productname>Agens SQL</productname> 서버 간 네트워크 연결을 암호화하기 위해 <application>SSH</application>를 사용할 수 있다. 제대로 된 경우 이것은 SSL이 불가능한 클라이언트에 대해서도 적절한 네트워크 연결 보호를 제공한다.
	  </para>
	
	  <para>
	먼저 <application>SSH</application> 서버가 <productname>Agens SQL</productname> 서버와 동일한 머신에서 올바로 실행 중인지 확인하고 <command>ssh</command>를 사용하여 일부 사용자로 로그인할 수 있는지 확인한다. 그런 다음, 클라이언트 머신에서 아래와 같은 명령을 사용하여 보안 터널을 설정할 수 있다.
	<programlisting>
	ssh -L 63333:localhost:5432 joe@foo.com
	</programlisting>
	<option>-L</option> 의 첫 번째 인수 63333은 터널 종단의 포트 번호이며, 미사용 포트는 무엇이든 가능하다. (IANA는 개인용으로 포트 49152 ~ 65535를 제공한다.) 두 번째 숫자 5432는 터널의 원거리 종단: 서버가 사용 중인 포트 번호이다. 포트 번호 간의 이름 또는 IP 주소는 연결하려는 데이터베이스 서버가 있는 호스트이며, 이 예시에서 <literal>foo.com</literal>인 로그인되어 있는 호스트에서 표시된다. 이 터널을 사용하여 데이터베이스 서버에 연결하기 위해 사용자는 로컬 머신의 포트 63333에 연결한다.
	<programlisting>
	psql -h localhost -p 63333 agens
	</programlisting>
	이것은 해당 문맥의 <literal>localhost</literal>에 연결하는 <literal>foo.com</literal> 호스트에서 사용자가 정말로 데이터베이스 서버에 대한 <literal>joe</literal> 사용자인 것처럼 보이게 하고, 이 사용자와 호스트로부터의 연결에 대해 환경 설정된 대로 인증 절차를 사용한다. 사실, <application>SSH</application> 서버와 <productname>Agens SQL</productname> 서버 사이가 암호화되지 않으므로 서버는 연결이 SSL로 암호화되어 있지 않다고 생각하게 된다. 동일한 머신에 있는 것이 아니라면 이것은 어떠한 추가적인 보안 위험을 드러내지 않을 것이다.
	  </para>
	
	  <para>
	터널 설정이 성공하려면 사용자가 <command>ssh</command>를 사용하여 터미널 세션을 생성하려고 하는 것처럼 <literal>joe@foo.com</literal>로써 <command>ssh</command>를 통한 연결이 허용되어야 한다
	  </para>
	
	  <para>
	   사용자는 다음과 같이 포트 포워딩을 설정할 수도 있다.
	<programlisting>
	ssh -L 63333:foo.com:5432 joe@foo.com
	</programlisting>
	그러나 데이터베이스 서버가 <literal>foo.com</literal> 인터페이스에서 들어오는 연결을 보게 되는데, 이것은 기본 설정 <literal>listen_addresses =
	   'localhost'</literal>에 의해서는 개방되지 않는다. 보통 이것은 사용자가 원하는 바가 아니다.
	  </para>
	
	  <para>
	일부 로그인 호스트를 통해 데이터베이스 서버에 <quote>hop</quote>해야 한다면 가능한 설정 중 하나는 다음과 같을 것이다.
	<programlisting>
	ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
	</programlisting>
	<literal>shell.foo.com</literal>에서 <literal>db.foo.com</literal>으로의 이러한 연결 방법은 SSH 터널에서 암호화되지 않는다는 점에 유의해야 한다. 다양한 방법으로 네트워크가 제한되는 경우에 SSH는 가능한 환경 설정을 다수 제공한다. 자세한 내용은 SSH 문서를 참조 바란다.
	  </para>
	
	  <tip>
	   <para>
	    방금 설명한 개념과 유사한 절차를 사용하여 보안 터널을 제공할 수 있는 몇 가지 다른 어플리케이션이 존재한다.
	   </para>
	  </tip>
	
	 </sect1>
	
	 <sect1 id="event-log-registration">
	  <title><systemitem class="osname">Windows</>에 <application>이벤트 로그</> 등록</title>
	
	  <indexterm zone="event-log-registration">
	   <primary>이벤트 로그</primary>
	   <secondary>이벤트 로그</secondary>
	  </indexterm>
	
	  <para>
	<systemitem class="osname">Windows</> <application>이벤트 로그</> 라이브러리를 운영 체제에 등록하려면 다음 명령을 실행해야 한다.
	<screen>
	<userinput>regsvr32 <replaceable>pgsql_library_directory</>/pgevent.dll</>
	</screen>
	이것은 <literal>Agens SQL</literal>이라는 기본 이벤트 소스 하에서, 이벤트 뷰어가 사용하는 레지스트리 항목을 생성한다.
	  </para>
	
	  <para>
	이벤트 소스 이름을 다르게 지정하려면(<xref linkend="guc-event-source"> 참조), <literal>/n</literal> 및 <literal>/i</literal> 옵션을 사용해야 한다.
	<screen>
	<userinput>regsvr32 /n /i:<replaceable>event_source_name</> <replaceable>pgsql_library_directory</>/pgevent.dll</>
	</screen>
	  </para>
	
	  <para>
	운영 체제에서 <application>이벤트 로그</> 라이브러리를 등록 취소하려면 아래 명령을 실행해야 한다.
	<screen>
	<userinput>regsvr32 /u [/i:<replaceable>event_source_name</>] <replaceable>pgsql_library_directory</>/pgevent.dll</>
	</screen>
	  </para>
	
	  <note>
	   <para>
	데이터베이스 서버에서 이벤트 로깅을 활성화하려면 <xref linkend="guc-log-destination">을 수정하여 <filename>Agens SQL.conf</filename>에서 <literal>eventlog</literal>를 포함해야 한다.
	   </para>
	  </note>
	 </sect1>
	
	</chapter>
	
	
