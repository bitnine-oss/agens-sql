<chapter id="slonyI">
    <title>Slony-I</title>

    <para>
        <productname>Slony-I</productname>는 지속적이고, 장애 극복을 지원하기 위한 master와 다중 slave replication 시스템이다. <productname>PostgreSQL</productname> 9.0 부터 지원하는 streaming replication 방식이 더 간단할 수 있지만 WAL-based replication 구성이 불가능한 경우나 데이터베이스 전체가 아닌 부분 replication이 필요한 경우에는 효과적이다. 
    </para>
    
    <para>
        <productname>Slony-I</productname>의 특징은 다음과 같다.
        <ItemizedList>
            <listitem>
                <para>
                    <productname>Slony-I</productname>는 <productname>PostgreSQL</productname>의 다른 주요 버전간에 데이터 replication가 가능하다.
                </para>
            </listitem>
            <listitem>
                <para>
                    <productname>Slony-I</productname>는 다른 물리장치와 OS간에 데이터 replication가 가능하다.
                </para>
            </listitem>
            <listitem>
                <para>
                    <productname>Slony-I</productname>는 slave로 테이블 단위의 replication만을 허락한다.
                </para>
            </listitem>
            <listitem>
                <para>
                    <productname>Slony-I</productname>는 하나 이상의 slave에 테이블 단위의 replication를 허락한다.
                </para>
            </listitem>
            <listitem>
                <para>
                    <productname>Slony-I</productname>는 다른 데이터베이스 서버가 다른 테이블의 마스터가 될 수 있다.
                </para>
            </listitem>
        </ItemizedList>
    </para>

    <para>
        <productname>Agens SQL</productname>에서 제공하는 <productname>Slony-I</productname>의 버전은 2.2.4 버전을 사용한다. 이 메뉴얼에서는 간단한 설명과 초기 시작 방법에 대해서 다룬다. 자세한 내용은 <ulink url="http://slony.info/documentation/2.2/index.html"><productname>Slony-I</productname> 공식 문서</ulink>를 참고하기 바란다.
    </para>

    <sect1 id="slonyi-def">
        <title><productname>Slony-I</productname> 개념 정의</title>

        <para>
            이번 절에서는 <productname>Slony-I</productname>를 이해하기 위한 용어를 설명한다.
        </para>

        <sect2 id="slonyi-cluster">
            <title>Cluster</title>

            <para>
                Cluster는 <productname>PostgreSQL</productname> 데이터베이스 인스턴스들 묶어 주는 이름을 말한다. Replication은 동일한 cluster명으로 묶인 데이터베이스들 간에 동작한다. Cluster명은 <command>Slonik</command> 스크립트에 다음과 같이 직접적으로 명시한다.
            </para>

            <para>
                <ProgramListing>#!/bin/sh

slonik <<_EOF_
                cluster name = something;
...</ProgramListing>
            </para>

            <para>
                Cluster명을 <command>something</command>으로 한다면, <productname>Slony-I</productname>는 각각의 데이터베이스는 _something으 cluster명으로 묶인다.
            </para>

        </sect2>

        <sect2 id="slonyi-node">
            <title>Node</title>

            <para>
                Slony-I 노드는 replication에 참여하는 PostgreSQL의 데이터베이스 이름이다. Node는 Slonik 스크립트에 직접적으로 작성하여 사용하고, 작성방법은 다음과 같다.
            </para>

            <para>
                <ProgramListing>#!/bin/sh

slonik <<_EOF_
...
                NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
                NODE 2 ADMIN CONNINFO = 'dbname=testdbslave host=server1slave user=slony';
...</ProgramListing>
            </para>

            <para>
                ADMIN CONNINFO는 데이터베이스 접속 정보를 나타낸다. 이 정보는 libpq 함수의 PQconnectdb()로 넘겨진다.
            </para>

        </sect2>

        <sect2 id="slonyi-replication">
            <title>Replication Set</title>

            <para>
                Replication Set은 Slony-I 클러스터의 노드들 간에 복제되는 테이블들과 시쿼스의 집합으로 정의 된다.
                Replication Set은 여러가지 세트를 가질수 있고, replication의 "flow"는 동일할 필요가 없다.
            </para>

        </sect2>

        <sect2 id="slonyi-def-more">
            <title>Origin, Providers 그리고 Subscribers</title>

            <para>
                Replication Set은 테이블의 데이터를 수정하고 복제될 데이터를 가지고 있는 origin 노드를 가지고 있다. 이 origin 는 origin 또는 master provider라고 한다. Slonik 스크립트에서 작성은 다음과 같다.
            </para>

            <para>
                <ProgramListing>#!/bin/sh

slonik <<_EOF_
...
        create set (id=1, origin=1, comment='All pgbench tables');
        set add table (set id=1, origin=1, id=1, fully qualified name = 'public.pgbench_accounts', comment='accounts table');
        set add table (set id=1, origin=1, id=2, fully qualified name = 'public.pgbench_branches', comment='branches table');
        set add table (set id=1, origin=1, id=3, fully qualified name = 'public.pgbench_tellers', comment='tellers table');
        set add table (set id=1, origin=1, id=4, fully qualified name = 'public.pgbench_history', comment='history table');
...</ProgramListing>
            </para>

            <para>
               Subscribers는 slave 노드를 뜻한다. origin 또는 master provider의 변경이 있으면 slave 노드의 테이블의 값을 변경 한다. 
            </para>

        </sect2>

    </sect1>

    <sect1 id="slonyi-example1">
        <title><productname>Slony-I</productname> 구동 예제 (1)</title>
        <subtitle>간단한 replication</subtitle>

        <para>
            이번절에서는 로컬 데이터베이스로 master-slave를 구성하여 <productname>Slony-I</productname>를 구동하는 예제를 보인다. 
        </para>

        <para>
            
        </para>

        <orderedlist>
            <listitem>
            <para>환경변수 설정</para>

            <para>
                자주 사용해야 하는 변수는 다음과 같이 환경 변수로 등록후에 사용하면 편리하다. 다음은 환경변수를 임시로 설정하는 방법이다. 다른 방법은 <filename>.bashrc</filename> 파일 또는 <filename>.bash_profile</filename> 파일에 등록 후에 사용하면 편하게 설정 할 수 있다.
            </para>

            <para>
                <ProgramListing>export CLUSTERNAME=slony_example
export MASTERDBNAME=pgbench
export SLAVEDBNAME=pgbenchslave
export MASTERHOST=localhost
export SLAVEHOST=localhost
export REPLICATIONUSER=postgres
export PGBENCHUSER=pgbench</ProgramListing>
            </para>
            </listitem>

            <listitem>
            <para>데이터베이스 사용자 생성</para>

            <para>
                다음 명령어는 데이터베이스 사용자를 생성하는 명령어이다. 사용자의 이름은 <command>pgbench</command>로 만들고 생성 옵션 <command>-SRD</command>를 줌으로써  superuser가 아니고 role을 생성하지 않고 데이터베이스를 생성하지 않는 사용자를 만드는 명령어이다.
            </para>

            <para>
                <ProgramListing><userinput>createuser -SRD $PGBENCHUSER</userinput></ProgramListing>
            </para>
            </listitem>

            <listitem>
            <para>데이터베이스 생성</para>

            <para>
                다음 명령어는 master 노드와 slave 노드를 구성하는 두 개의 데이터베이스를 생성한 후에 마스터 노드에 <command>pgbench</command>를 실행하여 데이터를 생성하는 명령어 이다.
            </para>

            <para>
                <ProgramListing>createdb -O $PGBENCHUSER -h $MASTERHOST $MASTERDBNAME
createdb -O $PGBENCHUSER -h $SLAVEHOST $SLAVEDBNAME
pgbench -i -s 1 -U $PGBENCHUSER -h $MASTERHOST $MASTERDBNAME</ProgramListing>
            </para>

            <para>
                <productname>Slony-I</productname>는 replication을 실행하려고 하는 테이블에 primary key가 존재 해야한다. 다음 명령어는 pgbench_history 테이블에 primary key를 생성하는 명령어이다.
            </para>

            <para>
                <ProgramListing>psql -U $PGBENCHUSER -h $MASTERHOST -d $MASTERDBNAME -c "begin;
alter table pgbench_history add column id serial;
update pgbench_history set id = nextval('pgbench_history_id_seq');
alter table pgbench_history add primary key(id);
commit;"</ProgramListing>
            </para>

            <para>
                <productname>Slony-I</productname>는 자동적으로 DDL 명령을 실행 하지 못한다. 따라서 다음 명령어로 master 노드의 테이블 스키마를 slave 노드에 생성 시켜주어야 한다.
            </para>

            <para>
                <ProgramListing>pg_dump -s -U $REPLICATIONUSER -h $MASTERHOST $MASTERDBNAME | psql -U $REPLICATIONUSER -h $SLAVEHOST $SLAVEDBNAME</ProgramListing>
            </para>
            </listitem>

            <listitem>
            <para><productname>Slony-I</productname>를 사용한 replication 시작</para>

            <para>
                다음 스크립트는 <command>slonik</command> 설정 프로세서를 실행하여 <productname>Slony-I</productname>의 설정을 하는 스크립트이다.
            </para>

            <para>
                <ProgramListing>#!/bin/sh

slonik <<_EOF_
    #--
    # define the namespace the replication system uses in our example it is
    # slony_example
    #--
    cluster name = $CLUSTERNAME;

    #--
    # admin conninfo's are used by slonik to connect to the nodes one for each
    # node on each side of the cluster, the syntax is that of PQconnectdb in
    # the C-API
    # --
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    #--
    # init the first node.  This creates the schema
    # _$CLUSTERNAME containing all replication system specific database
    # objects.

    #--
    init cluster ( id=1, comment = 'Master Node');
 
    #--
    # Slony-I organizes tables into sets.  The smallest unit a node can
    # subscribe is a set.  The following commands create one set containing
    # all 4 pgbench tables.  The master or origin of the set is node 1.
    #--
    create set (id=1, origin=1, comment='All pgbench tables');
    set add table (set id=1, origin=1, id=1, fully qualified name = 'public.pgbench_accounts', comment='accounts table');
    set add table (set id=1, origin=1, id=2, fully qualified name = 'public.pgbench_branches', comment='branches table');
    set add table (set id=1, origin=1, id=3, fully qualified name = 'public.pgbench_tellers', comment='tellers table');
    set add table (set id=1, origin=1, id=4, fully qualified name = 'public.pgbench_history', comment='history table');

    #--
    # Create the second node (the slave) tell the 2 nodes how to connect to
    # each other and how they should listen for events.
    #--

    store node (id=2, comment = 'Slave node', event node=1);
    store path (server = 1, client = 2, conninfo='dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER');
    store path (server = 2, client = 1, conninfo='dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER');
_EOF_</ProgramListing>
            </para>

            <para>
                스크립트의 이름은 상관이 없지만 이 예제에서는 <filename>slony-conf.sh</filename>로 생성한다. 다음은 해당 스크립트에 실행 권한을 준 후에 실행하는 명령어이다.
            </para>

            <para>
                <ProgramListing><prompt>localhost</prompt> $ <userinput><command>[sudo]chmod a+x ./<filename>slony-conf.sh</filename></command></userinput>
<prompt>localhost</prompt> $ <userinput><command>./<filename>slony-conf.sh</filename></command></userinput></ProgramListing>
            </para>

            <para>
                다음에는 <productname>Slony-I</productname> replication 데몬을 실행시켜준다. 첫 줄은 master 노드의 <productname>Slony-I</productname> 데몬을 실행 하는 명령어이다. 다음 줄은 slave 노드의 <productname>Slony-I</productname> 데몬을 실행 하는 명령어이다.
            </para>

            <para>
                <ProgramListing><prompt>localhost</prompt> $ <userinput><command>slon $CLUSTERNAME "dbname=$MASTERDBNAME user=$REPLICATIONUSER host=$MASTERHOST"</command></userinput>
<prompt>localhost</prompt> $ <userinput><command>slon $CLUSTERNAME "dbname=$SLAVEDBNAME user=$REPLICATIONUSER host=$SLAVEHOST"</command></userinput></ProgramListing>
            </para>

            <para>
                Replication을 시작 하기 위해 다음 스크립트 파일을 생성 후 시작 한다.
            </para>

            <para>
                <ProgramListing>#!/bin/sh

slonik <<_EOF_
    # ----
    # This defines which namespace the replication system uses
    # ----
    cluster name = $CLUSTERNAME;

    # ----
    # Admin conninfo's are used by the slonik program to connect
    # to the node databases.  So these are the PQconnectdb arguments
    # that connect from the administrators workstation (where
    # slonik is executed).
    # ----
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    # ----
    # Node 2 subscribes set 1
    # ----
    subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);
_EOF_</ProgramListing>
            </para>

            <para>
                위의 스크립트를 <filename>sloni-start.sh</filename>로 만든 후 실행 시켜주면 성공적으로 replication이 동작된 것을 확인 할 수 있다.
            </para>

            <para>
                <ProgramListing><prompt>localhost</prompt> $ <userinput><command>[sudo]chmod a+x ./<filename>sloni-start.sh</filename></command></userinput>
<prompt>localhost</prompt> $ <userinput><command>./<filename>sloni-start.sh</filename></command></userinput></ProgramListing>
            </para>
            </listitem>
        </orderedlist>

    </sect1>

    <sect1 id="slonyi-example2">
        <title><productname>Slony-I</productname> 구동 예제 (2)</title>
        <subtitle>테이블 스키마 변경</subtitle>

        <para>
            이번 절에서는 <productname>Slony-I</productname>가 동작하고 있는 상태에서 master 노드와 slave 노드의 테이블 스키마를 변경하는 방법에 대해 예제를 통해 살펴본다. 이번 절의 예제는 <productname>Slony-I</productname> 구동 예제 (1)가 동작하고 있는 상태를 전제로 한다.
        </para>

        <orderedlist>
            <listitem>
                <para>해당 스크립트에 실행 권한을 주고 실행 시킨다.
                </para>

                <para>
                    <ProgramListing>#!/bin/sh

slonik <<_EOF_
    # ----
    # This defines which namespace the replication system uses
    # ----
    cluster name = $CLUSTERNAME;

    # ----
    # Admin conninfo's are used by the slonik program to connect
    # to the node databases.  So these are the PQconnectdb arguments
    # that connect from the administrators workstation (where
    # slonik is executed).
    # ----
    node 1 admin conninfo = 'dbname=$MASTERDBNAME host=$MASTERHOST user=$REPLICATIONUSER';
    node 2 admin conninfo = 'dbname=$SLAVEDBNAME host=$SLAVEHOST user=$REPLICATIONUSER';

    # ----
    # Node 2 subscribes set 1
    # ----
    subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);
_EOF_</ProgramListing>
                </para>
            </listitem>

            <listitem>
                <para>slonik 설정 프로세서를 동작 시키기 위해 다음 스크립트를 작성 한다.
                </para>

                <para>
                    <ProgramListing><prompt>localhost</prompt> $ <userinput><command>[sudo]chmod a+x ./<filename>table_schema_change.sh</filename></command></userinput>
<prompt>localhost</prompt> $ <userinput><command>./<filename>table_schema_change.sh</filename></command></userinput></ProgramListing>
                </para>

            </listitem>

            <listitem>
                <para>테이블 변경이 제대로 되었는지 확인 하기 위해 SQL 명령을 확인 해 본다.
                </para>

                <para>
                    <ProgramListing><prompt>pgbench</prompt>=# <userinput><command>select * from pgbench_tellers;</command></userinput>
 tid | bid | tbalance | filler | date 
-----+-----+----------+--------+------
   1 |   1 |        0 |        | 
   2 |   1 |        0 |        | 
   3 |   1 |        0 |        | 
   4 |   1 |        0 |        | 
   5 |   1 |        0 |        | 
   6 |   1 |        0 |        | 
   7 |   1 |        0 |        | 
   8 |   1 |        0 |        | 
   9 |   1 |        0 |        | 
  10 |   1 |        0 |        | 
(10 rows)</ProgramListing>
                </para>

                <para>
                    위와 같이 Master 노드의 테이블이 변경된 것을 확인 할 수 있다. Slave 노드에서도 동일한 SQL 명령을 확인해 보면 다음과 같이 변경된 것을 확인 할 수 있다.
                </para>

                <para>
                    <ProgramListing><prompt>pgbenchslave</prompt>=# <userinput><command>select * from pgbench_tellers;</command></userinput>
 tid | bid | tbalance | filler | date 
-----+-----+----------+--------+------
   1 |   1 |        0 |        | 
   2 |   1 |        0 |        | 
   3 |   1 |        0 |        | 
   4 |   1 |        0 |        | 
   5 |   1 |        0 |        | 
   6 |   1 |        0 |        | 
   7 |   1 |        0 |        | 
   8 |   1 |        0 |        | 
   9 |   1 |        0 |        | 
  10 |   1 |        0 |        | 
(10 rows)</ProgramListing>
                </para>
            </listitem>
        </orderedlist>
    </sect1>
</chapter>

