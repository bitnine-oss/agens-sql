<chapter id="pgbouncer">
 <title><productname>PgBouncer</productname></title>
 <para>
     <productname>PgBouncer</productname>는 Connection Pooling 기능을 제공하기 위한 모듈로써, 다수의 트랜잭션 및 클라이언트의 DB 연결 작업이 필요한 OLTP 환경에서 최적의 리소스 활용 효율을 제공하여 준다.
     <productname>PgBouncer</productname>에 대한 자세한 정보는 <ulink url="https://pgbouncer.github.io"> https://pgbouncer.github.io</ulink>에서 확인하기 바란다. 다음 그림은 <productname>PgBouncer</productname>에 대한 개괄적인 아키텍쳐 그림이다. 해당 그림은 <productname>PgBouncer</productname> 내에 다수의 pool과 각각의 안에 client user명/연결 DB명의 순서쌍으로 명명된 connection들을 지님을 보여 주고 있다. 
 </para>
 <screenshot>
     <screeninfo>PgBouncer architecture</screeninfo>
     <graphic fileref="images/pgbouncer_architecture.png">
 </screenshot>
 <sect1 id="pgbouncer-configuration">
     <title>설정</title>
     <para>
         <productname>Agens SQL</productname>을 통해 <productname>PgBouncer</productname>를 설치한 후, 실제 사용을 하기 위해서는 <filename>.ini</filename>환경파일의 설정이 필요하다. 본 장에서는 개괄적인 <filename>.ini</filename>환경파일 설정에 대하여 알아보도록 한다. 편의상 <filename>pgbouncer.ini</filename>라는 이름으로 환경파일을 설정하겠다. 파일명은 확장자가 <filename>.ini</filename>라는 것을 전제하에 얼마든지 변경가능하다.
     </para>
     <itemizedlist>
         <listitem>
             <para><filename>pgbouncer.ini</filename>파일은 [databases] 설정과 [pgbouncer] 설정, 이렇게 두 가지 파트로 이루어진다.
             </para>
                 <para>
                     <command>$ vi pgbouncer.ini</command>
                     <programlisting>
[databases]
db = ...
[pgbouncer]
...
                     </programlisting>
                 </para>
                 <para>[databases] 파트의 db는 DB 연결명이다. <productname>psql</productname>과 같은 클라이언트 유틸리티를 통해 연결 대상 DB 명을 지정한 값과 대응된다. 해당 값은 경우에 따라 실제 존재하는 DB 명일수도, 단순한 alias 이름일 수도 있다.</para>
             <itemizedlist>
                 <listitem>
                     <para>[databases] 파트</para>
                     <para>[databases] 파트는 클라이언트가 접속할 DB의 Connection Pooling 관련 속성을 담는다. 클라이언트는 최초 DB 연결시 본 파트의 속성에 따라 연결을 성립시키게 된다. 다음은 해당 속성의 대표적인 예와 그에 대한 설명이다.
                     </para>
                     <itemizedlist>
                         <listitem>
                             <para>dbname</para>
                             <para>dbname은 <productname>PgBouncer</productname>를 통해 연결되는 DB의 이름이다.
                             </para>
                             <orderedlist numeration="loweralpha">
                                 <listitem>
                                     <para>
                                         dbname을 명시하지 않을 경우
                                     </para>
                                     <para>
                                         DB 연결명과 동일한 DB로 연결이 된다. 만약 DB 연결명에 명시된 것과 동일한 DB가 존재하지 않는다면 <productname>PgBouncer</productname>는 연결을 거부한다.
                                     </para>
                                 </listitem>
                                 <listitem>
                                     <para>
                                         dbname을 명시할 경우
                                     </para>
                                     <para>
                                         해당 연결은 DB 연결명이 어떠한 이름이든 간에(실제 DB명이거나 연결에 대한 alias명이거나) dbname에 명시된 DB로 연결이 된다. 이러한 점은 fallback DB를 이용하는 환경에서 역시 유용하게 쓰일 수 있다.
                                     </para>
                                 </listitem>
                             </orderedlist>
                         </listitem>
                         <listitem>
                             <para>host</para>
                             <para>host에는 접속하려는 DB가 있는 곳의 ip 주소가 들어가게 된다.</para>
                         </listitem>
                         <listitem>
                             <para>port</para>
                             <para>port는 <productname>PgBouncer</productname>가 <productname>Agens SQL</productname>에 연결할 때에 사용될 port 번호이다. <productname>Agens SQL</productname>이 허용하고 있는 port번호를 명시하면 된다.</para>
                         </listitem>
                         <listitem>
                             <para>user</para>
                             <para>user는 <productname>PgBouncer</productname>를 통해 DB에 연결시 사용될 유저의 이름을 명시한다. 해당 값이 명시될 경우 클라이언트 측에서 어떠한 DB유저명으로 접속을 하려 하든 user에 명시된 유저로 접속하게 된다.</para>
                         </listitem>
                     </itemizedlist>
                 </listitem>
                 <listitem>
                     <para>[pgbouncer] 파트</para>
                     <para>[pgbouncer] 파트는 클라이언트가 <productname>PgBouncer</productname>에 연결할 시에 적용받게 되는 속성들을 명시한다. 다음은 해당 속성의 대표적인 예와 그에 대한 설명이다.</para>
                     <itemizedlist>
                         <listitem>
                             <para>logfile, pidfile</para>
                             <itemizedlist>
                                 <listitem>
                                     <para>logfile</para>
                                     <para>logfile에 나타난 파일명에 <productname>PgBouncer</productname>의 log정보를 남기게 된다.</para>
                                 </listitem>
                                 <listitem>
                                     <para>pidfile</para>
                                     <para><productname>PgBouncer</productname>를 시스템의 background에서 daemon화 시켜 수행하기 위해서는 pidfile에 파일명을 명시하여야 한다.</para>
                                 </listitem>
                             </itemizedlist>
                         </listitem>
                         <listitem>
                             <para>listen_port</para>
                             <para>listen_port는 <productname>PgBouncer</productname>으로의 접속 port를 명시한다. 클라이언트 측에서는 해당 port를 통하여 <productname>Agens SQL</productname>에 접속하여야만 PgBouncer의 Connection Pooling 기능을 사용할 수 있다.</para>
                         </listitem>
                         <listitem>
                             <para>auth_file, auth_type</para>
                             <itemizedlist>
                                 <listitem>
                                     <para>auth_file</para>
                                     <para>
                                         auth_file 속성은 <productname>PgBouncer</productname>에 접속할 계정 정보(유저명, 비밀번호)를 담고 있는 파일을 명시한다.
                                     </para>
                                 </listitem>
                                 <listitem>
                                     <para>auth_type</para>
                                     <para>
                                         auth_type은 유효한 유저에 대한 판별은 어떻게 입증할 것 인지에 대한 속성이다. <productname>Agens SQL</productname>이 단순한 비밀번호 방식으로 유저 유효성을 검사할 경우에는 plain을 명시하고, md5 방식으로 유저 유효성을 검사할 경우 md5를 명시하면 된다. 이때 md5를 이용한 검증을 하기 위해서는 auth_file내에 md5화된 암호를 기술하여야 한다. 이에 대한 자세한 설명은 공식 문서 <ulink url="https://pgbouncer.github.io/config.html#authentication-file-format">https://pgbouncer.github.io/config.html#authentication-file-format</ulink>을 참고하기 바란다.
                                     </para>
                                 </listitem>
                             </itemizedlist>
                         </listitem>
                         <listitem>
                             <para>pool_mode</para>
                             <para><productname>PgBouncer</productname>는 세가지 방식의 pooling 모드를 제공한다. session pooling, transaction pooling, statement pooling이 바로 그것이다. pool_mode 속성은 이에 대한 바를 명시한다.</para>
                         </listitem>
                         <listitem>
                             <para>max_client_conn</para>
                             <para><productname>PgBouncer</productname>를 통해 Agens SQL에 접속할 수 있는 클라이언트의 개수를 설정한다. 클라이언트는 해당 속성에 명시된 값 이상으로 <productname>PgBouncer</productname>를 통한 DB 연결을 성립시킬 수가 없다.</para>
                         </listitem>
                         <listitem>
                             <para>admin_users</para>
                             <para>admin_users에 DB 유저이름을 넣음으로써 <productname>PgBouncer</productname> 가상 DB를 통해 <productname>PgBouncer</productname>의 상태 정보를 실시간으로 모니터링 할 수 있다.</para>
                         </listitem>
                     </itemizedlist>
                 </listitem>
             </itemizedlist>
         </listitem>
     </itemizedlist>
 </sect1>
 <sect1 id="pgbouncer-quickstart">
     <title>Quick Start</title>
     <para>
         <productname>PgBouncer</productname>는 세가지의 pooling 방식을 지원한다(session, transaction, statement). 본 장에서는 간단한 예제를 통하여 이 세 가지의 pooling 방식을 살펴본다.
     </para>
     <itemizedlist>
         <listitem>
             <para><productname>PgBouncer</productname>의 구동과 모니터링</para>
             <itemizedlist>
                 <listitem>
                     <para><productname>PgBouncer</productname> 구동</para>
                     <para><productname>PgBouncer</productname>가 설치된 디렉토리 내에서 환경설정 <filename>.ini</filename>파일을 인자로 넘겨주어 다음과 같이 실행한다.</para>
                     <para><command>$ pgbouncer pgbouncer.ini</command></para>
                     <para><productname>PgBouncer</productname>를 데몬화 시켜서 백그라운드에서 실행되게 하기 위해서는 상기 커맨드에 -d 옵션을 추가하여 수행한다. 이때 <filename>.ini</filename>에 pidfile 속성이 명시되어 있어야 한다.</para>
                     <para><command>$ pgbouncer -d pgbouncer.ini</command></para>
                 </listitem>
                 <listitem>
                     <para><productname>PgBouncer</productname> 모니터링</para>
                     <para><productname>PgBouncer</productname>를 백그라운드에서 실행하게 하면 손쉬운 모니터링이 가능하다. 모니터링을 위해서는 <filename>.ini</filename>파일의 admin_user에 명시되어 있는 유저를 이용하여 pgbouncer DB에 접속한다.</para>
                     <para>
                     <screen>
<prompt>[agens@localhost ~]$</prompt> <userinput>psql -p 6432 -U postgres pgbouncer</userinput>
<computeroutput>
Password for user postgres:<userinput></userinput>
psql (9.4.2, server 1.5.5/bouncer)
Type "help" for help.

<prompt>pgbouncer=#</prompt>
</computeroutput></screen>
                     </para>
                     <para>pgbouncer DB에 연결된 상태에서 help 명령을 누르면 <productname>PgBouncer</productname>가 지원하는 명령어가 나오며 이 명령어들을 활용하여 실시간 모니터링 및 <productname>PgBouncer</productname> 제어가 가능하다.</para>
<screen><prompt>pgbouncer=#</prompt> <userinput>show help;</userinput>
<computeroutput>NOTICE:  Console usage
DETAIL:  
    SHOW HELP|CONFIG|DATABASES|POOLS|CLIENTS|SERVERS|VERSION
    SHOW STATS|FDS|SOCKETS|ACTIVE_SOCKETS|LISTS|MEM
    SHOW DNS_HOSTS|DNS_ZONES
    SET key = arg
    RELOAD
    PAUSE [&lt;db&gt;]
    RESUME [&lt;db&gt;]
    KILL &lt;db&gt;
    SUSPEND
    SHUTDOWN
SHOW</computeroutput>
<prompt>pgbouncer=#</prompt></screen>
                 </listitem>
             </itemizedlist>
         </listitem>
         <listitem>
             <para><productname>PgBouncer</productname>의 Connection State</para>
             <para><productname>PgBouncer</productname>에서 구분짓는 Connection의 대표적인 State에 대해서 간략히 알아보겠다.(하기 명시된 State명은 이해를 돕기위해 show pools 명령에 의해 나오는 정보를 기준으로 작성된 것이며 정식 명칭은 아니다.)</para>
             <itemizedlist>
                 <listitem>
                     <para>sv_active</para>
                     <para>서버 연결이 열려 있으며 현재 특정 클라이언트가 사용 중인 상태이다.</para>
                 </listitem>
                 <listitem>
                     <para>sv_idle</para>
                     <para>서버 연결이 열려 있으며 클라이언트와는 연결이 안되어 있는 상태이다. 새로운 클라이언트와의 연결이 언제라도 가능한 상태이며 내부적으로는 server_reset_query(session feature 초기화)가 불려졌으며 server_check_delay로 지정된 시간보다 적은 시간을 머문 상태이다.</para>
                 </listitem>
                 <listitem>
                     <para>sv_used</para>
                     <para>서버 연결이 열려있으며 sv_idle상태에서 server_check_delay로 지정된 시간을 초과하여 옮겨진 상태이다. 새로운 클라이언트와의 연결을 통해 reuse를 하기 위해서는 server_check_query가 호출되어야 한다.</para>
                 </listitem>
                 <listitem>
                     <para>sv_tested</para>
                     <para>server_reset_query 혹은 server_check_query에 의해 test가 진행 중인 상태이다. 테스트가 완료 되면 sv_idle 상태로 옮겨진다.</para>
                 </listitem>
                 <listitem>
                     <para>sv_login</para>
                     <para>서버 연결이 열려있으며 현재 DB에 login한 상태이다.</para>
                 </listitem>
             </itemizedlist>
         </listitem>
         <listitem>
             <para><productname>PgBouncer</productname>의 세 가지 pooling 방식</para>
             <para>세 가지 각각의 pooling방식을 간단한 예제를 통해 살펴보도록 하겠다. 이에 앞서 기본적인 <filename>.ini</filename>파일의 설정은 다음과 같으며 session pooling, transaction pooling은 auto commit 모드를 끈 상태로 진행된다.</para>
             <screen>
<prompt>[agens@localhost bin]$</prompt><userinput>vi pgbouncer.ini</userinput>

<computeroutput>
[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = session
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</computeroutput>
</screen>
<para>또한 <productname>PgBouncer</productname>를 백그라운드에서 실행한다.</para>
<screen>
<computeroutput>
<prompt>[agens@localhost bin]$</prompt> <userinput>pgbouncer -d pgbouncer.ini </userinput>
2015-06-08 00:49:20.702 6351 LOG File descriptor limit: 1024 (H:4096), max_client_conn: 3, max fds possible: 33
</computeroutput>
</screen>
             <orderedlist numeration="loweralpha">
                 <listitem>
                     <para>session pooling</para>
                     <para>클라이언트 측에서 연결을 해제할 시에 서버연결은 pool로 반환된다. 다음은 session pooling을 위한 예제이다.</para>
                     <para>먼저 초기상태의 pool상태를 확인한다.</para>
                     <screen>
<prompt>[agens@localhost bin]$</prompt> <userinput>psql -p 6432 -U postgres pgbouncer</userinput>
<computeroutput>Password for user postgres:<userinput></userinput> 
psql (9.4.2, server 1.5.5/bouncer)
Type "help" for help.

<prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>
                     <para>이제 클라이언트의 접속을 시도하고 다시 pool정보를 살펴본다. cl_active가 1로 변하여 클라이언트의 접속이 이루어졌다는 것을 살펴볼 수 있다.</para>
                     <screen>
<prompt>[agens@localhost ~]$</prompt> <userinput>psql -p 6432 -U kim test1</userinput>
<computeroutput>Password for user kim: <userinput></userinput>
psql (9.4.2)
Type "help" for help.

<prompt>test1=#</prompt></computeroutput>
                     </screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>
                     <para>다음 클라이언트측에서 간단한 질의를 입력하고 commit을 입력한 후 다시 pool의 정보를 살펴본다. sv_active가 1이 되어 현재 1개의 클라이언트가 서버에 연결되어 사용 중이라는 것을 알 수 있다.</para>
                     <screen>
<computeroutput><prompt>test1=#</prompt> <userinput>select * from table1;</userinput>
 a | b 
---+---
(0 rows)
</computeroutput>

<prompt>test1=#</prompt> <userinput>commit;</userinput>
</screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>
                     <para>이제 클라이언트에서 연결을 끊고 pool을 살펴본다. cl_active가 0으로 되어 클라이언트의 연결이 끊어졌고 방금 사용한 연결은 sv_idle상태로 옮겨졌음을 볼 수 있다. 그리고 일정시간(<filename>.ini</filename>파일의 server_check_delay에 명시된 시간)이 지난 후 다시 pool의 상태정보를 보면 sv_used 상태로 다시 옮겨졌음을 볼 수 있다. </para>
                     <screen>
<computeroutput><prompt>test1=#</prompt> <userinput>\q</userinput>
</computeroutput>
</screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       1 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>
                     <para>이 상태에서 다시 클라이언트가 다시 연결을 시도하여 질의를 수행하면 sv_used 상태에 있었던 연결이 sv_active로 옮겨져 재사용 되었음을 알 수 있다.</para>
                     <screen>
<prompt>[agens@localhost ~]$</prompt> <userinput>psql -p 6432 -U kim test1</userinput>
<computeroutput>Password for user kim: <userinput></userinput>
psql (9.4.2)
Type "help" for help.

<prompt>test1=#</prompt> <userinput>select * from table1;</userinput></computeroutput>
                     </screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>                     
                 </listitem>
                 <listitem>
                     <para>transaction pooling</para>
                     <para>트랜잭션이 완료되면 서버연결은 pool로 반환된다. 다음은 transaction pooling을 위한 예제이다.</para>
                     <para>먼저 <filename>.ini</filename>파일의 pool_mode = transaction으로 고친다.</para>
                     <screen>
<prompt>[agens@localhost bin]$</prompt><userinput>vi pgbouncer.ini</userinput>

<computeroutput>
[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = transaction
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</computeroutput>
</screen>
                     <para>다음 RELOAD 명령을 통하여 <productname>PgBouncer</productname>의 새로운 환경설정을 다시 로드한다.</para>
                     <screen><computeroutput>
<prompt>pgbouncer=#</prompt> <userinput>RELOAD;</userinput>
RELOAD
<prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)
</computeroutput>
</screen>
                     <para>이제 클라이언트에서 새롭게 접속을 하고 질의를 수행한 후 pool의 상태정보를 확인한다. cl_active와 sv_active가 1이 되어 현재 클라이언트 1명이 작업중임을 알 수 있다.</para>
                     <screen>
<computeroutput><prompt>[agens@localhost ~]$</prompt> <userinput>psql -p 6432 -U kim test1</userinput>
Password for user kim:<userinput></userinput> 
psql (9.4.2)
Type "help" for help.

<prompt>test1=#</prompt> <userinput>select * from table1;</userinput>
 a | b 
---+---
(0 rows)

<prompt>test1=#</prompt></computeroutput>
</screen>
<screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)</computeroutput>
</screen>
                     <para>이제 클라이언트 측에서 commit을 수행하여 pool의 정보를 확인한다. session 모드에서와는 다르게 sv_active가 0이 되고 sv_idle이 1이 되어 있음을 확인할 수 있다.</para>
                     <screen>
<computeroutput><prompt>test1=#</prompt> <userinput>commit;</userinput>
COMMIT
<prompt>test1=#</prompt>
</computeroutput>
</screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)</computeroutput>
                     </screen>
                     <para>이제 다시 질의를 수행하여 pool을 살펴본다. sv_idle에 있던 1이 sv_active로 옮겨갔음을 확인할 수 있다. 만약 질의 수행을 server_check_delay에 명시된 시간보다 늦게 하였다면 sv_idle에서 sv_used로 옮겨간게 다시 sv_active로 옮겨가 연결을 재사용하였음을 확인할 수 있다.</para>
<screen><computeroutput>
<prompt>test1=#</prompt> <userinput>select * from table1;</userinput>
 a | b 
---+---
(0 rows)</computeroutput></screen>
<screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         1 |       0 |       0 |         0 |        0 |       0
(2 rows)</computeroutput>
</screen>
                     <para>이제 commit을 하여 sv_idle상태로 전이된 연결을 확인한다. 이와 같이 transaction pooling 모드에서는 transaction의 시작과 완료 기점을 중심으로 클라이언트와의 연결을 성립 및 해제한다.</para>
<screen>
<computeroutput><prompt>test1=#</prompt> <userinput>commit;</userinput>
COMMIT
<prompt>test1=#</prompt>
</computeroutput>
</screen>
                     <screen>
<computeroutput><prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)</computeroutput>
                     </screen>
                 </listitem>
                 <listitem>
                     <para>statement pooling</para>
                     <para>개별의 Query가 끝날시에 서버연결은 pool로 반환된다. Autocommit모드가 활성화된다. 앞선 예제와 마찬가지로 <filename>.ini</filename>파일의 pool_mode를 statement로 변경한다.</para>
<screen>
<prompt>[agens@localhost bin]$</prompt><userinput>vi pgbouncer.ini</userinput>

<computeroutput>
[databases]
test1 = host=127.0.0.1 port=5432 dbname=test user=postgres
[pgbouncer]
listen_port = 6432
listen_addr = *
auth_file = users.txt
auth_type = plain
max_client_conn = 3
pool_mode = statement
pidfile = pgbouncer.pid
admin_users = postgres
server_check_query = SELECT 1;
server_check_delay = 10</computeroutput>
</screen>
                     <para>다음 RELOAD 명령을 통하여 <productname>PgBouncer</productname>의 새로운 환경설정을 다시 로드한다.</para>
                     <screen><computeroutput>
<prompt>pgbouncer=#</prompt> <userinput>RELOAD;</userinput>
RELOAD
<prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         0 |          0 |         0 |       0 |       0 |         0 |        0 |       0
(2 rows)
</computeroutput>
</screen>                     
                     <para>새로운 클라이언트로 접속 후 질의를 수행하여 pool의 상태를 확인한다. statement가 수행된 이후 이전의 예에서와는 달리 sv_active에 머무르지 않고 바로 sv_idle상태로 옮겨진 것을 볼 수 있다.</para>
                     <screen>
<prompt>[agens@localhost ~]$</prompt> <userinput>psql -p 6432 -U kim test1</userinput>
Password for user kim: <userinput></userinput>
psql (9.4.2)
Type "help" for help.

<prompt>test1=#</prompt> <userinput>select * from table1;</userinput>
 a | b 
---+---
(0 rows)

<prompt>test1=#</prompt>
</screen>
                     <screen><computeroutput>
<prompt>pgbouncer=#</prompt> <userinput>show pools;</userinput>
 database  |   user    | cl_active | cl_waiting | sv_active | sv_idle | sv_used | sv_tested | sv_login | maxwait 
-----------+-----------+-----------+------------+-----------+---------+---------+-----------+----------+---------
 pgbouncer | pgbouncer |         1 |          0 |         0 |       0 |       0 |         0 |        0 |       0
 test1     | postgres  |         1 |          0 |         0 |       1 |       0 |         0 |        0 |       0
(2 rows)

<prompt>pgbouncer=#</prompt></computeroutput>
                     </screen>

                 </listitem>
             </orderedlist>
         </listitem>
     </itemizedlist>
 </sect1>
</chapter>
